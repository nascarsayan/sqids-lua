{"source_files":[{"name":"\/Users\/nascarsayan\/Code\/github.com\/nascarsayan\/sqids-lua\/lua_modules\/share\/lua\/5.4\/busted\/block.lua","coverage":[0,0,0,null,null,0,0,0,null,0,null,0,null,null,null,3,3,null,3,1428,0,null,null,null,3,84,84,1512,1428,1344,null,null,null,null,null,0,0,0,0,null,null,3,252,null,252,168,168,0,null,null,null,252,27,null,252,252,225,null,null,27,27,0,0,0,null,null,null,27,null,27,null,null,3,279,null,279,168,168,0,null,null,null,279,null,279,279,0,0,0,null,null,279,null,null,3,306,306,null,306,306,0,0,0,null,null,null,306,168,0,null,null,306,null,null,3,84,null,null,3,27,27,27,null,null,null,3,27,null,null,3,27,null,null,3,24,null,24,24,24,0,0,0,null,null,null,24,24,0,24,0,0,null,null,24,24,null,null,24,24,null,null,null,3,null],"source":"local getfenv = require 'busted.compatibility'.getfenv\nlocal unpack = require 'busted.compatibility'.unpack\nlocal shuffle = require 'busted.utils'.shuffle\n\nlocal function sort(elements)\n  table.sort(elements, function(t1, t2)\n    if t1.name and t2.name then\n      return t1.name < t2.name\n    end\n    return t2.name ~= nil\n  end)\n  return elements\nend\n\nreturn function(busted)\n  local block = {}\n  local root = busted.context.get()\n\n  function block.reject(descriptor, element)\n    element.env[descriptor] = function(...)\n      error(\"'\" .. descriptor .. \"' not supported inside current context block\", 2)\n    end\n  end\n\n  function block.rejectAll(element)\n    local env = getfenv(element.run)\n    block.reject('randomize', element)\n    for descriptor, _ in pairs(busted.executors) do\n      if root.env[descriptor] and (env ~= _G and env[descriptor] or rawget(env, descriptor)) then\n        block.reject(descriptor, element)\n      end\n    end\n  end\n\n  local function exec(descriptor, element)\n    if not element.env then element.env = {} end\n    block.rejectAll(element)\n    local ret = { busted.safe(descriptor, element.run, element) }\n    return unpack(ret)\n  end\n\n  function block.execAllOnce(descriptor, current, err)\n    local parent = busted.context.parent(current)\n\n    if parent then\n      local success = block.execAllOnce(descriptor, parent)\n      if not success then\n        return success\n      end\n    end\n\n    if not current[descriptor] then\n      current[descriptor] = {}\n    end\n    local list = current[descriptor]\n    if list.success ~= nil then\n      return list.success\n    end\n\n    local success = true\n    for _, v in ipairs(list) do\n      if not exec(descriptor, v):success() then\n        if err then err(descriptor) end\n        success = false\n      end\n    end\n\n    list.success = success\n\n    return success\n  end\n\n  function block.execAll(descriptor, current, propagate, err)\n    local parent = busted.context.parent(current)\n\n    if propagate and parent then\n      local success, ancestor = block.execAll(descriptor, parent, propagate)\n      if not success then\n        return success, ancestor\n      end\n    end\n\n    local list = current[descriptor] or {}\n\n    local success = true\n    for _, v in ipairs(list) do\n      if not exec(descriptor, v):success() then\n        if err then err(descriptor) end\n        success = nil\n      end\n    end\n    return success, current\n  end\n\n  function block.dexecAll(descriptor, current, propagate, err)\n    local parent = busted.context.parent(current)\n    local list = current[descriptor] or {}\n\n    local success = true\n    for _, v in ipairs(list) do\n      if not exec(descriptor, v):success() then\n        if err then err(descriptor) end\n        success = nil\n      end\n    end\n\n    if propagate and parent then\n      if not block.dexecAll(descriptor, parent, propagate) then\n        success = nil\n      end\n    end\n    return success\n  end\n\n  function block.lazySetup(element, err)\n    return block.execAllOnce('lazy_setup', element, err)\n  end\n\n  function block.lazyTeardown(element, err)\n    if element.lazy_setup and element.lazy_setup.success ~= nil then\n      block.dexecAll('lazy_teardown', element, nil, err)\n      element.lazy_setup.success = nil\n    end\n  end\n\n  function block.setup(element, err)\n      return block.execAll('strict_setup', element, nil, err)\n  end\n\n  function block.teardown(element, err)\n      return block.dexecAll('strict_teardown', element, nil, err)\n  end\n\n  function block.execute(descriptor, element)\n    if not element.env then element.env = {} end\n\n    local randomize = busted.randomize\n    local randomseed = busted.randomseed\n    element.env.randomize = function(...)\n      randomize = (select('#', ...) == 0 or ...)\n      if randomize then\n        randomseed = tonumber(({...})[1]) or tonumber(({...})[2]) or randomseed\n      end\n    end\n\n    if busted.safe(descriptor, element.run, element):success() then\n      if busted.sort then\n        sort(busted.context.children(element))\n      elseif randomize then\n        element.randomseed = randomseed\n        shuffle(busted.context.children(element), randomseed)\n      end\n\n      if block.setup(element) then\n        busted.execute(element)\n      end\n\n      block.lazyTeardown(element)\n      block.teardown(element)\n    end\n  end\n\n  return block\nend"},{"name":"\/Users\/nascarsayan\/Code\/github.com\/nascarsayan\/sqids-lua\/lua_modules\/share\/lua\/5.4\/busted\/compatibility.lua","coverage":[0,0,84,null,84,null,null,159,159,159,null,84,null,null,0,12,null,12,null,null,12,12,12,null,12,12,12,null,null,12,null,null,null,null,null,null,0,0,0,0,null,0,0,null,null,null,null,null,null,0,0,0,0,0,0,0,0,null,null,null,0,null,null,null,0,null,null,null,null],"source":"return {\n  getfenv = getfenv or function(f)\n    f = (type(f) == 'function' and f or debug.getinfo(f + 1, 'f').func)\n    local name, value\n    local up = 0\n\n    repeat\n      up = up + 1\n      name, value = debug.getupvalue(f, up)\n    until name == '_ENV' or name == nil\n\n    return name and value or _G\n  end,\n\n  setfenv = setfenv or function(f, t)\n    f = (type(f) == 'function' and f or debug.getinfo(f + 1, 'f').func)\n    local name\n    local up = 0\n\n    repeat\n      up = up + 1\n      name = debug.getupvalue(f, up)\n    until name == '_ENV' or name == nil\n\n    if name then\n      debug.upvaluejoin(f, up, function() return name end, 1)\n      debug.setupvalue(f, up, t)\n    end\n\n    if f ~= 0 then return f end\n  end,\n\n  loadstring = loadstring or load,\n  unpack = table.unpack or unpack,\n\n  exit = function(code, force)\n    if not force and code ~= 0 and _VERSION:match('^Lua 5%.[12]$') then\n      error()\n    elseif code ~= 0 then\n      code = 1\n    end\n    if _VERSION == 'Lua 5.1' and\n      (type(jit) ~= 'table' or not jit.version or jit.version_num < 20000) then\n      -- From Lua 5.1 manual:\n      -- > The userdata itself is freed only in the next\n      -- > garbage-collection cycle.\n      -- Call collectgarbage() while collectgarbage('count')\n      -- changes + 3 times, at least 3 times,\n      -- at max 100 times (to prevent infinite loop).\n      local times_const = 0\n      for i = 1, 100 do\n        local count_before = collectgarbage(\"count\")\n        collectgarbage()\n        local count_after = collectgarbage(\"count\")\n        if count_after == count_before then\n          times_const = times_const + 1\n          if times_const > 3 then\n            break\n          end\n        else\n          times_const = 0\n        end\n      end\n    end\n    os.exit(code, true)\n  end,\n\n  execute = require 'pl.utils'.execute,\n}"},{"name":"\/Users\/nascarsayan\/Code\/github.com\/nascarsayan\/sqids-lua\/lua_modules\/share\/lua\/5.4\/busted\/context.lua","coverage":[0,null,null,12,456,444,null,12,12,12,12,12,null,null,null,12,468,456,null,456,null,444,0,null,null,984,972,null,null,null,null,0,null,0,0,0,0,0,null,0,0,0,null,null,0,0,0,0,0,null,0,0,null,0,0,null,0,0,null,null,null,null,null,null,108,108,12,96,0,96,0,null,108,null,null,null,108,108,0,null,108,12,null,null,null,0,2808,0,null,null,0,0,null,null,0,0,0,0,0,0,0,null,null,0,108,108,108,null,null,0,30,null,null,0,9525,null,null,0,438,438,438,438,null,null,0,438,438,438,438,null,null,0,null,null,0,null],"source":"local tablex = require 'pl.tablex'\n\nlocal function save()\n  local g = {}\n  for k,_ in next, _G, nil do\n    g[k] = rawget(_G, k)\n  end\n  return {\n    gmt = debug.getmetatable(_G),\n    g = g,\n    loaded = tablex.copy(package.loaded)\n  }\nend\n\nlocal function restore(state)\n  setmetatable(_G, state.gmt)\n  for k,_ in next, _G, nil do\n    rawset(_G, k, state.g[k])\n  end\n  for k, v in next, state.g, nil do\n    -- reset globals that were set to nil during the insulation block\n    if rawget(_G, k) == nil then\n      rawset(_G, k, v)\n    end\n  end\n  for k,_ in pairs(package.loaded) do\n    package.loaded[k] = state.loaded[k]\n  end\nend\n\nreturn function()\n  local context = {}\n\n  local data = { descriptor = 'suite', attributes = {} }\n  local parents = {}\n  local children = {}\n  local stack = {}\n  local states = {}\n\n  function context.ref()\n    local ref = {}\n    local ctx = data\n\n    local function unwrap(element, levels)\n      local levels = levels or 1\n      local parent = element\n      for i = 1, levels do\n        parent = ref.parent(parent)\n        if not parent then break end\n      end\n      if not element.env then element.env = {} end\n      setmetatable(element.env, {\n        __newindex = function(self, key, value)\n          if not parent then\n            _G[key] = value\n          else\n            if not parent.env then parent.env = {} end\n            parent.env[key] = value\n          end\n        end\n      })\n    end\n\n    local function push_state(current)\n      local state = false\n      if current.attributes.envmode == 'insulate' then\n        state = save()\n      elseif current.attributes.envmode == 'unwrap' then\n        unwrap(current)\n      elseif current.attributes.envmode == 'expose' then\n        unwrap(current, 2)\n      end\n      table.insert(states, state)\n    end\n\n    local function pop_state(current)\n      local state = table.remove(states)\n      if current.attributes.envmode == 'expose' then\n        states[#states] = states[#states] and save()\n      end\n      if state then\n        restore(state)\n      end\n    end\n\n    function ref.get(key)\n      if not key then return ctx end\n      return ctx[key]\n    end\n\n    function ref.set(key, value)\n      ctx[key] = value\n    end\n\n    function ref.clear()\n      data = { descriptor = 'suite', attributes = {} }\n      parents = {}\n      children = {}\n      stack = {}\n      states = {}\n      ctx = data\n    end\n\n    function ref.attach(child)\n      if not children[ctx] then children[ctx] = {} end\n      parents[child] = ctx\n      table.insert(children[ctx], child)\n    end\n\n    function ref.children(parent)\n      return children[parent] or {}\n    end\n\n    function ref.parent(child)\n      return parents[child]\n    end\n\n    function ref.push(current)\n      if not parents[current] and current ~= data then error('Detached child. Cannot push.') end\n      if ctx ~= current then push_state(current) end\n      table.insert(stack, ctx)\n      ctx = current\n    end\n\n    function ref.pop()\n      local current = ctx\n      ctx = table.remove(stack)\n      if ctx ~= current then pop_state(current) end\n      if not ctx then error('Context stack empty. Cannot pop.') end\n    end\n\n    return ref\n  end\n\n  return context\nend"},{"name":"\/Users\/nascarsayan\/Code\/github.com\/nascarsayan\/sqids-lua\/lua_modules\/share\/lua\/5.4\/busted\/core.lua","coverage":[0,0,0,0,0,0,0,null,0,null,null,0,null,null,0,null,0,null,null,0,null,null,0,null,null,null,0,0,0,0,0,null,0,null,null,null,0,null,null,null,12,null,null,null,0,null,0,0,null,0,0,null,0,null,0,0,0,0,null,0,0,0,0,null,0,null,0,0,0,null,96,null,96,96,96,96,0,0,null,null,96,96,null,96,96,null,null,0,0,0,0,0,null,0,0,0,0,0,null,null,0,null,null,0,333,null,null,0,114,null,null,0,0,null,null,0,96,null,96,96,12,12,12,12,12,12,null,null,84,84,84,84,84,84,null,null,0,null,null,0,null,null,0,0,0,0,0,0,0,null,null,0,0,0,0,null,null,0,0,0,0,0,0,null,null,0,12,null,12,null,null,null,0,438,null,438,null,876,0,0,0,876,null,438,0,0,0,0,0,null,null,0,null,null,null,null,null,null,null,null,0,null,438,null,438,438,null,null,0,222,222,222,111,111,111,111,111,111,null,444,222,444,222,null,null,0,0,null,null,0,0,0,null,null,0,0,0,null,null,0,null,0,0,0,0,0,0,0,null,0,0,0,null,0,0,null,null,null,108,0,0,108,0,null,null,null,null,108,108,96,null,null,null,108,null,null,108,null,null,0,0,0,null,0,108,108,108,108,108,108,108,108,108,108,108,108,null,null,108,null,108,27,null,81,null,null,null,null,0,27,135,108,108,216,null,null,null,null,0,null],"source":"local getfenv = require 'busted.compatibility'.getfenv\nlocal setfenv = require 'busted.compatibility'.setfenv\nlocal unpack = require 'busted.compatibility'.unpack\nlocal path = require 'pl.path'\nlocal pretty = require 'pl.pretty'\nlocal system = require 'system'\nlocal throw = error\n\nlocal failureMt = {\n  __index = {},\n  __tostring = function(e) return tostring(e.message) end,\n  __type = 'failure'\n}\n\nlocal failureMtNoString = {\n  __index = {},\n  __type = 'failure'\n}\n\nlocal pendingMt = {\n  __index = {},\n  __tostring = function(p) return p.message end,\n  __type = 'pending'\n}\n\nlocal function errortype(obj)\n  local mt = debug.getmetatable(obj)\n  if mt == failureMt or mt == failureMtNoString then\n    return 'failure'\n  elseif mt == pendingMt then\n    return 'pending'\n  end\n  return 'error'\nend\n\nlocal function hasToString(obj)\n  return type(obj) == 'string' or (debug.getmetatable(obj) or {}).__tostring\nend\n\nlocal function isCallable(obj)\n  return type(obj) == 'function' or (debug.getmetatable(obj) or {}).__call\nend\n\nreturn function()\n  local mediator = require 'mediator'()\n\n  local busted = {}\n  busted.version = '2.2.0'\n\n  local root = require 'busted.context'()\n  busted.context = root.ref()\n\n  local environment = require 'busted.environment'(busted.context)\n\n  busted.api = {}\n  busted.executors = {}\n  local executors = {}\n  local eattributes = {}\n\n  busted.gettime = system.gettime\n  busted.monotime = system.monotime\n  busted.sleep = system.sleep\n  busted.status = require 'busted.status'\n\n  function busted.getTrace(element, level, msg)\n    local function trimTrace(info)\n      local index = info.traceback:find('\\n%s*%[C]')\n      info.traceback = info.traceback:sub(1, index)\n      return info\n    end\n    level = level or  3\n\n    local thisdir = path.dirname(debug.getinfo(1, 'Sl').source)\n    local info = debug.getinfo(level, 'Sl')\n    while info.what == 'C' or info.short_src:match('luassert[\/\\\\].*%.lua$') or\n          (info.source:sub(1,1) == '@' and thisdir == path.dirname(info.source)) do\n      level = level + 1\n      info = debug.getinfo(level, 'Sl')\n    end\n\n    info.traceback = debug.traceback('', level)\n    info.message = tostring(msg)\n\n    local file = busted.getFile(element)\n    return file and file.getTrace(file.name, info) or trimTrace(info)\n  end\n\n  function busted.rewriteMessage(element, message, trace)\n    local file = busted.getFile(element)\n    local msg = hasToString(message) and tostring(message)\n    msg = msg or (message ~= nil and pretty.write(message) or 'Nil error')\n    msg = (file and file.rewriteMessage and file.rewriteMessage(file.name, msg) or msg)\n\n    local hasFileLine = msg:match('^[^\\n]-:%d+: .*')\n    if not hasFileLine then\n      local trace = trace or busted.getTrace(element, 3, message)\n      local fileline = trace.short_src .. ':' .. trace.currentline .. ': '\n      msg = fileline .. msg\n    end\n\n    return msg\n  end\n\n  function busted.publish(...)\n    return mediator:publish(...)\n  end\n\n  function busted.subscribe(...)\n    return mediator:subscribe(...)\n  end\n\n  function busted.unsubscribe(...)\n    return mediator:removeSubscriber(...)\n  end\n\n  function busted.getFile(element)\n    local parent = busted.context.parent(element)\n\n    while parent do\n      if parent.file then\n        local file = parent.file[1]\n        return {\n          name = file.name,\n          getTrace = file.run.getTrace,\n          rewriteMessage = file.run.rewriteMessage\n        }\n      end\n\n      if parent.descriptor == 'file' then\n        return {\n          name = parent.name,\n          getTrace = parent.run.getTrace,\n          rewriteMessage = parent.run.rewriteMessage\n        }\n      end\n\n      parent = busted.context.parent(parent)\n    end\n\n    return parent\n  end\n\n  function busted.fail(msg, level)\n    local rawlevel = (type(level) ~= 'number' or level <= 0) and level\n    local level = level or 1\n    local _, emsg = pcall(throw, msg, rawlevel or level+2)\n    local e = { message = emsg }\n    setmetatable(e, hasToString(msg) and failureMt or failureMtNoString)\n    throw(e, rawlevel or level+1)\n  end\n\n  function busted.pending(msg)\n    local p = { message = msg }\n    setmetatable(p, pendingMt)\n    throw(p)\n  end\n\n  function busted.bindfenv(callable, var, value)\n    local env = {}\n    local f = (debug.getmetatable(callable) or {}).__call or callable\n    setmetatable(env, { __index = getfenv(f) })\n    env[var] = value\n    setfenv(f, env)\n  end\n\n  function busted.wrap(callable)\n    if isCallable(callable) then\n      -- prioritize __call if it exists, like in files\n      environment.wrap((debug.getmetatable(callable) or {}).__call or callable)\n    end\n  end\n\n  function busted.safe(descriptor, run, element)\n    busted.context.push(element)\n    local trace, message\n    local status = 'success'\n\n    local ret = { xpcall(run, function(msg)\n      status = errortype(msg)\n      trace = busted.getTrace(element, 3, msg)\n      message = busted.rewriteMessage(element, msg, trace)\n    end) }\n\n    if not ret[1] then\n      if status == 'success' then\n        status = 'error'\n        trace = busted.getTrace(element, 3, ret[2])\n        message = busted.rewriteMessage(element, ret[2], trace)\n      elseif status == 'failure' and descriptor ~= 'it' then\n        -- Only 'it' blocks can generate test failures. Failures in all\n        -- other blocks are errors outside the test.\n        status = 'error'\n      end\n      -- Note: descriptor may be different from element.descriptor when\n      -- safe_publish is used (i.e. for test start\/end). The safe_publish\n      -- descriptor needs to be different for 'it' blocks so that we can\n      -- detect that a 'failure' in a test start\/end handler is not really\n      -- a test failure, but rather an error outside the test, much like a\n      -- failure in a support function (i.e. before_each\/after_each or\n      -- setup\/teardown).\n      busted.publish({ status, element.descriptor }, element, busted.context.parent(element), message, trace)\n    end\n    ret[1] = busted.status(status)\n\n    busted.context.pop()\n    return unpack(ret)\n  end\n\n  function busted.safe_publish(descriptor, channel, element, ...)\n    local args = {...}\n    local n = select('#', ...)\n    if channel[2] == 'start' then\n      element.starttick = busted.monotime()\n      element.starttime = busted.gettime()\n    elseif channel[2] == 'end' then\n      element.endtime = busted.gettime()\n      element.endtick = busted.monotime()\n      element.duration = element.starttick and (element.endtick - element.starttick)\n    end\n    local status = busted.safe(descriptor, function()\n      busted.publish(channel, element, unpack(args, 1, n))\n    end, element)\n    return status:success()\n  end\n\n  function busted.exportApi(key, value)\n    busted.api[key] = value\n  end\n\n  function busted.export(key, value)\n    busted.exportApi(key, value)\n    environment.set(key, value)\n  end\n\n  function busted.hide(key, value)\n    busted.api[key] = nil\n    environment.set(key, nil)\n  end\n\n  function busted.register(descriptor, executor, attributes)\n    local alias = nil\n    if type(executor) == 'string' then\n      alias = descriptor\n      descriptor = executor\n      executor = executors[descriptor]\n      attributes = attributes or eattributes[descriptor]\n      executors[alias] = executor\n      eattributes[alias] = attributes\n    else\n      if executor ~= nil and not isCallable(executor) then\n        attributes = executor\n        executor = nil\n      end\n      executors[descriptor] = executor\n      eattributes[descriptor] = attributes\n    end\n\n    local publisher = function(name, fn)\n      if not fn and type(name) == 'function' then\n        fn = name\n        name = alias\n      elseif not fn then\n        fn = attributes and attributes.default_fn\n      end\n\n      local trace\n\n      local ctx = busted.context.get()\n      if busted.context.parent(ctx) then\n        trace = busted.getTrace(ctx, 3, name)\n      end\n\n      local publish = function(f)\n        busted.publish({ 'register', descriptor }, name, f, trace, attributes)\n      end\n\n      if fn then publish(fn) else return publish end\n    end\n\n    local edescriptor = alias or descriptor\n    busted.executors[edescriptor] = publisher\n    busted.export(edescriptor, publisher)\n\n    busted.subscribe({ 'register', descriptor }, function(name, fn, trace, attributes)\n      local ctx = busted.context.get()\n      local plugin = {\n        descriptor = descriptor,\n        attributes = attributes or {},\n        name = name,\n        run = fn,\n        trace = trace,\n        starttick = nil,\n        endtick = nil,\n        starttime = nil,\n        endtime = nil,\n        duration = nil,\n      }\n\n      busted.context.attach(plugin)\n\n      if not ctx[descriptor] then\n        ctx[descriptor] = { plugin }\n      else\n        ctx[descriptor][#ctx[descriptor]+1] = plugin\n      end\n    end)\n  end\n\n  function busted.execute(current)\n    if not current then current = busted.context.get() end\n    for _, v in pairs(busted.context.children(current)) do\n      local executor = executors[v.descriptor]\n      if executor and not busted.skipAll then\n        busted.safe(v.descriptor, function() executor(v) end, v)\n      end\n    end\n  end\n\n  return busted\nend"},{"name":"\/Users\/nascarsayan\/Code\/github.com\/nascarsayan\/sqids-lua\/lua_modules\/share\/lua\/5.4\/busted\/environment.lua","coverage":[0,null,null,null,0,null,null,10299,0,9870,7800,9870,null,null,null,0,0,null,null,null,2499,null,null,null,0,null,null,0,null,0,12,null,null,0,0,null,0,0,0,null,null,0,null,0,null],"source":"local setfenv = require 'busted.compatibility'.setfenv\n\nreturn function(context)\n\n  local environment = {}\n\n  local function getEnv(self, key)\n    if not self then return nil end\n    return\n      self.env and self.env[key] or\n      getEnv(context.parent(self), key) or\n      _G[key]\n  end\n\n  local function setEnv(self, key, value)\n    if not self.env then self.env = {} end\n    self.env[key] = value\n  end\n\n  local function __index(self, key)\n    return getEnv(context.get(), key)\n  end\n\n  local function __newindex(self, key, value)\n    setEnv(context.get(), key, value)\n  end\n\n  local env = setmetatable({}, { __index=__index, __newindex=__newindex })\n\n  function environment.wrap(fn)\n    return setfenv(fn, env)\n  end\n\n  function environment.set(key, value)\n    local env = context.get('env')\n\n    if not env then\n      env = {}\n      context.set('env', env)\n    end\n\n    env[key] = value\n  end\n  return environment\nend"},{"name":"\/Users\/nascarsayan\/Code\/github.com\/nascarsayan\/sqids-lua\/lua_modules\/share\/lua\/5.4\/busted\/execute.lua","coverage":[3,3,3,null,null,0,0,0,null,0,null,0,null,null,null,3,null,null,3,3,null,null,0,null,0,0,0,0,null,null,0,0,0,null,0,null,null,0,null,null,6,3,0,0,0,null,null,3,0,3,0,0,null,null,3,3,3,3,null,3,3,null,3,null,3,null,null,null,null,null,3,null],"source":"local shuffle = require 'busted.utils'.shuffle\nlocal urandom = require 'busted.utils'.urandom\nlocal tablex = require 'pl.tablex'\n\nlocal function sort(elements)\n  table.sort(elements, function(t1, t2)\n    if t1.name and t2.name then\n      return t1.name < t2.name\n    end\n    return t2.name ~= nil\n  end)\n  return elements\nend\n\nreturn function(busted)\n  local block = require 'busted.block'(busted)\n\n  local function execute(runs, options)\n    local root = busted.context.get()\n    local children = tablex.copy(busted.context.children(root))\n\n    local function suite_reset()\n      local oldctx = busted.context.get()\n\n      busted.context.clear()\n      local ctx = busted.context.get()\n      for k, v in pairs(oldctx) do\n        ctx[k] = v\n      end\n\n      for _, child in ipairs(children) do\n        for descriptor, _ in pairs(busted.executors) do\n          child[descriptor] = nil\n        end\n        busted.context.attach(child)\n      end\n\n      busted.randomseed = tonumber(options.seed) or urandom() or os.time()\n    end\n\n    for i = 1, runs do\n      if i > 1 then\n        suite_reset()\n        root = busted.context.get()\n        busted.safe_publish('suite', { 'suite', 'reset' }, root, i, runs)\n      end\n\n      if options.sort then\n        sort(busted.context.children(root))\n      elseif options.shuffle then\n        root.randomseed = busted.randomseed\n        shuffle(busted.context.children(root), busted.randomseed)\n      end\n\n      local seed = (busted.randomize and busted.randomseed or nil)\n      if busted.safe_publish('suite', { 'suite', 'start' }, root, i, runs, seed) then\n        if block.setup(root) then\n          busted.execute()\n        end\n        block.lazyTeardown(root)\n        block.teardown(root)\n      end\n      busted.safe_publish('suite', { 'suite', 'end' }, root, i, runs)\n\n      if busted.skipAll then\n        break\n      end\n    end\n  end\n\n  return execute\nend"},{"name":"\/Users\/nascarsayan\/Code\/github.com\/nascarsayan\/sqids-lua\/lua_modules\/share\/lua\/5.4\/busted\/init.lua","coverage":[null,0,null,null,12,12,12,null,12,null,null,null,12,12,12,null,12,null,null,null,84,null,null,84,null,0,null,null,84,null,84,84,84,null,84,null,84,84,84,84,84,0,0,null,null,0,null,84,null,null,84,null,null,null,0,0,0,0,null,0,null,null,0,null,0,0,0,null,0,null,0,null,0,0,null,0,0,0,0,null,0,0,null,0,0,0,null,0,null,0,0,0,0,0,null,null,null,0,0,0,0,0,null,0,0,0,null,0,0,0,0,0,0,0,0,null,0,0,null,0,null,null,0,null,0,null,0,null,567,null,null,null,0,null,null,null,null],"source":"local function init(busted)\n  local block = require 'busted.block'(busted)\n\n  local file = function(file)\n    busted.wrap(file.run)\n    if busted.safe_publish('file', { 'file', 'start' }, file) then\n      block.execute('file', file)\n    end\n    busted.safe_publish('file', { 'file', 'end' }, file)\n  end\n\n  local describe = function(describe)\n    local parent = busted.context.parent(describe)\n    if busted.safe_publish('describe', { 'describe', 'start' }, describe, parent) then\n      block.execute('describe', describe)\n    end\n    busted.safe_publish('describe', { 'describe', 'end' }, describe, parent)\n  end\n\n  local it = function(element)\n    local parent = busted.context.parent(element)\n    local finally\n\n    if not block.lazySetup(parent) then\n      -- skip test if any setup failed\n      return\n    end\n\n    if not element.env then element.env = {} end\n\n    block.rejectAll(element)\n    element.env.finally = function(fn) finally = fn end\n    element.env.pending = busted.pending\n\n    local pass, ancestor = block.execAll('before_each', parent, true)\n\n    if pass then\n      local status = busted.status('success')\n      if busted.safe_publish('test', { 'test', 'start' }, element, parent) then\n        status:update(busted.safe('it', element.run, element))\n        if finally then\n          block.reject('pending', element)\n          status:update(busted.safe('finally', finally, element))\n        end\n      else\n        status = busted.status('error')\n      end\n      busted.safe_publish('test', { 'test', 'end' }, element, parent, tostring(status))\n    end\n\n    block.dexecAll('after_each', ancestor, true)\n  end\n\n  local pending = function(element)\n    local parent = busted.context.parent(element)\n    local status = 'pending'\n    if not busted.safe_publish('it', { 'test', 'start' }, element, parent) then\n      status = 'error'\n    end\n    busted.safe_publish('it', { 'test', 'end' }, element, parent, status)\n  end\n\n  busted.register('file', file, { envmode = 'insulate' })\n\n  busted.register('describe', describe)\n  busted.register('insulate', 'describe', { envmode = 'insulate' })\n  busted.register('expose', 'describe', { envmode = 'expose' })\n\n  busted.register('it', it)\n\n  busted.register('pending', pending, { default_fn = function() end })\n\n  busted.register('before_each', { envmode = 'unwrap' })\n  busted.register('after_each', { envmode = 'unwrap' })\n\n  busted.register('lazy_setup', { envmode = 'unwrap' })\n  busted.register('lazy_teardown', { envmode = 'unwrap' })\n  busted.register('strict_setup', { envmode = 'unwrap' })\n  busted.register('strict_teardown', { envmode = 'unwrap' })\n\n  busted.register('setup', 'strict_setup')\n  busted.register('teardown', 'strict_teardown')\n\n  busted.register('context', 'describe')\n  busted.register('spec', 'it')\n  busted.register('test', 'it')\n\n  busted.hide('file')\n\n  local assert = require 'luassert'\n  local spy    = require 'luassert.spy'\n  local mock   = require 'luassert.mock'\n  local stub   = require 'luassert.stub'\n  local match  = require 'luassert.match'\n\n  require 'busted.fixtures'  -- just load into the environment, not exposing it\n\n  busted.export('assert', assert)\n  busted.export('spy', spy)\n  busted.export('mock', mock)\n  busted.export('stub', stub)\n  busted.export('match', match)\n\n  busted.exportApi('publish', busted.publish)\n  busted.exportApi('subscribe', busted.subscribe)\n  busted.exportApi('unsubscribe', busted.unsubscribe)\n\n  busted.exportApi('bindfenv', busted.bindfenv)\n  busted.exportApi('fail', busted.fail)\n  busted.exportApi('gettime', busted.gettime)\n  busted.exportApi('monotime', busted.monotime)\n  busted.exportApi('sleep', busted.sleep)\n  busted.exportApi('parent', busted.context.parent)\n  busted.exportApi('children', busted.context.children)\n  busted.exportApi('version', busted.version)\n\n  busted.bindfenv(assert, 'error', busted.fail)\n  busted.bindfenv(assert.is_true, 'error', busted.fail)\n\n  return busted\nend\n\nreturn setmetatable({}, {\n  __call = function(self, busted)\n    init(busted)\n\n    return setmetatable(self, {\n      __index = function(self, key)\n        return busted.api[key]\n      end,\n\n      __newindex = function(self, key, value)\n        error('Attempt to modify busted')\n      end\n    })\n  end\n})"},{"name":"\/Users\/nascarsayan\/Code\/github.com\/nascarsayan\/sqids-lua\/lua_modules\/share\/lua\/5.4\/busted\/languages\/en.lua","coverage":[3,null,3,null,null,3,3,3,3,null,3,3,3,3,null,3,3,3,3,null,3,3,3,3,null,3,null,3,3,null,null,3,3,3,3,3,3,3,3,3,null,3,3,3,3,3,3,null,3,3],"source":"local s = require('say')\n\ns:set_namespace('en')\n\n-- 'Pending: test.lua @ 12 \\n description\ns:set('output.pending', 'Pending')\ns:set('output.failure', 'Failure')\ns:set('output.error', 'Error')\ns:set('output.success', 'Success')\n\ns:set('output.pending_plural', 'pending')\ns:set('output.failure_plural', 'failures')\ns:set('output.error_plural', 'errors')\ns:set('output.success_plural', 'successes')\n\ns:set('output.pending_zero', 'pending')\ns:set('output.failure_zero', 'failures')\ns:set('output.error_zero', 'errors')\ns:set('output.success_zero', 'successes')\n\ns:set('output.pending_single', 'pending')\ns:set('output.failure_single', 'failure')\ns:set('output.error_single', 'error')\ns:set('output.success_single', 'success')\n\ns:set('output.seconds', 'seconds')\n\ns:set('output.no_test_files_match', 'No test files found matching Lua pattern: %s')\ns:set('output.file_not_found', 'Cannot find file or directory: %s')\n\n-- definitions following are not used within the 'say' namespace\nreturn {\n  failure_messages = {\n    'You have %d busted specs',\n    'Your specs are busted',\n    'Your code is bad and you should feel bad',\n    'Your code is in the Danger Zone',\n    'Strange game. The only way to win is not to test',\n    'My grandmother wrote better specs on a 3 86',\n    'Every time there\\'s a failure, drink another beer',\n    'Feels bad man'\n  },\n  success_messages = {\n    'Aww yeah, passing specs',\n    'Doesn\\'t matter, had specs',\n    'Feels good, man',\n    'Great success',\n    'Tests pass, drink another beer',\n  }\n}"},{"name":"\/Users\/nascarsayan\/Code\/github.com\/nascarsayan\/sqids-lua\/lua_modules\/share\/lua\/5.4\/busted\/luajit.lua","coverage":[3,null,3,6,null,null,null,null,null,0,null,null,null,null,null,null,null,0,0,null,null,0,0,null,0,0,null,0,null,0,null,0,null,null,0,0,null,null,null,null,0,0,null,null,0,0,null,0,0,null,0,null,null,0,0,null,null,null,null,0,0,0,0,null],"source":"local isJit = (tostring(assert):match('builtin') ~= nil)\n\nif not isJit then\n  return function() end\nend\n\n-- pre-load the ffi module, such that it becomes part of the environment\n-- and Busted will not try to GC and reload it. The ffi is not suited\n-- for that and will occasionally segfault if done so.\nlocal ffi = require \"ffi\"\n\n\n-- patching assumes;\n--  * first parameter to be a unique key to identify repeated calls\n--  * only a single return value\n\nlocal function patch_with_return_value(func_name)\n  local original = ffi[func_name]\n  local original_store = {}\n\n  ffi[func_name] = function (primary, ...)\n    if original_store[primary] then\n      return original_store[primary]\n    end\n    local success, result, err = pcall(original, primary, ...)\n    if not success then\n      -- hard error was thrown\n      error(result, 2)\n    end\n    if not result then\n      -- soft error was returned\n      return result, err\n    end\n    -- it worked, store and return\n    original_store[primary] = result\n    return result\n  end\nend\n\nlocal function patch_without_return_value(func_name)\n  local original = ffi[func_name]\n  local original_store = {}\n\n  ffi[func_name] = function (primary, ...)\n    if original_store[primary] then\n      return\n    end\n    local success, result = pcall(original, primary, ...)\n    if not success then\n      -- hard error was thrown\n      error(result, 2)\n    end\n    -- store and return\n    original_store[primary] = true\n    return result\n  end\nend\n\nreturn function()\n    patch_without_return_value(\"cdef\")\n    patch_with_return_value(\"typeof\")\n    patch_with_return_value(\"metatype\")\n    patch_with_return_value(\"load\")\n  end"},{"name":"\/Users\/nascarsayan\/Code\/github.com\/nascarsayan\/sqids-lua\/lua_modules\/share\/lua\/5.4\/busted\/modules\/files\/lua.lua","coverage":[3,null,3,null,null,96,96,96,null,null,null,12,null,null,null,12,12,0,null,12,null,null,3],"source":"local path = require 'pl.path'\n\nlocal ret = {}\n\nlocal getTrace = function(filename, info)\n  local index = info.traceback:find('\\n%s*%[C]')\n  info.traceback = info.traceback:sub(1, index)\n  return info\nend\n\nret.match = function(busted, filename)\n  return path.extension(filename) == '.lua'\nend\n\nret.load = function(busted, filename)\n  local file, err = loadfile(filename)\n  if not file then\n    busted.publish({ 'error', 'file' }, { descriptor = 'file', name = filename }, nil, err, {})\n  end\n  return file, getTrace\nend\n\nreturn ret"},{"name":"\/Users\/nascarsayan\/Code\/github.com\/nascarsayan\/sqids-lua\/lua_modules\/share\/lua\/5.4\/busted\/modules\/files\/moonscript.lua","coverage":[3,null,6,3,null,null,3,null,null,null,0,0,0,0,null,null,0,null,null,null,0,0,0,0,0,null,null,null,null,0,null,null,null,null,null,0,null,null,null,null,0,null,0,null,0,0,0,0,0,null,null,null,0,null,null,0,0,null,0,0,0,0,0,null,null,0,null,null,3,null,null,0,0,null,0,0,0,0,null,0,null,null,null,0,0,0,null,null,0,0,null,0,null,null,null,0,null,null,null,0,0,0,null,0,null,null,3],"source":"local path = require 'pl.path'\n\nlocal ok, moonscript, line_tables, util = pcall(function()\n  return require 'moonscript', require 'moonscript.line_tables', require 'moonscript.util'\nend)\n\nlocal _cache = {}\n\n-- find the line number of `pos` chars into fname\nlocal lookup_line = function(fname, pos)\n  if not _cache[fname] then\n    local f = io.open(fname)\n    _cache[fname] = f:read('*a')\n    f:close()\n  end\n\n  return util.pos_to_line(_cache[fname], pos)\nend\n\nlocal rewrite_linenumber = function(fname, lineno)\n  local tbl = line_tables['@' .. fname]\n  if fname and tbl then\n    for i = lineno, 0 ,-1 do\n      if tbl[i] then\n        return lookup_line(fname, tbl[i])\n      end\n    end\n  end\n\n  return lineno\nend\n\nlocal rewrite_filename = function(filename)\n  -- sometimes moonscript gives files like [string \".\/filename.moon\"], so\n  -- we'll chop it up to only get the filename.\n  return filename:match('string \"(.+)\"') or filename\nend\n\nlocal rewrite_traceback = function(fname, trace)\n  local rewrite_one = function(line, pattern, sub)\n    if line == nil then return '' end\n\n    local fname, lineno = line:match(pattern)\n\n    if fname and lineno then\n      fname = rewrite_filename(fname)\n      local new_lineno = rewrite_linenumber(fname, tonumber(lineno))\n      if new_lineno then\n        line = line:gsub(sub:format(tonumber(lineno)), sub:format(tonumber(new_lineno)))\n      end\n    end\n\n    return line\n  end\n\n  local lines = {}\n  local j = 0\n\n  for line in trace:gmatch('[^\\r\\n]+') do\n    j = j + 1\n    line = rewrite_one(line, '%s*(.-):(%d+): ', ':%d:')\n    line = rewrite_one(line, '<(.*):(%d+)>', ':%d>')\n    lines[j] = line\n  end\n\n  return '\\n' .. table.concat(lines, trace:match('[\\r\\n]+')) .. '\\n'\nend\n\nlocal ret = {}\n\nlocal getTrace = function(filename, info)\n  local index = info.traceback:find('\\n%s*%[C]')\n  info.traceback = info.traceback:sub(1, index)\n\n  info.short_src = rewrite_filename(info.short_src)\n  info.traceback = rewrite_traceback(filename, info.traceback)\n  info.linedefined = rewrite_linenumber(filename, info.linedefined)\n  info.currentline = rewrite_linenumber(filename, info.currentline)\n\n  return info\nend\n\nlocal rewriteMessage = function(filename, message)\n  local fname, line, msg = message:match('^([^\\n]-):(%d+): (.*)')\n  if not fname then\n    return message\n  end\n\n  fname = rewrite_filename(fname)\n  line = rewrite_linenumber(fname, tonumber(line))\n\n  return fname .. ':' .. tostring(line) .. ': ' .. msg\nend\n\nret.match = function(busted, filename)\n  return ok and path.extension(filename) == '.moon'\nend\n\nret.load = function(busted, filename)\n  local file, err = moonscript.loadfile(filename)\n  if not file then\n    busted.publish({ 'error', 'file' }, { descriptor = 'file', name = filename }, nil, err, {})\n  end\n  return file, getTrace, rewriteMessage\nend\n\nreturn ret"},{"name":"\/Users\/nascarsayan\/Code\/github.com\/nascarsayan\/sqids-lua\/lua_modules\/share\/lua\/5.4\/busted\/modules\/filter_loader.lua","coverage":[null,null,null,84,84,null,168,168,84,84,null,null,84,null,null,null,0,0,null,null,null,96,0,0,null,null,96,null,null,null,84,84,0,0,null,null,84,null,null,null,96,0,0,null,null,96,null,null,3,3,0,0,null,null,null,null,0,0,0,null,null,0,null,null,null,96,0,0,null,null,96,null,null,null,84,0,0,null,null,84,null,null,null,0,0,0,0,0,null,0,null,0,null,null,null,0,null,null,3,null,0,0,null,0,0,null,null,null,0,null,null,null,30,54,39,null,null,null,null,null,0,0,0,0,null,null,null,null,3,0,0,0,0,0,0,0,0,0,0,0,0,null,null,3,3,3,3,null,null,3,3,3,3,3,3,null,null,0,null],"source":"return function()\n  local function filter(busted, options)\n    local getFullName = function(name)\n      local parent = busted.context.get()\n      local names = { name }\n\n      while parent and (parent.name or parent.descriptor) and\n            parent.descriptor ~= 'file' do\n        table.insert(names, 1, parent.name or parent.descriptor)\n        parent = busted.context.parent(parent)\n      end\n\n      return table.concat(names, ' ')\n    end\n\n    local hasTag = function(name, tag)\n      local found = name:find('#' .. tag)\n      return (found ~= nil)\n    end\n\n    local filterExcludeTags = function(name)\n      for i, tag in pairs(options.excludeTags) do\n        if hasTag(name, tag) then\n          return nil, false\n        end\n      end\n      return nil, true\n    end\n\n    local filterTags = function(name)\n      local fullname = getFullName(name)\n      for i, tag in pairs(options.tags) do\n        if hasTag(fullname, tag) then\n          return nil, true\n        end\n      end\n      return nil, (#options.tags == 0)\n    end\n\n    local filterOutNames = function(name)\n      for _, filter in pairs(options.filterOut) do\n        if getFullName(name):find(filter) ~= nil then\n          return nil, false\n        end\n      end\n      return nil, true\n    end\n\n    local excludeNames = {}\n    if options.excludeNamesFile then\n      for name in io.lines(options.excludeNamesFile) do\n        table.insert(excludeNames, name)\n      end\n    end\n\n    local excludeNamesFile = function(name)\n      for _, filter in ipairs(excludeNames) do\n        if getFullName(name) == filter then\n          return nil, false\n        end\n      end\n      return nil, true\n    end\n\n    local name = function(name)\n      for _, candidate in pairs(options.name) do\n        if string.find(candidate, getFullName(name), 1, true) then\n          return nil, true\n        end\n      end\n      return nil, (#options.name == 0)\n    end\n\n    local filterNames = function(name)\n      for _, filter in pairs(options.filter) do\n        if getFullName(name):find(filter) ~= nil then\n          return nil, true\n        end\n      end\n      return nil, (#options.filter == 0)\n    end\n\n    local printTestName = function(element, parent, status)\n      if not (options.suppressPending and status == 'pending') then\n        local fullname = getFullName()\n        local trace = element.trace\n        if trace and trace.what == 'Lua' then\n          fullname = trace.short_src .. ':' .. trace.currentline .. ': ' .. fullname\n        end\n        print(fullname)\n      end\n      return nil, false\n    end\n\n    local ignoreAll = function()\n      return nil, false\n    end\n\n    local noop = function() end\n    local stubOut = function(descriptor, name, fn, ...)\n      if fn == noop then\n        return nil, true\n      end\n      busted.publish({ 'register', descriptor }, name, noop, ...)\n      return nil, false\n    end\n\n    local skipOnError = function()\n      return nil, not busted.skipAll\n    end\n\n    local applyFilter = function(descriptors, name, fn)\n      if options[name] and options[name] ~= '' then\n        for _, descriptor in ipairs(descriptors) do\n          busted.subscribe({ 'register', descriptor }, fn, { priority = 1 })\n        end\n      end\n    end\n\n    local applyDescFilter = function(descriptors, name, fn)\n      if options[name] and options[name] ~= '' then\n        for _, descriptor in ipairs(descriptors) do\n          local f = function(...) return fn(descriptor, ...) end\n          busted.subscribe({ 'register', descriptor }, f, { priority = 1 })\n        end\n      end\n    end\n\n    if options.list then\n      busted.subscribe({ 'suite', 'start' }, ignoreAll, { priority = 1 })\n      busted.subscribe({ 'suite', 'end' }, ignoreAll, { priority = 1 })\n      busted.subscribe({ 'file', 'start' }, ignoreAll, { priority = 1 })\n      busted.subscribe({ 'file', 'end' }, ignoreAll, { priority = 1 })\n      busted.subscribe({ 'describe', 'start' }, ignoreAll, { priority = 1 })\n      busted.subscribe({ 'describe', 'end' }, ignoreAll, { priority = 1 })\n      busted.subscribe({ 'test', 'start' }, ignoreAll, { priority = 1 })\n      busted.subscribe({ 'test', 'end' }, printTestName, { priority = 1 })\n      applyDescFilter({ 'setup', 'teardown', 'before_each', 'after_each' }, 'list', stubOut)\n      applyDescFilter({ 'lazy_setup', 'lazy_teardown' }, 'list', stubOut)\n      applyDescFilter({ 'strict_setup', 'strict_teardown' }, 'list', stubOut)\n      applyDescFilter({ 'it', 'pending' }, 'list', stubOut)\n    end\n\n    applyFilter({ 'lazy_setup', 'lazy_teardown' }, 'nokeepgoing', skipOnError)\n    applyFilter({ 'strict_setup', 'strict_teardown' }, 'nokeepgoing', skipOnError)\n    applyFilter({ 'setup', 'teardown', 'before_each', 'after_each' }, 'nokeepgoing', skipOnError)\n    applyFilter({ 'file', 'describe', 'it', 'pending' }, 'nokeepgoing', skipOnError)\n\n    -- The following filters are applied in reverse order\n    applyFilter({ 'it', 'pending' }            , 'filter'          , filterNames           )\n    applyFilter({ 'describe', 'it', 'pending' }, 'name'            , name                  )\n    applyFilter({ 'describe', 'it', 'pending' }, 'filterOut'       , filterOutNames        )\n    applyFilter({ 'describe', 'it', 'pending' }, 'excludeNamesFile', excludeNamesFile      )\n    applyFilter({ 'it', 'pending' }            , 'tags'            , filterTags            )\n    applyFilter({ 'describe', 'it', 'pending' }, 'excludeTags'     , filterExcludeTags     )\n  end\n\n  return filter\nend"},{"name":"\/Users\/nascarsayan\/Code\/github.com\/nascarsayan\/sqids-lua\/lua_modules\/share\/lua\/5.4\/busted\/modules\/output_handler_loader.lua","coverage":[0,0,0,null,null,null,null,null,3,6,3,0,3,0,null,3,null,null,null,3,0,null,null,3,0,0,null,null,3,0,null,null,3,null,null,0,null],"source":"local path = require 'pl.path'\nlocal hasMoon, moonscript = pcall(require, 'moonscript')\nlocal utils = require 'busted.utils'\n\nreturn function()\n  local loadOutputHandler = function(busted, output, options)\n    local handler\n\n    utils.copy_interpreter_args(options.arguments)\n    local success, err = pcall(function()\n      if output:match('%.lua$') then\n        handler = dofile(path.normpath(output))\n      elseif hasMoon and output:match('%.moon$') then\n        handler = moonscript.dofile(path.normpath(output))\n      else\n        handler = require('busted.outputHandlers.' .. output)\n      end\n    end)\n\n    if not success and err:match(\"module '.-' not found:\") then\n      success, err = pcall(function() handler = require(output) end)\n    end\n\n    if not success then\n      busted.publish({ 'error', 'output' }, { descriptor = 'output', name = output }, nil, err, {})\n      handler = require('busted.outputHandlers.' .. options.defaultOutput)\n    end\n\n    if options.enableSound then\n      require 'busted.outputHandlers.sound'(options)\n    end\n\n    handler(options):subscribe(options)\n  end\n\n  return loadOutputHandler\nend"},{"name":"\/Users\/nascarsayan\/Code\/github.com\/nascarsayan\/sqids-lua\/lua_modules\/share\/lua\/5.4\/busted\/modules\/test_file_loader.lua","coverage":[3,null,null,3,3,3,3,null,9,6,6,null,null,null,null,null,3,0,3,3,3,null,6,12,12,0,0,null,null,12,12,12,null,null,0,null,null,6,12,0,null,12,null,null,null,0,0,null,null,3,3,null,null,null,3,6,3,null,3,null,null,null,null,12,12,12,null,null,null,null,null,3,null,15,12,null,12,24,12,12,12,12,null,null,12,null,null,null,3,0,0,0,null,0,null,null,3,null,null,3,null,null],"source":"local s = require 'say'\n\nreturn function(busted, loaders)\n  local path = require 'pl.path'\n  local dir = require 'pl.dir'\n  local tablex = require 'pl.tablex'\n  local fileLoaders = {}\n\n  for _, v in pairs(loaders) do\n    local loader = require('busted.modules.files.'..v)\n    fileLoaders[#fileLoaders+1] = loader\n  end\n\n  local getTestFiles = function(rootFile, patterns, options)\n    local fileList\n\n    if path.isfile(rootFile) then\n      fileList = { rootFile }\n    elseif path.isdir(rootFile) then\n      local getfiles = options.recursive and dir.getallfiles or dir.getfiles\n      fileList = getfiles(rootFile)\n\n      fileList = tablex.filter(fileList, function(filename)\n        local basename = path.basename(filename)\n        for _, patt in ipairs(options.excludes) do\n          if patt ~= '' and basename:find(patt) then\n            return nil\n          end\n        end\n        for _, patt in ipairs(patterns) do\n          if basename:find(patt) then\n            return true\n          end\n        end\n        return #patterns == 0\n      end)\n\n      fileList = tablex.filter(fileList, function(filename)\n        if path.is_windows then\n          return not filename:find('%\\\\%.%w+.%w+', #rootFile)\n        else\n          return not filename:find('\/%.%w+.%w+', #rootFile)\n        end\n      end)\n    else\n      busted.publish({ 'error' }, {}, nil, s('output.file_not_found'):format(rootFile), {})\n      fileList = {}\n    end\n\n    table.sort(fileList)\n    return fileList\n  end\n\n  local getAllTestFiles = function(rootFiles, patterns, options)\n    local fileList = {}\n    for _, root in ipairs(rootFiles) do\n      tablex.insertvalues(fileList, getTestFiles(root, patterns, options))\n    end\n    return fileList\n  end\n\n  -- runs a testfile, loading its tests\n  local loadTestFile = function(busted, filename)\n    for _, v in pairs(fileLoaders) do\n      if v.match(busted, filename) then\n        return v.load(busted, filename)\n      end\n    end\n  end\n\n  local loadTestFiles = function(rootFiles, patterns, options)\n    local fileList = getAllTestFiles(rootFiles, patterns, options)\n\n    for i, fileName in ipairs(fileList) do\n      local testFile, getTrace, rewriteMessage = loadTestFile(busted, fileName)\n\n      if testFile then\n        local file = setmetatable({\n          getTrace = getTrace,\n          rewriteMessage = rewriteMessage\n        }, {\n          __call = testFile\n        })\n\n        busted.executors.file(fileName, file)\n      end\n    end\n\n    if #fileList == 0 then\n      local pattern = patterns[1]\n      if #patterns > 1 then\n        pattern = '\\n\\t' .. table.concat(patterns, '\\n\\t')\n      end\n      busted.publish({ 'error' }, {}, nil, s('output.no_test_files_match'):format(pattern), {})\n    end\n\n    return fileList\n  end\n\n  return loadTestFiles, loadTestFile, getAllTestFiles\nend\n"},{"name":"\/Users\/nascarsayan\/Code\/github.com\/nascarsayan\/sqids-lua\/lua_modules\/share\/lua\/5.4\/busted\/outputHandlers\/base.lua","coverage":[3,3,null,null,3,3,3,3,3,3,3,3,3,3,3,null,null,null,336,null,null,null,3,3,null,3,0,null,null,3,3,3,3,3,3,3,3,3,3,null,null,null,252,252,null,504,504,null,252,252,null,null,252,null,null,null,null,84,1008,924,756,null,null,84,null,null,84,84,84,84,84,84,84,null,84,null,84,null,null,null,0,0,null,null,0,null,null,null,3,3,3,null,null,null,0,0,0,0,0,0,0,0,0,null,0,null,null,null,3,3,3,null,null,null,84,84,null,null,null,null,null,84,84,84,0,0,0,0,null,0,0,0,null,0,null,null,84,null,84,84,84,0,null,null,84,null,null,84,null,84,null,null,null,0,0,0,0,null,null,null,0,0,null,null,null,0,0,0,null,null,null,0,0,0,null,null,0,null,null,3,null],"source":"local table_concat = table.concat\nlocal table_insert = table.insert\n\nreturn function()\n  local busted = require 'busted'\n  local handler = {\n    successes = {},\n    successesCount = 0,\n    pendings = {},\n    pendingsCount = 0,\n    failures = {},\n    failuresCount = 0,\n    errors = {},\n    errorsCount = 0,\n    inProgress = {}\n  }\n\n  handler.cancelOnPending = function(element, parent, status)\n    return not ((element.descriptor == 'pending' or status == 'pending') and handler.options.suppressPending)\n  end\n\n  handler.subscribe = function(handler, options)\n    require('busted.languages.en')\n    handler.options = options\n\n    if options.language ~= 'en' then\n      require('busted.languages.' .. options.language)\n    end\n\n    busted.subscribe({ 'suite', 'reset' }, handler.baseSuiteReset, { priority = 1 })\n    busted.subscribe({ 'suite', 'start' }, handler.baseSuiteStart, { priority = 1 })\n    busted.subscribe({ 'suite', 'end' }, handler.baseSuiteEnd, { priority = 1 })\n    busted.subscribe({ 'test', 'start' }, handler.baseTestStart, { priority = 1, predicate = handler.cancelOnPending })\n    busted.subscribe({ 'test', 'end' }, handler.baseTestEnd, { priority = 1, predicate = handler.cancelOnPending })\n    busted.subscribe({ 'pending' }, handler.basePending, { priority = 1, predicate = handler.cancelOnPending })\n    busted.subscribe({ 'failure', 'it' }, handler.baseTestFailure, { priority = 1 })\n    busted.subscribe({ 'error', 'it' }, handler.baseTestError, { priority = 1 })\n    busted.subscribe({ 'failure' }, handler.baseError, { priority = 1 })\n    busted.subscribe({ 'error' }, handler.baseError, { priority = 1 })\n  end\n\n  handler.getFullName = function(context)\n    local parent = busted.parent(context)\n    local names = { (context.name or context.descriptor) }\n\n    while parent and (parent.name or parent.descriptor) and\n          parent.descriptor ~= 'file' do\n\n      table_insert(names, 1, parent.name or parent.descriptor)\n      parent = busted.parent(parent)\n    end\n\n    return table_concat(names, ' ')\n  end\n\n  handler.format = function(element, parent, message, debug, isError)\n    local function copyElement(e)\n      local copy = {}\n      for k,v in next, e do\n        if type(v) ~= 'function' and k ~= 'env' then\n          copy[k] = v\n        end\n      end\n      return copy\n    end\n\n    local formatted = {\n      trace = debug or element.trace,\n      element = copyElement(element),\n      name = handler.getFullName(element),\n      message = message,\n      randomseed = parent and parent.randomseed,\n      isError = isError\n    }\n    formatted.element.trace = element.trace or debug\n\n    return formatted\n  end\n\n  handler.getDuration = function()\n    if not handler.endTick or not handler.startTick then\n      return 0\n    end\n\n    return handler.endTick - handler.startTick\n  end\n\n  handler.baseSuiteStart = function(suite)\n    handler.startTick = suite.starttick\n    handler.startTime = suite.starttime\n    return nil, true\n  end\n\n  handler.baseSuiteReset = function()\n    handler.successes = {}\n    handler.successesCount = 0\n    handler.pendings = {}\n    handler.pendingsCount = 0\n    handler.failures = {}\n    handler.failuresCount = 0\n    handler.errors = {}\n    handler.errorsCount = 0\n    handler.inProgress = {}\n\n    return nil, true\n  end\n\n  handler.baseSuiteEnd = function(suite)\n    handler.endTick = suite.endtick\n    handler.endTime = suite.endtime\n    return nil, true\n  end\n\n  handler.baseTestStart = function(element, parent)\n    handler.inProgress[tostring(element)] = {}\n    return nil, true\n  end\n\n  handler.baseTestEnd = function(element, parent, status, debug)\n    local insertTable\n\n    if status == 'success' then\n      insertTable = handler.successes\n      handler.successesCount = handler.successesCount + 1\n    elseif status == 'pending' then\n      insertTable = handler.pendings\n      handler.pendingsCount = handler.pendingsCount + 1\n    elseif status == 'failure' then\n      -- failure already saved in failure handler\n      handler.failuresCount = handler.failuresCount + 1\n      return nil, true\n    elseif status == 'error' then\n      -- error count already incremented and saved in error handler\n      return nil, true\n    end\n\n    local formatted = handler.format(element, parent, element.message, debug)\n\n    local id = tostring(element)\n    if handler.inProgress[id] then\n      for k, v in pairs(handler.inProgress[id]) do\n        formatted[k] = v\n      end\n\n      handler.inProgress[id] = nil\n    end\n\n    table_insert(insertTable, formatted)\n\n    return nil, true\n  end\n\n  handler.basePending = function(element, parent, message, debug)\n    local id = tostring(element)\n    handler.inProgress[id].message = message\n    handler.inProgress[id].trace = debug\n    return nil, true\n  end\n\n  handler.baseTestFailure = function(element, parent, message, debug)\n    table_insert(handler.failures, handler.format(element, parent, message, debug))\n    return nil, true\n  end\n\n  handler.baseTestError = function(element, parent, message, debug)\n    handler.errorsCount = handler.errorsCount + 1\n    table_insert(handler.errors, handler.format(element, parent, message, debug, true))\n    return nil, true\n  end\n\n  handler.baseError = function(element, parent, message, debug)\n    if element.descriptor ~= 'it' then\n      handler.errorsCount = handler.errorsCount + 1\n      table_insert(handler.errors, handler.format(element, parent, message, debug, true))\n    end\n\n    return nil, true\n  end\n\n  return handler\nend"},{"name":"\/Users\/nascarsayan\/Code\/github.com\/nascarsayan\/sqids-lua\/lua_modules\/share\/lua\/5.4\/busted\/outputHandlers\/gtest.lua","coverage":[3,3,3,3,3,3,3,3,3,null,null,3,null,null,3,3,null,3,3,null,3,3,3,null,3,3,0,0,0,null,null,3,0,0,null,3,3,3,null,null,0,null,0,0,null,0,0,null,null,null,3,3,3,3,3,3,3,3,3,3,3,3,3,3,null,3,3,3,3,3,3,null,3,3,3,3,3,null,3,3,3,3,3,null,null,3,3,3,3,3,3,3,null,null,0,null,0,0,0,0,null,null,0,null,null,null,0,0,0,0,0,null,0,null,null,0,null,0,0,null,null,0,null,null,null,168,168,168,168,null,168,null,null,null,9,9,9,0,0,0,null,0,0,0,0,0,0,0,null,null,null,null,9,null,null,null,9,9,9,0,0,0,null,9,null,null,null,3,3,null,3,3,3,null,3,3,3,3,null,3,null,null,null,168,null,null,null,0,0,0,0,0,0,0,null,0,null,null,null,3,0,null,3,0,null,3,3,3,null,3,null,null,null,3,3,3,3,3,3,3,null,3,null,null,null,12,12,12,12,null,null,null,12,12,12,12,12,12,null,null,null,84,84,null,84,null,null,null,84,null,null,84,84,84,84,84,0,0,0,0,0,0,0,0,0,null,null,84,84,null,84,null,null,null,0,0,0,null,0,null,null,null,0,0,0,null,0,null,null,null,0,0,0,0,null,0,null,null,0,null,null,3,3,3,3,3,3,3,3,3,3,3,null,3,null],"source":"local pretty = require 'pl.pretty'\nlocal term = require 'term'\nlocal luassert = require 'luassert'\nlocal io = io\nlocal type = type\nlocal ipairs = ipairs\nlocal string_format = string.format\nlocal io_write = io.write\nlocal io_flush = io.flush\nlocal colors\n\nlocal isatty = io.type(io.stdout) == 'file' and term.isatty(io.stdout)\n\nreturn function(options)\n  local busted = require 'busted'\n  local handler = require 'busted.outputHandlers.base'()\n\n  local cli = require 'cliargs'\n  local args = options.arguments\n\n  cli:set_name('gtest output handler')\n  cli:flag('--color', 'force use of color')\n  cli:flag('--plain', 'force use of no color')\n\n  local cliArgs, err = cli:parse(args)\n  if not cliArgs and err then\n    io.stderr:write(string.format('%s: %s\\n\\n', cli.name, err))\n    io.stderr:write(cli.printer.generate_help_and_usage().. '\\n')\n    os.exit(1)\n  end\n\n  if cliArgs.plain then\n    colors = setmetatable({}, {__index = function() return function(s) return s end end})\n    luassert:set_parameter(\"TableErrorHighlightColor\", \"none\")\n\n  elseif cliArgs.color then\n    colors = require 'term.colors'\n    luassert:set_parameter(\"TableErrorHighlightColor\", \"red\")\n\n  else\n    if package.config:sub(1,1) == '\\\\' and not os.getenv(\"ANSICON\") or not isatty then\n      -- Disable colors on Windows.\n      colors = setmetatable({}, {__index = function() return function(s) return s end end})\n      luassert:set_parameter(\"TableErrorHighlightColor\", \"none\")\n    else\n      colors = require 'term.colors'\n      luassert:set_parameter(\"TableErrorHighlightColor\", \"red\")\n    end\n  end\n\n  local repeatSuiteString = '\\nRepeating all tests (run %u of %u) . . .\\n\\n'\n  local randomizeString  = colors.yellow('Note: Randomizing test order with a seed of %u.\\n')\n  local suiteStartString = colors.green  ('[==========]') .. ' Running tests from scanned files.\\n'\n  local globalSetup      = colors.green  ('[----------]') .. ' Global test environment setup.\\n'\n  local fileStartString  = colors.green  ('[----------]') .. ' Running tests from %s\\n'\n  local runString        = colors.green  ('[ RUN      ]') .. ' %s\\n'\n  local successString    = colors.green  ('[       OK ]') .. ' %s (%.2f ms)\\n'\n  local skippedString    = colors.yellow ('[ SKIPPED  ]') .. ' %s (%.2f ms)\\n'\n  local failureString    = colors.red    ('[  FAILED  ]') .. ' %s (%.2f ms)\\n'\n  local errorString      = colors.magenta('[  ERROR   ]') .. ' %s (%.2f ms)\\n'\n  local fileEndString    = colors.green  ('[----------]') .. ' %u %s from %s (%.2f ms total)\\n\\n'\n  local globalTeardown   = colors.green  ('[----------]') .. ' Global test environment teardown.\\n'\n  local suiteEndString   = colors.green  ('[==========]') .. ' %u %s from %u test %s ran. (%.2f ms total)\\n'\n  local successStatus    = colors.green  ('[  PASSED  ]') .. ' %u %s.\\n'\n\n  local summaryStrings = {\n    skipped = {\n      header = colors.yellow ('[ SKIPPED  ]') .. ' %u %s, listed below:\\n',\n      test   = colors.yellow ('[ SKIPPED  ]') .. ' %s\\n',\n      footer = ' %u SKIPPED %s\\n',\n    },\n\n    failure = {\n      header = colors.red    ('[  FAILED  ]') .. ' %u %s, listed below:\\n',\n      test   = colors.red    ('[  FAILED  ]') .. ' %s\\n',\n      footer = ' %u FAILED %s\\n',\n    },\n\n    error = {\n      header = colors.magenta('[  ERROR   ]') .. ' %u %s, listed below:\\n',\n      test   = colors.magenta('[  ERROR   ]') .. ' %s\\n',\n      footer = ' %u %s\\n',\n    },\n  }\n\n  local fileCount = 0\n  local fileTestCount = 0\n  local testCount = 0\n  local successCount = 0\n  local skippedCount = 0\n  local failureCount = 0\n  local errorCount = 0\n\n  local pendingDescription = function(pending)\n    local string = ''\n\n    if type(pending.message) == 'string' then\n      string = string .. pending.message .. '\\n'\n    elseif pending.message ~= nil then\n      string = string .. pretty.write(pending.message) .. '\\n'\n    end\n\n    return string\n  end\n\n  local failureDescription = function(failure)\n    local string = failure.randomseed and ('Random seed: ' .. failure.randomseed .. '\\n') or ''\n    if type(failure.message) == 'string' then\n      string = string .. failure.message\n    elseif failure.message == nil then\n      string = string .. 'Nil error'\n    else\n      string = string .. pretty.write(failure.message)\n    end\n\n    string = string .. '\\n'\n\n    if options.verbose and failure.trace and failure.trace.traceback then\n      string = string .. failure.trace.traceback .. '\\n'\n    end\n\n    return string\n  end\n\n  local getFileLine = function(element)\n    local fileline = ''\n    if element.trace or element.trace.short_src then\n      fileline = colors.cyan(element.trace.short_src) .. ':' ..\n                 colors.cyan(element.trace.currentline) .. ': '\n    end\n    return fileline\n  end\n\n  local getTestList = function(status, count, list, getDescription)\n    local string = ''\n    local header = summaryStrings[status].header\n    if count > 0 and header then\n      local tests = (count == 1 and 'test' or 'tests')\n      local errors = (count == 1 and 'error' or 'errors')\n      string = string_format(header, count, status == 'error' and errors or tests)\n\n      local testString = summaryStrings[status].test\n      if testString then\n        for _, t in ipairs(list) do\n          local fullname = getFileLine(t.element) .. colors.bright(t.name)\n          string = string .. string_format(testString, fullname)\n          if options.deferPrint then\n            string = string .. getDescription(t)\n          end\n        end\n      end\n    end\n    return string\n  end\n\n  local getSummary = function(status, count)\n    local string = ''\n    local footer = summaryStrings[status].footer\n    if count > 0 and footer then\n      local tests = (count == 1 and 'TEST' or 'TESTS')\n      local errors = (count == 1 and 'ERROR' or 'ERRORS')\n      string = string_format(footer, count, status == 'error' and errors or tests)\n    end\n    return string\n  end\n\n  local getSummaryString = function()\n    local tests = (successCount == 1 and 'test' or 'tests')\n    local string = string_format(successStatus, successCount, tests)\n\n    string = string .. getTestList('skipped', skippedCount, handler.pendings, pendingDescription)\n    string = string .. getTestList('failure', failureCount, handler.failures, failureDescription)\n    string = string .. getTestList('error', errorCount, handler.errors, failureDescription)\n\n    string = string .. ((skippedCount + failureCount + errorCount) > 0 and '\\n' or '')\n    string = string .. getSummary('skipped', skippedCount)\n    string = string .. getSummary('failure', failureCount)\n    string = string .. getSummary('error', errorCount)\n\n    return string\n  end\n\n  local getFullName = function(element)\n    return getFileLine(element) .. colors.bright(handler.getFullName(element))\n  end\n\n  handler.suiteReset = function()\n    fileCount = 0\n    fileTestCount = 0\n    testCount = 0\n    successCount = 0\n    skippedCount = 0\n    failureCount = 0\n    errorCount = 0\n\n    return nil, true\n  end\n\n  handler.suiteStart = function(suite, count, total, randomseed)\n    if total > 1 then\n      io_write(string_format(repeatSuiteString, count, total))\n    end\n    if randomseed then\n      io_write(string_format(randomizeString, randomseed))\n    end\n    io_write(suiteStartString)\n    io_write(globalSetup)\n    io_flush()\n\n    return nil, true\n  end\n\n  handler.suiteEnd = function(suite, count, total)\n    local elapsedTime_ms = suite.duration * 1000\n    local tests = (testCount == 1 and 'test' or 'tests')\n    local files = (fileCount == 1 and 'file' or 'files')\n    io_write(globalTeardown)\n    io_write(string_format(suiteEndString, testCount, tests, fileCount, files, elapsedTime_ms))\n    io_write(getSummaryString())\n    io_flush()\n\n    return nil, true\n  end\n\n  handler.fileStart = function(file)\n    fileTestCount = 0\n    io_write(string_format(fileStartString, file.name))\n    io_flush()\n    return nil, true\n  end\n\n  handler.fileEnd = function(file)\n    local elapsedTime_ms = file.duration * 1000\n    local tests = (fileTestCount == 1 and 'test' or 'tests')\n    fileCount = fileCount + 1\n    io_write(string_format(fileEndString, fileTestCount, tests, file.name, elapsedTime_ms))\n    io_flush()\n    return nil, true\n  end\n\n  handler.testStart = function(element, parent)\n    io_write(string_format(runString, getFullName(element)))\n    io_flush()\n\n    return nil, true\n  end\n\n  handler.testEnd = function(element, parent, status, debug)\n    local elapsedTime_ms = element.duration * 1000\n    local string\n\n    fileTestCount = fileTestCount + 1\n    testCount = testCount + 1\n    if status == 'success' then\n      successCount = successCount + 1\n      string = successString\n    elseif status == 'pending' then\n      skippedCount = skippedCount + 1\n      string = skippedString\n    elseif status == 'failure' then\n      failureCount = failureCount + 1\n      string = failureString\n    elseif status == 'error' then\n      errorCount = errorCount + 1\n      string = errorString\n    end\n\n    io_write(string_format(string, getFullName(element), elapsedTime_ms))\n    io_flush()\n\n    return nil, true\n  end\n\n  handler.testFailure = function(element, parent, message, debug)\n    if not options.deferPrint then\n      io_write(failureDescription(handler.failures[#handler.failures]))\n      io_flush()\n    end\n    return nil, true\n  end\n\n  handler.testError = function(element, parent, message, debug)\n    if not options.deferPrint then\n      io_write(failureDescription(handler.errors[#handler.errors]))\n      io_flush()\n    end\n    return nil, true\n  end\n\n  handler.error = function(element, parent, message, debug)\n    if element.descriptor ~= 'it' then\n      if not options.deferPrint then\n        io_write(failureDescription(handler.errors[#handler.errors]))\n        io_flush()\n      end\n      errorCount = errorCount + 1\n    end\n\n    return nil, true\n  end\n\n  busted.subscribe({ 'suite', 'reset' }, handler.suiteReset)\n  busted.subscribe({ 'suite', 'start' }, handler.suiteStart)\n  busted.subscribe({ 'suite', 'end' }, handler.suiteEnd)\n  busted.subscribe({ 'file', 'start' }, handler.fileStart)\n  busted.subscribe({ 'file', 'end' }, handler.fileEnd)\n  busted.subscribe({ 'test', 'start' }, handler.testStart, { predicate = handler.cancelOnPending })\n  busted.subscribe({ 'test', 'end' }, handler.testEnd, { predicate = handler.cancelOnPending })\n  busted.subscribe({ 'failure', 'it' }, handler.testFailure)\n  busted.subscribe({ 'error', 'it' }, handler.testError)\n  busted.subscribe({ 'failure' }, handler.error)\n  busted.subscribe({ 'error' }, handler.error)\n\n  return handler\nend"},{"name":"\/Users\/nascarsayan\/Code\/github.com\/nascarsayan\/sqids-lua\/lua_modules\/share\/lua\/5.4\/busted\/runner.lua","coverage":[null,null,0,0,0,0,0,0,0,null,null,3,null,0,0,0,null,0,null,0,0,0,0,null,0,null,0,null,0,0,0,0,0,null,null,0,0,0,0,0,0,null,null,0,null,0,0,null,null,null,0,0,0,0,null,null,null,0,0,3,0,0,null,null,null,null,3,0,null,null,null,3,0,0,null,null,null,3,3,null,null,3,3,null,null,null,3,3,0,null,null,null,null,3,3,3,null,6,0,0,null,null,6,0,0,null,null,6,0,0,0,null,null,6,0,0,null,0,null,0,0,null,null,null,3,3,3,null,null,6,3,3,3,3,3,3,3,null,null,null,3,null,null,3,0,null,null,0,null,0,0,0,0,null,null,null,null,0,0,null,0,0,0,0,null,null,0,null,null,3,0,0,0,0,null,null,null,null,null,6,3,3,3,3,3,3,3,3,3,null,null,3,null,3,3,3,6,3,3,3,3,null,null,0,0,null,null,3,3,6,3,3,3,null,null,3,null,3,0,null,null],"source":"-- Busted command-line runner\n\nlocal path = require 'pl.path'\nlocal tablex = require 'pl.tablex'\nlocal term = require 'term'\nlocal utils = require 'busted.utils'\nlocal exit = require 'busted.compatibility'.exit\nlocal loadstring = require 'busted.compatibility'.loadstring\nlocal loaded = false\n\nreturn function(options)\n  if loaded then return function() end else loaded = true end\n\n  local isatty = io.type(io.stdout) == 'file' and term.isatty(io.stdout)\n  options = tablex.update(require 'busted.options', options or {})\n  options.output = options.output or (isatty and 'utfTerminal' or 'plainTerminal')\n\n  local busted = require 'busted.core'()\n\n  local cli = require 'busted.modules.cli'(options)\n  local filterLoader = require 'busted.modules.filter_loader'()\n  local helperLoader = require 'busted.modules.helper_loader'()\n  local outputHandlerLoader = require 'busted.modules.output_handler_loader'()\n\n  local luacov = require 'busted.modules.luacov'()\n\n  require 'busted'(busted)\n\n  local level = 2\n  local info = debug.getinfo(level, 'Sf')\n  local source = info.source\n  local fileName = source:sub(1,1) == '@' and source:sub(2) or nil\n  local forceExit = fileName == nil\n\n  -- Parse the cli arguments\n  local appName = path.basename(fileName or 'busted')\n  cli:set_name(appName)\n  local cliArgs, err = cli:parse(arg)\n  if not cliArgs then\n    io.stderr:write(err .. '\\n')\n    exit(1, forceExit)\n  end\n\n  if cliArgs.version then\n    -- Return early if asked for the version\n    print(busted.version)\n    exit(0, forceExit)\n  end\n\n  -- Load current working directory\n  local _, err = path.chdir(path.normpath(cliArgs.directory))\n  if err then\n    io.stderr:write(appName .. ': error: ' .. err .. '\\n')\n    exit(1, forceExit)\n  end\n\n  -- If coverage arg is passed in, load LuaCovsupport\n  if cliArgs.coverage then\n    local ok, err = luacov(cliArgs['coverage-config-file'])\n    if not ok then\n      io.stderr:write(appName .. ': error: ' .. err .. '\\n')\n      exit(1, forceExit)\n    end\n  end\n\n  -- If auto-insulate is disabled, re-register file without insulation\n  if not cliArgs['auto-insulate'] then\n    busted.register('file', 'file', {})\n  end\n\n  -- If lazy is enabled, make lazy setup\/teardown the default\n  if cliArgs.lazy then\n    busted.register('setup', 'lazy_setup')\n    busted.register('teardown', 'lazy_teardown')\n  end\n\n  -- Add additional package paths based on lpath and cpath cliArgs\n  if #cliArgs.lpath > 0 then\n    package.path = (cliArgs.lpath .. ';' .. package.path):gsub(';;',';')\n  end\n\n  if #cliArgs.cpath > 0 then\n    package.cpath = (cliArgs.cpath .. ';' .. package.cpath):gsub(';;',';')\n  end\n\n  -- Load and execute commands given on the command-line\n  if cliArgs.e then\n    for k,v in ipairs(cliArgs.e) do\n      loadstring(v)()\n    end\n  end\n\n  -- watch for test errors and failures\n  local failures = 0\n  local errors = 0\n  local quitOnError = not cliArgs['keep-going']\n\n  busted.subscribe({ 'error', 'output' }, function(element, parent, message)\n    io.stderr:write(appName .. ': error: Cannot load output library: ' .. element.name .. '\\n' .. message .. '\\n')\n    return nil, true\n  end)\n\n  busted.subscribe({ 'error', 'helper' }, function(element, parent, message)\n    io.stderr:write(appName .. ': error: Cannot load helper script: ' .. element.name .. '\\n' .. message .. '\\n')\n    return nil, true\n  end)\n\n  busted.subscribe({ 'error' }, function(element, parent, message)\n    errors = errors + 1\n    busted.skipAll = quitOnError\n    return nil, true\n  end)\n\n  busted.subscribe({ 'failure' }, function(element, parent, message)\n    if element.descriptor == 'it' then\n      failures = failures + 1\n    else\n      errors = errors + 1\n    end\n    busted.skipAll = quitOnError\n    return nil, true\n  end)\n\n  -- Set up randomization options\n  busted.sort = cliArgs['sort-tests']\n  busted.randomize = cliArgs['shuffle-tests']\n  busted.randomseed = tonumber(cliArgs.seed) or utils.urandom() or os.time()\n\n  -- Set up output handler to listen to events\n  outputHandlerLoader(busted, cliArgs.output, {\n    defaultOutput = options.output,\n    enableSound = cliArgs['enable-sound'],\n    verbose = cliArgs.verbose,\n    suppressPending = cliArgs['suppress-pending'],\n    language = cliArgs.lang,\n    deferPrint = cliArgs['defer-print'],\n    arguments = cliArgs.Xoutput,\n  })\n\n  -- Pre-load the LuaJIT 'ffi' module if applicable\n  require 'busted.luajit'()\n\n  -- Set up helper script, must succeed to even start tests\n  if cliArgs.helper and cliArgs.helper ~= '' then\n    local ok, err = helperLoader(busted, cliArgs.helper, {\n      verbose = cliArgs.verbose,\n      language = cliArgs.lang,\n      arguments = cliArgs.Xhelper\n    })\n    if not ok then\n      io.stderr:write(appName .. ': failed running the specified helper (' ..\n                      cliArgs.helper .. '), error: ' .. err .. '\\n')\n      exit(1, forceExit)\n    end\n  end\n\n  local getFullName = function(name)\n    local parent = busted.context.get()\n    local names = { name }\n\n    while parent and (parent.name or parent.descriptor) and\n      parent.descriptor ~= 'file' do\n      table.insert(names, 1, parent.name or parent.descriptor)\n      parent = busted.context.parent(parent)\n    end\n\n    return table.concat(names, ' ')\n  end\n\n  if cliArgs['log-success'] then\n    local logFile = assert(io.open(cliArgs['log-success'], 'a'))\n    busted.subscribe({ 'test', 'end' }, function (test, parent, status)\n      if status == \"success\" then\n        logFile:write(getFullName() .. \"\\n\")\n      end\n    end)\n  end\n\n  -- Load tag and test filters\n  filterLoader(busted, {\n    tags = cliArgs.tags,\n    excludeTags = cliArgs['exclude-tags'],\n    filter = cliArgs.filter,\n    name = cliArgs.name,\n    filterOut = cliArgs['filter-out'],\n    excludeNamesFile = cliArgs['exclude-names-file'],\n    list = cliArgs.list,\n    nokeepgoing = not cliArgs['keep-going'],\n    suppressPending = cliArgs['suppress-pending'],\n  })\n\n  if cliArgs.ROOT then\n    -- Load test directories\/files\n    local rootFiles = cliArgs.ROOT\n    local patterns = cliArgs.pattern\n    local testFileLoader = require 'busted.modules.test_file_loader'(busted, cliArgs.loaders)\n    testFileLoader(rootFiles, patterns, {\n      excludes = cliArgs['exclude-pattern'],\n      verbose = cliArgs.verbose,\n      recursive = cliArgs['recursive'],\n    })\n  else\n    -- Running standalone, use standalone loader\n    local testFileLoader = require 'busted.modules.standalone_loader'(busted)\n    testFileLoader(info, { verbose = cliArgs.verbose })\n  end\n\n  local runs = cliArgs['repeat']\n  local execute = require 'busted.execute'(busted)\n  execute(runs, {\n    seed = cliArgs.seed,\n    shuffle = cliArgs['shuffle-files'],\n    sort = cliArgs['sort-files'],\n  })\n\n  busted.publish({ 'exit' })\n\n  if options.standalone or failures > 0 or errors > 0 then\n    exit(failures + errors, forceExit)\n  end\nend"},{"name":"\/Users\/nascarsayan\/Code\/github.com\/nascarsayan\/sqids-lua\/lua_modules\/share\/lua\/5.4\/busted\/status.lua","coverage":[null,606,606,606,606,606,606,606,606,null,606,null,null,null,522,522,768,522,522,522,null,null,0,null,null,null,0,null,null,null,null,84,84,84,null,null,null,null,1044,522,690,null,null],"source":"local function get_status(status)\n  local smap = {\n    ['success'] = 'success',\n    ['pending'] = 'pending',\n    ['failure'] = 'failure',\n    ['error'] = 'error',\n    ['true'] = 'success',\n    ['false'] = 'failure',\n    ['nil'] = 'error',\n  }\n  return smap[tostring(status)] or 'error'\nend\n\nreturn function(inital_status)\n  local objstat = get_status(inital_status)\n  local obj = {\n    success = function(self) return (objstat == 'success') end,\n    pending = function(self) return (objstat == 'pending') end,\n    failure = function(self) return (objstat == 'failure') end,\n    error   = function(self) return (objstat == 'error') end,\n\n    get = function(self)\n      return objstat\n    end,\n\n    set = function(self, status)\n      objstat = get_status(status)\n    end,\n\n    update = function(self, status)\n      -- prefer current failure\/error status over new status\n      status = get_status(status)\n      if objstat == 'success' or (objstat == 'pending' and status ~= 'success') then\n        objstat = status\n      end\n    end\n  }\n\n  return setmetatable(obj, {\n    __index = {},\n    __tostring = function(self) return objstat end\n  })\nend"},{"name":"\/Users\/nascarsayan\/Code\/github.com\/nascarsayan\/sqids-lua\/lua_modules\/share\/lua\/5.4\/busted\/utils.lua","coverage":[0,null,null,3,3,15,12,12,null,null,null,null,null,null,null,0,0,0,0,0,0,null,0,null,null,null,3,3,3,3,3,15,12,null,3,null,null],"source":"return {\n  copy_interpreter_args = function(arguments)\n    -- copy non-positive command-line args auto-inserted by Lua interpreter\n    if arguments and _G.arg then\n      local i = 0\n      while _G.arg[i] do\n        arguments[i] = _G.arg[i]\n        i = i - 1\n      end\n    end\n  end,\n\n  split = require 'pl.utils'.split,\n\n  shuffle = function(t, seed)\n    if seed then math.randomseed(seed) end\n    local n = #t\n    while n >= 2 do\n      local k = math.random(n)\n      t[n], t[k] = t[k], t[n]\n      n = n - 1\n    end\n    return t\n  end,\n\n  urandom = function()\n    local f = io.open('\/dev\/urandom', 'rb')\n    if not f then return nil end\n    local s = f:read(4) f:close()\n    local bytes = {s:byte(1, 4)}\n    local value = 0\n    for _, v in ipairs(bytes) do\n      value = value * 256 + v\n    end\n    return value\n  end,\n}"},{"name":"\/Users\/nascarsayan\/Code\/github.com\/nascarsayan\/sqids-lua\/lua_modules\/share\/lua\/5.4\/cliargs.lua","coverage":[null,null,3,3,null,3,null,3,3,3,null,null,3,null,3,null,null,null,null,3,258,255,42,null,null,null,3,null,null,3,null,3],"source":"-- luacheck: ignore 212\n\nlocal core = require('cliargs.core')()\nlocal unpack = _G.unpack or table.unpack\n\nlocal cli = setmetatable({},{ __index = core })\n\nfunction cli:parse(arguments, no_cleanup)\n  if not no_cleanup then\n    cli:cleanup()\n  end\n\n  local out = { core.parse(self, arguments) }\n\n  return unpack(out)\nend\n\n-- Clean up the entire module (unload the scripts) as it's expected to be\n-- discarded after use.\nfunction cli:cleanup()\n  for k, v in pairs(package.loaded) do\n    if (v == cli) or (k:match('cliargs')) then\n      package.loaded[k] = nil\n    end\n  end\n\n  cli = nil\nend\n\ncli.VERSION = \"3.0-2\"\n\nreturn cli"},{"name":"\/Users\/nascarsayan\/Code\/github.com\/nascarsayan\/sqids-lua\/lua_modules\/share\/lua\/5.4\/cliargs\/core.lua","coverage":[null,null,null,0,0,0,0,0,0,0,0,null,null,0,null,null,null,6,6,null,0,null,null,null,null,null,null,null,null,null,null,null,null,3,3,3,null,3,3,null,6,0,null,null,null,0,null,null,null,null,null,6,6,null,6,0,null,null,null,6,0,null,null,6,0,null,null,null,6,6,6,6,6,6,6,6,6,6,null,null,6,null,null,null,null,null,null,null,0,null,0,0,null,null,null,null,null,null,null,0,0,0,null,null,null,null,null,null,null,null,0,0,0,null,null,0,null,null,null,null,null,null,null,null,null,3,3,null,3,null,null,null,3,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,3,0,null,null,3,0,null,0,0,null,null,0,0,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,3,0,0,null,0,0,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,3,0,0,null,null,0,null,0,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,3,0,null,null,null,0,null,null,null,0,0,null,null,0,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,3,0,null,null,null,0,null,null,null,0,null,null,null,0,null,0,null,null,null,0,null,null,null,0,null,0,0,null,null,0,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,3,0,null,null,null,0,null,null,null,0,null,null,null,null,null,0,0,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,3,6,0,0,null,null,12,null,6,null,6,null,6,0,null,null,6,null,6,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,3,0,null,0,0,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,3,3,null,null,null,null,null,null,3,0,null,null,3,0,null,null,null,null,null,null,3,0,null,null,3,null,null,0],"source":"-- luacheck: ignore 212\n\nlocal _\nlocal disect = require('cliargs.utils.disect')\nlocal lookup = require('cliargs.utils.lookup')\nlocal filter = require('cliargs.utils.filter')\nlocal shallow_copy = require('cliargs.utils.shallow_copy')\nlocal create_printer = require('cliargs.printer')\nlocal config_loader = require('cliargs.config_loader')\nlocal parser = require('cliargs.parser')\nlocal K = require 'cliargs.constants'\n\nlocal function is_callable(fn)\n  return type(fn) == \"function\" or (getmetatable(fn) or {}).__call\nend\n\nlocal function cast_to_boolean(v)\n  if v == nil then\n    return v\n  else\n    return v and true or false\n  end\nend\n\n-- -------- --\n-- CLI Main --\n-- -------- --\nlocal function create_core()\n  --- @module\n  ---\n  --- The primary export you receive when you require the library. For example:\n  ---\n  ---     local cli = require 'cliargs'\n  local cli = {}\n  local colsz = { 0, 0 } -- column width, help text. Set to 0 for auto detect\n  local options = {}\n\n  cli.name = \"\"\n  cli.description = \"\"\n\n  cli.printer = create_printer(function()\n    return {\n      name = cli.name,\n      description = cli.description,\n      options = options,\n      colsz = colsz\n    }\n  end)\n\n  -- Used internally to add an option\n  local function define_option(k, ek, v, label, desc, default, callback)\n    local flag = (v == nil) -- no value, so it's a flag\n    local negatable = flag and (ek and ek:find('^%[no%-]') ~= nil)\n\n    if negatable then\n      ek = ek:sub(6)\n    end\n\n    -- guard against duplicates\n    if lookup(k, ek, options) then\n      error(\"Duplicate option: \" .. (k or ek) .. \", please rename one of them.\")\n    end\n\n    if negatable and lookup(nil, \"no-\"..ek, options) then\n      error(\"Duplicate option: \" .. (\"no-\"..ek) .. \", please rename one of them.\")\n    end\n\n    -- below description of full entry record, nils included for reference\n    local entry = {\n      type = K.TYPE_OPTION,\n      key = k,\n      expanded_key = ek,\n      desc = desc,\n      default = default,\n      label = label,\n      flag = flag,\n      negatable = negatable,\n      callback = callback\n    }\n\n    table.insert(options, entry)\n  end\n\n  local function define_command_option(key)\n    --- @module\n    ---\n    --- This is a special instance of the [cli]() module that you receive when\n    --- you define a new command using [cli#command]().\n    local cmd = create_core()\n\n    cmd.__key__ = key\n    cmd.type = K.TYPE_COMMAND\n\n    --- Specify a file that the command should run. The rest of the arguments\n    --- are forward to that file to process, which is free to use or not use\n    --- lua_cliargs in turn.\n    ---\n    --- @param {string} file_path\n    ---        Absolute file-path to a lua script to execute.\n    function cmd:file(file_path)\n      cmd.__file__ = file_path\n      return cmd\n    end\n\n    --- Define a command handler. This callback will be invoked if the command\n    --- argument was supplied by the user at runtime. What you return from this\n    --- callback will be returned to the parent CLI library's parse routine and\n    --- it will return that in turn!\n    ---\n    --- @param {function} callback\n    function cmd:action(callback)\n      cmd.__action__ = callback\n      return cmd\n    end\n\n    return cmd\n  end\n\n  -- ------------------------------------------------------------------------ --\n  -- PUBLIC API\n  -- ------------------------------------------------------------------------ --\n\n  --- CONFIG\n\n  --- Assigns the name of the program which will be used for logging.\n  function cli:set_name(in_name)\n    cli.name = in_name\n\n    return self\n  end\n\n  --- Write down a brief, 1-liner description of what the program does.\n  function cli:set_description(in_description)\n    cli.description = in_description\n\n    return self\n  end\n\n  --- Sets the amount of space allocated to the argument keys and descriptions\n  --- in the help listing.\n  ---\n  --- The sizes are used for wrapping long argument keys and descriptions.\n  ---\n  --- @param {number} [key_cols=0]\n  ---        The number of columns assigned to the argument keys, set to 0 to\n  ---        auto detect.\n  ---\n  --- @param {number} [desc_cols=0]\n  ---        The number of columns assigned to the argument descriptions, set to\n  ---        0 to auto set the total width to 72.\n  function cli:set_colsz(key_cols, desc_cols)\n    colsz = { key_cols or colsz[1], desc_cols or colsz[2] }\n  end\n\n  function cli:redefine_default(key, new_default)\n    local entry = lookup(key, key, options)\n\n    if not entry then\n      return nil\n    end\n\n    if entry.flag then\n      new_default = cast_to_boolean(new_default)\n    end\n\n    entry.default = shallow_copy(new_default)\n\n    return true\n  end\n\n  --- Load default values from a table.\n  ---\n  --- @param {table} config\n  ---        Your new set of defaults. The keys could either point to the short\n  ---        or expanded option keys, and their values are the new defaults.\n  ---\n  --- @param {boolean} [strict=false]\n  ---        Turn this on to return nil and an error message if a key in the\n  ---        config table could not be mapped to any CLI option.\n  ---\n  --- @return {true}\n  ---         When the new defaults were loaded successfully, or strict was not\n  ---         set.\n  ---\n  --- @return {union<nil, string>}\n  ---         When strict was set and there was an error.\n  function cli:load_defaults(config, strict)\n    for k, v in pairs(config) do\n      local success = self:redefine_default(k, v)\n\n      if strict and not success then\n        return nil, \"Unrecognized option with the key '\" .. k .. \"'\"\n      end\n    end\n\n    return true\n  end\n\n  --- Read config values from a configuration file.\n  ---\n  --- @param {string} path\n  ---        Absolute file path.\n  ---\n  --- @param {string} [format=nil]\n  ---        The config file format, which has to be one of:\n  ---        \"lua\", \"json\", \"ini\", or \"yaml\".\n  ---        When this is left blank, we try to auto-detect the format from the\n  ---        file extension.\n  ---\n  --- @param {boolean} [strict=false]\n  ---        Forwarded to [#load_defaults](). See that method for the parameter\n  ---        description.\n  ---\n  --- @return {true|union<nil, string>}\n  ---         Returns true on successful load. Otherwise, nil and an error\n  ---         message are returned instead.\n  function cli:read_defaults(path, format)\n    if not format then\n      format = path:match('%.([^%.]+)$')\n    end\n\n    local loader = config_loader.FORMAT_LOADERS[format]\n\n    if not loader then\n      return nil, 'Unsupported file format \"' .. format .. '\"'\n    end\n\n    return config_loader[loader](path)\n  end\n\n  --- Define a required argument.\n  ---\n  ---\n  --- Required arguments do not take a symbol like `-` or `--`, may not have a\n  --- default value, and are parsed in the order they are defined.\n  ---\n  ---\n  --- For example:\n  ---\n  --- ```lua\n  --- cli:argument('INPUT', 'path to the input file')\n  --- cli:argument('OUTPUT', 'path to the output file')\n  --- ```\n  ---\n  --- At run-time, the arguments have to be specified using the following\n  --- notation:\n  ---\n  --- ```bash\n  --- $ .\/script.lua .\/main.c .\/a.out\n  --- ```\n  ---\n  --- If the user does not pass a value to _every_ argument, the parser will\n  --- raise an error.\n  ---\n  --- @param {string} key\n  ---\n  ---        The argument identifier that will be displayed to the user and\n  ---        be used to reference the run-time value.\n  ---\n  --- @param {string} desc\n  ---\n  ---        A description for this argument to display in usage help.\n  ---\n  --- @param {function} [callback]\n  ---        Callback to invoke when this argument is parsed.\n  function cli:argument(key, desc, callback)\n    assert(type(key) == \"string\" and type(desc) == \"string\",\n      \"Key and description are mandatory arguments (Strings)\"\n    )\n\n    assert(callback == nil or is_callable(callback),\n      \"Callback argument must be a function\"\n    )\n\n    if lookup(key, key, options) then\n      error(\"Duplicate argument: \" .. key .. \", please rename one of them.\")\n    end\n\n    table.insert(options, {\n      type = K.TYPE_ARGUMENT,\n      key = key,\n      desc = desc,\n      callback = callback\n    })\n\n    return self\n  end\n\n  --- Defines a \"splat\" (or catch-all) argument.\n  ---\n  --- This is a special kind of argument that may be specified 0 or more times,\n  --- the values being appended to a list.\n  ---\n  --- For example, let's assume our program takes a single output file and works\n  --- on multiple source files:\n  ---\n  --- ```lua\n  --- cli:argument('OUTPUT', 'path to the output file')\n  --- cli:splat('INPUTS', 'the sources to compile', nil, 10) -- up to 10 source files\n  --- ```\n  ---\n  --- At run-time, it could be invoked as such:\n  ---\n  --- ```bash\n  --- $ .\/script.lua .\/a.out file1.c file2.c main.c\n  --- ```\n  ---\n  --- If you want to make the output optional, you could do something like this:\n  ---\n  --- ```lua\n  --- cli:option('-o, --output=FILE', 'path to the output file', '.\/a.out')\n  --- cli:splat('INPUTS', 'the sources to compile', nil, 10)\n  --- ```\n  ---\n  --- And now we may omit the output file path:\n  ---\n  --- ```bash\n  --- $ .\/script.lua file1.c file2.c main.c\n  --- ```\n  ---\n  --- @param {string} key\n  ---        The argument's \"name\" that will be displayed to the user.\n  ---\n  --- @param {string} desc\n  ---        A description of the argument.\n  ---\n  --- @param {*} [default=nil]\n  ---        A default value.\n  ---\n  --- @param {number} [maxcount=1]\n  ---        The maximum number of occurences allowed.\n  ---\n  --- @param {function} [callback]\n  ---        A function to call **everytime** a value for this argument is\n  ---        parsed.\n  ---\n  function cli:splat(key, desc, default, maxcount, callback)\n    assert(#filter(options, 'type', K.TYPE_SPLAT) == 0,\n      \"Only one splat argument may be defined.\"\n    )\n\n    assert(type(key) == \"string\" and type(desc) == \"string\",\n      \"Key and description are mandatory arguments (Strings)\"\n    )\n\n    assert(type(default) == \"string\" or default == nil,\n      \"Default value must either be omitted or be a string\"\n    )\n\n    maxcount = tonumber(maxcount or 1)\n\n    assert(maxcount > 0 and maxcount < 1000,\n      \"Maxcount must be a number from 1 to 999\"\n    )\n\n    assert(is_callable(callback) or callback == nil,\n      \"Callback argument: expected a function or nil\"\n    )\n\n    local typed_default = default or {}\n\n    if type(typed_default) ~= 'table' then\n      typed_default = { typed_default }\n    end\n\n    table.insert(options, {\n      type = K.TYPE_SPLAT,\n      key = key,\n      desc = desc,\n      default = typed_default,\n      maxcount = maxcount,\n      callback = callback\n    })\n\n    return self\n  end\n\n  --- Defines an optional argument.\n  ---\n  --- Optional arguments can use 3 different notations, and can accept a value.\n  ---\n  --- @param {string} key\n  ---\n  ---        The argument identifier. This can either be `-key`, or\n  ---        `-key, --expanded-key`.\n  ---        Values can be specified either by appending a space after the\n  ---        identifier (e.g. `-key value` or `--expanded-key value`) or by\n  ---        separating them with a `=` (e.g. `-key=value` or\n  ---        `--expanded-key=value`).\n  ---\n  --- @param {string} desc\n  ---\n  ---        A description for the argument to be shown in --help.\n  ---\n  --- @param {bool} [default=nil]\n  ---\n  ---         A default value to use in case the option was not specified at\n  ---         run-time (the default value is nil if you leave this blank.)\n  ---\n  --- @param {function} [callback]\n  ---\n  ---        A callback to invoke when this option is parsed.\n  ---\n  --- @example\n  ---\n  --- The following option will be stored in `args[\"i\"]` and `args[\"input\"]`\n  --- with a default value of `file.txt`:\n  ---\n  ---     cli:option(\"-i, --input=FILE\", \"path to the input file\", \"file.txt\")\n  function cli:option(key, desc, default, callback)\n    assert(type(key) == \"string\" and type(desc) == \"string\",\n      \"Key and description are mandatory arguments (Strings)\"\n    )\n\n    assert(is_callable(callback) or callback == nil,\n      \"Callback argument: expected a function or nil\"\n    )\n\n    local k, ek, v = disect(key)\n\n    -- if there's no VALUE indicator anywhere, what they want really is a flag.\n    -- e.g:\n    --\n    --     cli:option('-q, --quiet', '...')\n    if v == nil then\n      return self:flag(key, desc, default, callback)\n    end\n\n    define_option(k, ek, v, key, desc, default, callback)\n\n    return self\n  end\n\n  --- Define an optional \"flag\" argument.\n  ---\n  --- Flags are a special subset of options that can either be `true` or `false`.\n  ---\n  --- For example:\n  --- ```lua\n  --- cli:flag('-q, --quiet', 'Suppress output.', true)\n  --- ```\n  ---\n  --- At run-time:\n  ---\n  --- ```bash\n  --- $ .\/script.lua --quiet\n  --- $ .\/script.lua -q\n  --- ```\n  ---\n  --- Passing a value to a flag raises an error:\n  ---\n  --- ```bash\n  --- $ .\/script.lua --quiet=foo\n  --- $ echo $? # => 1\n  --- ```\n  ---\n  --- Flags may be _negatable_ by prepending `[no-]` to their key:\n  ---\n  --- ```lua\n  --- cli:flag('-c, --[no-]compress', 'whether to compress or not', true)\n  --- ```\n  ---\n  --- Now the user gets to pass `--no-compress` if they want to skip\n  --- compression, or either specify `--compress` explicitly or leave it\n  --- unspecified to use compression.\n  ---\n  --- @param {string} key\n  --- @param {string} desc\n  --- @param {*} default\n  --- @param {function} callback\n  function cli:flag(key, desc, default, callback)\n    if type(default) == \"function\" then\n      callback = default\n      default = nil\n    end\n\n    assert(type(key) == \"string\" and type(desc) == \"string\",\n      \"Key and description are mandatory arguments (Strings)\"\n    )\n\n    local k, ek, v = disect(key)\n\n    if v ~= nil then\n      error(\"A flag type option cannot have a value set: \" .. key)\n    end\n\n    define_option(k, ek, nil, key, desc, cast_to_boolean(default), callback)\n\n    return self\n  end\n\n  --- Define a command argument.\n  ---\n  --- @param {string} name\n  ---        The name of the command and the argument that the user has to\n  ---        supply to invoke it.\n  ---\n  --- @param {string} [desc]\n  ---        An optional string to show in the help listing which should\n  ---        describe what the command does. It will be displayed if --help\n  ---        was run on the main program.\n  ---\n  ---\n  --- @return {cmd}\n  ---         Another instance of the CLI library which is scoped to that\n  ---         command.\n  function cli:command(name, desc)\n    local cmd = define_command_option(name)\n\n    cmd:set_name(cli.name .. ' ' .. name)\n    cmd:set_description(desc)\n\n    table.insert(options, cmd)\n\n    return cmd\n  end\n\n  --- Parse the process arguments table.\n  ---\n  --- @param {table<string>} [arguments=_G.arg]\n  ---        The list of arguments to parse. Defaults to the global `arg` table\n  ---        which contains the arguments the process was started with.\n  ---\n  --- @return {table}\n  ---         A table containing all the arguments, options, flags,\n  ---         and splat arguments that were specified or had a default\n  ---         (where applicable).\n  ---\n  --- @return {array<nil, string>}\n  ---         If a parsing error has occured, note that the --help option is\n  ---         also considered an error.\n  function cli:parse(arguments)\n    return parser(arguments, options, cli.printer)\n  end\n\n  --- Prints the USAGE message.\n  ---\n  --- @return {string}\n  ---         The USAGE message.\n  function cli:print_usage()\n    cli.printer.print(cli:get_usage_message())\n  end\n\n  function cli:get_usage_message()\n    return cli.printer.generate_usage()\n  end\n\n  --- Prints the HELP information.\n  ---\n  --- @return {string}\n  ---         The HELP message.\n  function cli:print_help()\n    cli.printer.print(cli.printer.generate_help_and_usage())\n  end\n\n  return cli\nend\n\nreturn create_core"},{"name":"\/Users\/nascarsayan\/Code\/github.com\/nascarsayan\/sqids-lua\/lua_modules\/share\/lua\/5.4\/cliargs\/parser.lua","coverage":[0,null,null,null,null,0,0,0,0,null,null,0,0,0,null,null,null,0,0,0,null,null,null,null,null,0,0,3,null,6,3,null,3,0,null,0,0,null,0,0,null,null,0,0,0,null,0,0,null,null,null,0,null,0,null,0,null,0,null,null,0,null,null,null,null,3,null,null,0,null,18,15,0,null,null,null,3,null,null,0,null,3,0,null,3,null,null,null,0,3,3,3,3,null,3,null,3,null,null,3,null,6,3,3,null,null,3,0,null,null,3,3,null,3,0,null,0,null,null,3,0,null,null,null,3,0,3,3,null,null,null,null,null,0,null,null,null,null,0,0,null,null,null,null,null,null,null,null,0,null,0,0,null,null,null,null,null,3,null,3,0,null,null,0,0,null,0,null,null,0,null,0,0,null,null,null,null,0,0,null,0,null,0,0,null,0,0,null,null,null,0,null,null,null,0,null,0,0,null,0,0,null,0,0,null,null,null,null,0,null,null,null,3,null,null,0,3,3,null,3,3,null,null,3,0,0,0,0,0,null,null,0,0,0,null,null,null,null,3,null,null,0,3,null,6,null,null,12,6,3,null,null,null,6,3,null,3,null,null,null,null,6,6,null,null,9,6,6,null,6,6,null,null,6,null,6,null,6,null,6,0,null,null,null,6,null,null,3,null,null,null,null,6,3,3,null,null,3,null,null,6,6,6,6,6,3,0,null,3,null,null,null,null,null,null,null],"source":"local K = require 'cliargs.constants'\n\n-------------------------------------------------------------------------------\n-- UTILS\n-------------------------------------------------------------------------------\nlocal shallow_copy = require 'cliargs.utils.shallow_copy'\nlocal filter = require 'cliargs.utils.filter'\nlocal disect_argument = require 'cliargs.utils.disect_argument'\nlocal lookup = require 'cliargs.utils.lookup'\n\nlocal function clone_table_shift(t)\n  local clone = shallow_copy(t)\n  table.remove(clone, 1)\n  return clone\nend\n\nlocal function clone_table_remove(t, index)\n  local clone = shallow_copy(t)\n  table.remove(clone, index)\n  return clone\nend\n\n-------------------------------------------------------------------------------\n-- PARSE ROUTINES\n-------------------------------------------------------------------------------\nlocal p = {}\nfunction p.invoke_command(args, options, done)\n  local commands = filter(options, 'type', K.TYPE_COMMAND)\n\n  for index, opt in ipairs(args) do\n    local command = filter(commands, '__key__', opt)[1]\n\n    if command then\n      local command_args = clone_table_remove(args, index)\n\n      if command.__action__ then\n        local parsed_command_args, err = command:parse(command_args)\n\n        if err then\n          return nil, err\n        end\n\n        return command.__action__(parsed_command_args)\n      elseif command.__file__ then\n        local filename = command.__file__\n\n        if type(filename) == 'function' then\n          filename = filename()\n        end\n\n        local run_command_file = function()\n          _G.arg = command_args\n\n          local res, err = assert(loadfile(filename))()\n\n          _G.arg = args\n\n          return res, err\n        end\n\n        return run_command_file()\n      end\n    end\n  end\n\n  return done()\nend\n\nfunction p.print_help(args, printer, done)\n  -- has --help or -h ? display the help listing and abort!\n  for _, v in pairs(args) do\n    if v == \"--help\" or v == \"-h\" then\n      return nil, printer.generate_help_and_usage()\n    end\n  end\n\n  return done()\nend\n\nfunction p.track_dump_request(args, done)\n  -- starts with --__DUMP__; set dump to true to dump the parsed arguments\n  if args[1] == \"--__DUMP__\" then\n    return done(true, clone_table_shift(args))\n  else\n    return done(false, args)\n  end\nend\n\nfunction p.process_arguments(args, options, done)\n  local values = {}\n  local cursor = 0\n  local argument_cursor = 1\n  local argument_delimiter_found = false\n  local function consume()\n    cursor = cursor + 1\n\n    return args[cursor]\n  end\n\n  local required = filter(options, 'type', K.TYPE_ARGUMENT)\n\n  while cursor < #args do\n    local curr_opt = consume()\n    local symbol, key, value, flag_negated = disect_argument(curr_opt)\n\n    -- end-of-options indicator:\n    if curr_opt == \"--\" then\n      argument_delimiter_found = true\n\n    -- an option:\n    elseif not argument_delimiter_found and symbol then\n      local entry = lookup(key, key, options)\n\n      if not key or not entry then\n        local option_type = value and \"option\" or \"flag\"\n\n        return nil, \"unknown\/bad \" .. option_type .. \": \" .. curr_opt\n      end\n\n      if flag_negated and not entry.negatable then\n        return nil, \"flag '\" .. curr_opt .. \"' may not be negated using --no-\"\n      end\n\n      -- a flag and a value specified? that's an error\n      if entry.flag and value then\n        return nil, \"flag \" .. curr_opt .. \" does not take a value\"\n      elseif entry.flag then\n        value = not flag_negated\n      -- an option:\n      else\n        -- the value might be in the next argument, e.g:\n        --\n        --     --compress lzma\n        if not value then\n          -- if the option contained a = and there's no value, it means they\n          -- want to nullify an option's default value. eg:\n          --\n          --    --compress=\n          if curr_opt:find('=') then\n            value = '__CLIARGS_NULL__'\n          else\n            -- NOTE: this has the potential to be buggy and swallow the next\n            -- entry as this entry's value even though that entry may be an\n            -- actual argument\/option\n            --\n            -- this would be a user error and there is no determinate way to\n            -- figure it out because if there's no leading symbol (- or --)\n            -- in that entry it can be an actual argument. :shrug:\n            value = consume()\n\n            if not value then\n              return nil, \"option \" .. curr_opt .. \" requires a value to be set\"\n            end\n          end\n        end\n      end\n\n      table.insert(values, { entry = entry, value = value })\n\n      if entry.callback then\n        local altkey = entry.key\n        local status, err\n\n        if key == entry.key then\n          altkey = entry.expanded_key\n        else\n          key = entry.expanded_key\n        end\n\n        status, err = entry.callback(key, value, altkey, curr_opt)\n\n        if status == nil and err then\n          return nil, err\n        end\n      end\n\n    -- a regular argument:\n    elseif argument_cursor <= #required then\n      local entry = required[argument_cursor]\n\n      table.insert(values, { entry = entry, value = curr_opt })\n\n      if entry.callback then\n        local status, err = entry.callback(entry.key, curr_opt)\n\n        if status == nil and err then\n          return nil, err\n        end\n      end\n\n      argument_cursor = argument_cursor + 1\n\n    -- a splat argument:\n    else\n      local entry = filter(options, 'type', K.TYPE_SPLAT)[1]\n\n      if entry then\n        table.insert(values, { entry = entry, value = curr_opt })\n\n        if entry.callback then\n          local status, err = entry.callback(entry.key, curr_opt)\n\n          if status == nil and err then\n            return nil, err\n          end\n        end\n      end\n\n      argument_cursor = argument_cursor + 1\n    end\n  end\n\n  return done(values, argument_cursor - 1)\nend\n\nfunction p.validate(options, arg_count, done)\n  local required = filter(options, 'type', K.TYPE_ARGUMENT)\n  local splatarg = filter(options, 'type', K.TYPE_SPLAT)[1] or { maxcount = 0 }\n\n  local min_arg_count = #required\n  local max_arg_count = #required + splatarg.maxcount\n\n  -- missing any required arguments, or too many?\n  if arg_count < min_arg_count or arg_count > max_arg_count then\n    if splatarg.maxcount > 0 then\n      return nil, (\n        \"bad number of arguments: \" ..\n        min_arg_count .. \"-\" .. max_arg_count ..\n        \" argument(s) must be specified, not \" .. arg_count\n      )\n    else\n      return nil, (\n        \"bad number of arguments: \" ..\n        min_arg_count .. \" argument(s) must be specified, not \" .. arg_count\n      )\n    end\n  end\n\n  return done()\nend\n\nfunction p.collect_results(cli_values, options)\n  local results = {}\n  local function collect_with_default(entry)\n    local entry_values = {}\n    local _\n\n    for _, item in ipairs(cli_values) do\n      if item.entry == entry then\n        table.insert(entry_values, item.value)\n      end\n    end\n\n    if #entry_values == 0 then\n      return type(entry.default) == 'table' and entry.default or { entry.default }\n    else\n      return entry_values\n    end\n  end\n\n  local function write(entry, value)\n    if entry.key then results[entry.key] = value end\n    if entry.expanded_key then results[entry.expanded_key] = value end\n  end\n\n  for _, entry in pairs(options) do\n    local entry_cli_values = collect_with_default(entry)\n    local maxcount = entry.maxcount\n\n    if maxcount == nil then\n      maxcount = type(entry.default) == 'table' and 999 or 1\n    end\n\n    local entry_value = entry_cli_values\n\n    if maxcount == 1 and type(entry_cli_values) == 'table' then\n      -- take the last value\n      entry_value = entry_cli_values[#entry_cli_values]\n\n      if entry_value == '__CLIARGS_NULL__' then\n        entry_value = nil\n      end\n    end\n\n    write(entry, entry_value)\n  end\n\n  return results\nend\n\n\nreturn function(arguments, options, printer)\n  assert(arguments == nil or type(arguments) == \"table\",\n    \"expected an argument table to be passed in, \" ..\n    \"got something of type \" .. type(arguments)\n  )\n\n  local args = arguments or _G.arg or {}\n\n  -- the spiral of DOOM:\n  return p.invoke_command(args, options, function()\n    return p.track_dump_request(args, function(dump, args_without_dump)\n      return p.print_help(args_without_dump, printer, function()\n        return p.process_arguments(args_without_dump, options, function(values, arg_count)\n          return p.validate(options, arg_count, function()\n            if dump then\n              return nil, printer.dump_internal_state(values)\n            else\n              return p.collect_results(values, options)\n            end\n          end)\n        end)\n      end)\n    end)\n  end)\nend"},{"name":"\/Users\/nascarsayan\/Code\/github.com\/nascarsayan\/sqids-lua\/lua_modules\/share\/lua\/5.4\/cliargs\/printer.lua","coverage":[0,0,0,0,null,null,null,3,null,3,0,null,null,null,0,0,0,0,null,0,0,0,null,null,null,0,0,0,null,0,0,null,null,null,null,0,0,null,null,0,null,null,null,3,0,0,null,0,0,0,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,0,null,null,null,0,0,0,0,0,0,0,null,null,null,0,null,null,3,0,0,0,0,0,0,0,0,null,null,0,0,0,null,0,null,null,0,0,null,null,null,0,null,0,0,null,null,0,0,null,null,0,0,null,0,0,null,null,null,0,0,null,0,0,null,null,null,0,0,0,0,null,null,0,0,null,0,null,null,0,null,null,0,0,null,0,0,0,0,0,0,0,0,null,0,null,null,null,0,null,null,3,0,0,0,0,0,0,null,null,0,null,null,0,0,null,0,0,null,null,0,0,0,0,0,0,0,0,null,null,null,null,0,0,0,0,0,0,null,null,null,0,0,0,0,0,0,null,null,null,0,0,0,0,0,0,0,null,null,null,null,null,null,null,0,0,0,0,0,null,0,0,null,0,null,null,0,null,0,null,null,null,0,null,0,null,null,3,0,null,0,0,null,0,null,null,3,null,null,0],"source":"local wordwrap = require('cliargs.utils.wordwrap')\nlocal filter = require('cliargs.utils.filter')\nlocal K = require('cliargs.constants')\nlocal MAX_COLS = 72\nlocal _\n\nlocal function create_printer(get_parser_state)\n  local printer = {}\n\n  function printer.print(msg)\n    return _G.print(msg)\n  end\n\n  local function get_max_label_length()\n    local maxsz = 0\n    local state = get_parser_state()\n    local optargument = filter(state.options, 'type', K.TYPE_SPLAT)[1]\n    local commands = filter(state.options, 'type', K.TYPE_COMMAND)\n\n    for _, entry in ipairs(commands) do\n      if #entry.__key__ > maxsz then\n        maxsz = #entry.__key__\n      end\n    end\n\n    for _,table_name in ipairs({\"options\"}) do\n      for _, entry in ipairs(state[table_name]) do\n        local key = entry.label or entry.key or entry.__key__\n\n        if #key > maxsz then\n          maxsz = #key\n        end\n      end\n    end\n\n    if optargument and #optargument.key > maxsz then\n      maxsz = #optargument.key\n    end\n\n    return maxsz\n  end\n\n  -- Generate the USAGE heading message.\n  function printer.generate_usage()\n    local state = get_parser_state()\n    local msg = \"Usage:\"\n\n    local required = filter(state.options, 'type', K.TYPE_ARGUMENT)\n    local optional = filter(state.options, 'type', K.TYPE_OPTION)\n    local optargument = filter(state.options, 'type', K.TYPE_SPLAT)[1]\n\n    if #state.name > 0 then\n      msg = msg .. ' ' .. tostring(state.name)\n    end\n\n    if #optional > 0 then\n      msg = msg .. \" [OPTIONS]\"\n    end\n\n    if #required > 0 or optargument then\n      msg = msg .. \" [--]\"\n    end\n\n    if #required > 0 then\n      for _,entry in ipairs(required) do\n        msg = msg .. \" \" .. entry.key\n      end\n    end\n\n    if optargument then\n      if optargument.maxcount == 1 then\n        msg = msg .. \" [\" .. optargument.key .. \"]\"\n      elseif optargument.maxcount == 2 then\n        msg = msg .. \" [\" .. optargument.key .. \"-1 [\" .. optargument.key .. \"-2]]\"\n      elseif optargument.maxcount > 2 then\n        msg = msg .. \" [\" .. optargument.key .. \"-1 [\" .. optargument.key .. \"-2 [...]]]\"\n      end\n    end\n\n    return msg\n  end\n\n  function printer.generate_help()\n    local msg = ''\n    local state = get_parser_state()\n    local col1 = state.colsz[1]\n    local col2 = state.colsz[2]\n    local required = filter(state.options, 'type', K.TYPE_ARGUMENT)\n    local optional = filter(state.options, 'type', K.TYPE_OPTION)\n    local commands = filter(state.options, 'type', K.TYPE_COMMAND)\n    local optargument = filter(state.options, 'type', K.TYPE_SPLAT)[1]\n\n    local function append(label, desc)\n      label = \"  \" .. label .. string.rep(\" \", col1 - (#label + 2))\n      desc = table.concat(wordwrap(desc, col2), \"\\n\") -- word-wrap\n      desc = desc:gsub(\"\\n\", \"\\n\" .. string.rep(\" \", col1)) -- add padding\n\n      msg = msg .. label .. desc .. \"\\n\"\n    end\n\n    if col1 == 0 then\n      col1 = get_max_label_length(state)\n    end\n\n    -- add margins\n    col1 = col1 + 3\n\n    if col2 == 0 then\n      col2 = MAX_COLS - col1\n    end\n\n    if col2 < 10 then\n      col2 = 10\n    end\n\n    if #commands > 0 then\n      msg = msg .. \"\\nCOMMANDS: \\n\"\n\n      for _, entry in ipairs(commands) do\n        append(entry.__key__, entry.description or '')\n      end\n    end\n\n    if required[1] or optargument then\n      msg = msg .. \"\\nARGUMENTS: \\n\"\n\n      for _,entry in ipairs(required) do\n        append(entry.key, entry.desc .. \" (required)\")\n      end\n    end\n\n    if optargument then\n      local optarg_desc = ' ' .. optargument.desc\n      local default_value = optargument.maxcount > 1 and\n        optargument.default[1] or\n        optargument.default\n\n      if #optargument.default > 0 then\n        optarg_desc = optarg_desc .. \" (optional, default: \" .. tostring(default_value[1]) .. \")\"\n      else\n        optarg_desc = optarg_desc .. \" (optional)\"\n      end\n\n      append(optargument.key, optarg_desc)\n    end\n\n    if #optional > 0 then\n      msg = msg .. \"\\nOPTIONS: \\n\"\n\n      for _,entry in ipairs(optional) do\n        local desc = entry.desc\n        if not entry.flag and entry.default and #tostring(entry.default) > 0 then\n          local readable_default = type(entry.default) == \"table\" and \"[]\" or tostring(entry.default)\n          desc = desc .. \" (default: \" .. readable_default .. \")\"\n        elseif entry.flag and entry.negatable then\n          local readable_default = entry.default and 'on' or 'off'\n          desc = desc .. \" (default: \" .. readable_default .. \")\"\n        end\n        append(entry.label, desc)\n      end\n    end\n\n    return msg\n  end\n\n  function printer.dump_internal_state(values)\n    local state = get_parser_state()\n    local required = filter(state.options, 'type', K.TYPE_ARGUMENT)\n    local optional = filter(state.options, 'type', K.TYPE_OPTION)\n    local optargument = filter(state.options, 'type', K.TYPE_SPLAT)[1]\n    local maxlabel = get_max_label_length()\n    local msg = ''\n\n    local function print(fragment)\n      msg = msg .. fragment .. '\\n'\n    end\n\n    print(\"\\n======= Provided command line =============\")\n    print(\"\\nNumber of arguments: \", #arg)\n\n    for i,v in ipairs(arg) do -- use gloabl 'arg' not the modified local 'args'\n      print(string.format(\"%3i = '%s'\", i, v))\n    end\n\n    print(\"\\n======= Parsed command line ===============\")\n    if #required > 0 then print(\"\\nArguments:\") end\n    for _, entry in ipairs(required) do\n      print(\n        \"  \" ..\n        entry.key .. string.rep(\" \", maxlabel + 2 - #entry.key) ..\n        \" => '\" ..\n        tostring(values[entry]) ..\n        \"'\"\n      )\n    end\n\n    if optargument then\n      print(\n        \"\\nOptional arguments:\" ..\n        optargument.key ..\n        \"; allowed are \" ..\n        tostring(optargument.maxcount) ..\n        \" arguments\"\n      )\n\n      if optargument.maxcount == 1 then\n          print(\n            \"  \" .. optargument.key ..\n            string.rep(\" \", maxlabel + 2 - #optargument.key) ..\n            \" => '\" ..\n            optargument.key ..\n            \"'\"\n          )\n      else\n        for i = 1, optargument.maxcount do\n          if values[optargument] and values[optargument][i] then\n            print(\n              \"  \" .. tostring(i) ..\n              string.rep(\" \", maxlabel + 2 - #tostring(i)) ..\n              \" => '\" ..\n              tostring(values[optargument][i]) ..\n              \"'\"\n            )\n          end\n        end\n      end\n    end\n\n    if #optional > 0 then print(\"\\nOptional parameters:\") end\n    local doubles = {}\n    for _, entry in pairs(optional) do\n      if not doubles[entry] then\n        local value = values[entry]\n\n        if type(value) == \"string\" then\n          value = \"'\"..value..\"'\"\n        else\n          value = tostring(value) ..\" (\" .. type(value) .. \")\"\n        end\n\n        print(\"  \" .. entry.label .. string.rep(\" \", maxlabel + 2 - #entry.label) .. \" => \" .. value)\n\n        doubles[entry] = entry\n      end\n    end\n\n    print(\"\\n===========================================\\n\\n\")\n\n    return msg\n  end\n\n  function printer.generate_help_and_usage()\n    local msg = ''\n\n    msg = msg .. printer.generate_usage() .. '\\n'\n    msg = msg .. printer.generate_help()\n\n    return msg\n  end\n\n  return printer\nend\n\nreturn create_printer"},{"name":"\/Users\/nascarsayan\/Code\/github.com\/nascarsayan\/sqids-lua\/lua_modules\/share\/lua\/5.4\/cliargs\/utils\/disect.lua","coverage":[0,null,0,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,6,6,0,null,null,null,null,null,null,6,6,0,null,null,null,6,6,null,null,null,6,null,null,6,null,null,6,6,null,6,0,null,null,6,null,null,0],"source":"local split = require('cliargs.utils.split')\n\nlocal RE_ADD_COMMA = \"^%-([%a%d]+)[%s]%-%-\"\nlocal RE_ADJUST_DELIMITER = \"(%-%-?)([%a%d]+)[%s]\"\n\n-- parameterize the key if needed, possible variations:\n--\n--     -key\n--     -key VALUE\n--     -key=VALUE\n--\n--     -key, --expanded\n--     -key, --expanded VALUE\n--     -key, --expanded=VALUE\n--\n--     -key --expanded\n--     -key --expanded VALUE\n--     -key --expanded=VALUE\n--\n--     --expanded\n--     --expanded VALUE\n--     --expanded=VALUE\nlocal function disect(key)\n  -- characters allowed are a-z, A-Z, 0-9\n  -- extended + values also allow; # @ _ + -\n  local k, ek, v, _\n  local dummy\n\n  -- leading \"-\" or \"--\"\n  local prefix\n\n  -- if there is no comma, between short and extended, add one\n  _, _, dummy = key:find(RE_ADD_COMMA)\n  if dummy then\n    key = key:gsub(RE_ADD_COMMA, \"-\" .. dummy .. \", --\", 1)\n  end\n\n  -- replace space delimiting the value indicator by \"=\"\n  --\n  --     -key VALUE => -key=VALUE\n  --     --expanded-key VALUE => --expanded-key=VALUE\n  _, _, prefix, dummy = key:find(RE_ADJUST_DELIMITER)\n  if prefix and dummy then\n    key = key:gsub(RE_ADJUST_DELIMITER, prefix .. dummy .. \"=\", 1)\n  end\n\n  -- if there is no \"=\", then append one\n  if not key:find(\"=\") then\n    key = key .. \"=\"\n  end\n\n  -- get value\n  _, _, v = key:find(\".-%=(.+)\")\n\n  -- get key(s), remove spaces\n  key = split(key, \"=\")[1]:gsub(\" \", \"\")\n\n  -- get short key & extended key\n  _, _, k = key:find(\"^%-([^-][^%s,]*)\")\n  _, _, ek = key:find(\"%-%-(.+)$\")\n\n  if v == \"\" then\n    v = nil\n  end\n\n  return k,ek,v\nend\n\nreturn disect"},{"name":"\/Users\/nascarsayan\/Code\/github.com\/nascarsayan\/sqids-lua\/lua_modules\/share\/lua\/5.4\/cliargs\/utils\/disect_argument.lua","coverage":[null,null,3,null,3,null,3,null,null,null,3,null,3,3,null,null,3,0,0,null,null,null,null,3,0,0,null,null,0,3,3,3,3,null,null,0],"source":"local function disect_argument(str)\n  local _, symbol, key, value\n  local negated = false\n\n  _, _, symbol, key = str:find(\"^([%-]*)(.*)\")\n\n  if key then\n    local actual_key\n\n    -- split value and key\n    _, _, actual_key, value = key:find(\"([^%=]+)[%=]?(.*)\")\n\n    if value then\n      key = actual_key\n    end\n\n    if key:sub(1,3) == \"no-\" then\n      key = key:sub(4,-1)\n      negated = true\n    end\n  end\n\n  -- no leading symbol means the sole fragment is the value.\n  if #symbol == 0 then\n    value = str\n    key = nil\n  end\n\n  return\n    #symbol > 0 and symbol or nil,\n    key and #key > 0 and key or nil,\n    value and #value > 0 and value or nil,\n    negated and true or false\nend\n\nreturn disect_argument"},{"name":"\/Users\/nascarsayan\/Code\/github.com\/nascarsayan\/sqids-lua\/lua_modules\/share\/lua\/5.4\/cliargs\/utils\/filter.lua","coverage":[null,15,null,39,24,0,null,null,null,15,null],"source":"return function(t, k, v)\n  local out = {}\n\n  for _, item in ipairs(t) do\n    if item[k] == v then\n      table.insert(out, item)\n    end\n  end\n\n  return out\nend"},{"name":"\/Users\/nascarsayan\/Code\/github.com\/nascarsayan\/sqids-lua\/lua_modules\/share\/lua\/5.4\/cliargs\/utils\/lookup.lua","coverage":[null,null,null,null,null,15,12,6,0,null,null,6,3,null,null,3,0,null,null,null,null,6,null,null,0],"source":"\n-- Used internally to lookup an entry using either its short or expanded keys\nlocal function lookup(k, ek, ...)\n  local _\n\n  for _, t in ipairs({...}) do\n    for _, entry in ipairs(t) do\n      if k  and entry.key == k then\n        return entry\n      end\n\n      if ek and entry.expanded_key == ek then\n        return entry\n      end\n\n      if entry.negatable then\n        if ek and (\"no-\"..entry.expanded_key) == ek then return entry end\n      end\n    end\n  end\n\n  return nil\nend\n\nreturn lookup"},{"name":"\/Users\/nascarsayan\/Code\/github.com\/nascarsayan\/sqids-lua\/lua_modules\/share\/lua\/5.4\/cliargs\/utils\/split.lua","coverage":[null,6,6,6,6,null,12,6,6,null,null,6,6,null,null,6,0,0,null,null,6,null,null,0],"source":"local function split(str, pat)\n  local t = {}\n  local fpat = \"(.-)\" .. pat\n  local last_end = 1\n  local s, e, cap = str:find(fpat, 1)\n\n  while s do\n    if s ~= 1 or cap ~= \"\" then\n      table.insert(t,cap)\n    end\n\n    last_end = e + 1\n    s, e, cap = str:find(fpat, last_end)\n  end\n\n  if last_end <= #str then\n    cap = str:sub(last_end)\n    table.insert(t, cap)\n  end\n\n  return t\nend\n\nreturn split"},{"name":"\/Users\/nascarsayan\/Code\/github.com\/nascarsayan\/sqids-lua\/lua_modules\/share\/lua\/5.4\/luassert\/assert.lua","coverage":[0,0,0,0,null,0,null,null,0,null,null,0,0,0,0,null,0,0,0,null,0,null,null,0,null,null,630,null,null,null,1890,1260,null,null,630,1890,1260,630,null,null,null,630,630,null,630,0,0,0,null,0,0,null,null,630,15,null,615,null,0,0,null,0,0,0,null,null,null,null,0,null,null,null,2388,1260,null,null,1128,null,null,null,0,630,null,null,null,0,0,0,null,0,null,null,null,0,null,null,null,null,null,0,0,0,null,0,null,null,null,null,null,0,null,null,null,null,0,null,null,null,null,0,0,0,0,0,0,0,0,null,null,0,null,null,null,3,null,null,null,0,null,null,null,0,null,null,null,0,null,null,null,0,0,0,null,null,null,null,0,0,null,0,null,null,null,0,null,null,513,0,0,null,513,null,null,null,630,null,null,null,null,0],"source":"local s = require 'say'\nlocal astate = require 'luassert.state'\nlocal util = require 'luassert.util'\nlocal unpack = util.unpack\nlocal obj   -- the returned module table\nlocal level_mt = {}\n\n-- list of namespaces\nlocal namespace = require 'luassert.namespaces'\n\nlocal function geterror(assertion_message, failure_message, args)\n  if util.hastostring(failure_message) then\n    failure_message = tostring(failure_message)\n  elseif failure_message ~= nil then\n    failure_message = astate.format_argument(failure_message)\n  end\n  local message = s(assertion_message, obj:format(args))\n  if message and failure_message then\n    message = failure_message .. \"\\n\" .. message\n  end\n  return message or failure_message\nend\n\nlocal __state_meta = {\n\n  __call = function(self, ...)\n    local keys = util.extract_keys(\"assertion\", self.tokens)\n\n    local assertion\n\n    for _, key in ipairs(keys) do\n      assertion = namespace.assertion[key] or assertion\n    end\n\n    if assertion then\n      for _, key in ipairs(keys) do\n        if namespace.modifier[key] then\n          namespace.modifier[key].callback(self)\n        end\n      end\n\n      local arguments = util.make_arglist(...)\n      local val, retargs = assertion.callback(self, arguments, util.errorlevel())\n\n      if (not val) == self.mod then\n        local message = assertion.positive_message\n        if not self.mod then\n          message = assertion.negative_message\n        end\n        local err = geterror(message, rawget(self,\"failure_message\"), arguments)\n        error(err or \"assertion failed!\", util.errorlevel())\n      end\n\n      if retargs then\n        return unpack(retargs)\n      end\n      return ...\n    else\n      local arguments = util.make_arglist(...)\n      self.tokens = {}\n\n      for _, key in ipairs(keys) do\n        if namespace.modifier[key] then\n          namespace.modifier[key].callback(self, arguments, util.errorlevel())\n        end\n      end\n    end\n\n    return self\n  end,\n\n  __index = function(self, key)\n    for token in key:lower():gmatch('[^_]+') do\n      table.insert(self.tokens, token)\n    end\n\n    return self\n  end\n}\n\nobj = {\n  state = function() return setmetatable({mod=true, tokens={}}, __state_meta) end,\n\n  -- registers a function in namespace\n  register = function(self, nspace, name, callback, positive_message, negative_message)\n    local lowername = name:lower()\n    if not namespace[nspace] then\n      namespace[nspace] = {}\n    end\n    namespace[nspace][lowername] = {\n      callback = callback,\n      name = lowername,\n      positive_message=positive_message,\n      negative_message=negative_message\n    }\n  end,\n\n  -- unregisters a function in a namespace\n  unregister = function(self, nspace, name)\n    local lowername = name:lower()\n    if not namespace[nspace] then\n      namespace[nspace] = {}\n    end\n    namespace[nspace][lowername] = nil\n  end,\n\n  -- registers a formatter\n  -- a formatter takes a single argument, and converts it to a string, or returns nil if it cannot format the argument\n  add_formatter = function(self, callback)\n    astate.add_formatter(callback)\n  end,\n\n  -- unregisters a formatter\n  remove_formatter = function(self, fmtr)\n    astate.remove_formatter(fmtr)\n  end,\n\n  format = function(self, args)\n    -- args.n specifies the number of arguments in case of 'trailing nil' arguments which get lost\n    local nofmt = args.nofmt or {}  -- arguments in this list should not be formatted\n    local fmtargs = args.fmtargs or {} -- additional arguments to be passed to formatter\n    for i = 1, (args.n or #args) do -- cannot use pairs because table might have nils\n      if not nofmt[i] then\n        local val = args[i]\n        local valfmt = astate.format_argument(val, nil, fmtargs[i])\n        if valfmt == nil then valfmt = tostring(val) end -- no formatter found\n        args[i] = valfmt\n      end\n    end\n    return args\n  end,\n\n  set_parameter = function(self, name, value)\n    astate.set_parameter(name, value)\n  end,\n\n  get_parameter = function(self, name)\n    return astate.get_parameter(name)\n  end,\n\n  add_spy = function(self, spy)\n    astate.add_spy(spy)\n  end,\n\n  snapshot = function(self)\n    return astate.snapshot()\n  end,\n\n  level = function(self, level)\n    return setmetatable({\n        level = level\n      }, level_mt)\n  end,\n\n  -- returns the level if a level-value, otherwise nil\n  get_level = function(self, level)\n    if getmetatable(level) ~= level_mt then\n      return nil -- not a valid error-level\n    end\n    return level.level\n  end,\n}\n\nlocal __meta = {\n\n  __call = function(self, bool, message, level, ...)\n    if not bool then\n      local err_level = (self:get_level(level) or 1) + 1\n      error(message or \"assertion failed!\", err_level)\n    end\n    return bool , message , level , ...\n  end,\n\n  __index = function(self, key)\n    return rawget(self, key) or self.state()[key]\n  end,\n\n}\n\nreturn setmetatable(obj, __meta)"},{"name":"\/Users\/nascarsayan\/Code\/github.com\/nascarsayan\/sqids-lua\/lua_modules\/share\/lua\/5.4\/luassert\/assertions.lua","coverage":[null,null,null,null,null,null,null,null,0,0,0,0,null,null,0,null,null,null,630,0,null,null,null,null,0,null,0,0,0,0,null,0,0,null,0,null,0,0,0,0,0,null,0,0,null,null,null,null,null,0,null,null,null,0,0,0,0,0,0,0,0,0,0,null,0,0,0,0,0,0,null,null,null,0,0,0,0,null,0,0,null,null,0,0,0,0,0,null,null,null,0,0,0,0,0,0,null,0,0,null,null,0,0,0,null,0,0,null,0,null,null,null,201,201,201,201,null,201,201,201,null,null,null,297,297,297,297,297,null,297,297,297,297,297,297,null,0,null,0,0,0,null,null,null,0,0,0,0,null,null,null,0,0,0,null,null,null,15,15,15,15,15,15,15,15,null,15,null,15,15,15,15,15,15,15,15,null,15,0,null,15,null,15,15,15,null,15,15,null,0,0,0,null,null,0,null,null,null,0,0,0,0,0,0,0,0,null,null,0,0,0,0,0,null,null,null,0,0,0,null,0,0,null,0,null,0,0,0,0,0,0,0,0,null,0,0,0,null,null,null,0,0,0,0,0,null,0,null,null,0,0,0,null,0,0,null,0,0,null,null,0,null,null,null,105,105,105,null,null,null,12,12,12,null,null,null,0,0,0,0,0,null,null,null,0,0,0,0,0,0,0,null,null,null,0,null,null,0,0,0,0,0,0,0,0,null,0,0,0,0,0,0,0,0,0,0,0,0,null,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],"source":"-- module will not return anything, only register assertions with the main assert engine\n\n-- assertions take 2 parameters;\n-- 1) state\n-- 2) arguments list. The list has a member 'n' with the argument count to check for trailing nils\n-- 3) level The level of the error position relative to the called function\n-- returns; boolean; whether assertion passed\n\nlocal assert = require('luassert.assert')\nlocal astate = require ('luassert.state')\nlocal util = require ('luassert.util')\nlocal s = require('say')\n\nlocal function format(val)\n  return astate.format_argument(val) or tostring(val)\nend\n\nlocal function set_failure_message(state, message)\n  if message ~= nil then\n    state.failure_message = message\n  end\nend\n\nlocal function unique(state, arguments, level)\n  local list = arguments[1]\n  local deep\n  local argcnt = arguments.n\n  if type(arguments[2]) == \"boolean\" or (arguments[2] == nil and argcnt > 2) then\n    deep = arguments[2]\n    set_failure_message(state, arguments[3])\n  else\n    if type(arguments[3]) == \"boolean\" then\n      deep = arguments[3]\n    end\n    set_failure_message(state, arguments[2])\n  end\n  for k,v in pairs(list) do\n    for k2, v2 in pairs(list) do\n      if k ~= k2 then\n        if deep and util.deepcompare(v, v2, true) then\n          return false\n        else\n          if v == v2 then\n            return false\n          end\n        end\n      end\n    end\n  end\n  return true\nend\n\nlocal function near(state, arguments, level)\n  local level = (level or 1) + 1\n  local argcnt = arguments.n\n  assert(argcnt > 2, s(\"assertion.internal.argtolittle\", { \"near\", 3, tostring(argcnt) }), level)\n  local expected = tonumber(arguments[1])\n  local actual = tonumber(arguments[2])\n  local tolerance = tonumber(arguments[3])\n  local numbertype = \"number or object convertible to a number\"\n  assert(expected, s(\"assertion.internal.badargtype\", { 1, \"near\", numbertype, format(arguments[1]) }), level)\n  assert(actual, s(\"assertion.internal.badargtype\", { 2, \"near\", numbertype, format(arguments[2]) }), level)\n  assert(tolerance, s(\"assertion.internal.badargtype\", { 3, \"near\", numbertype, format(arguments[3]) }), level)\n  -- switch arguments for proper output message\n  util.tinsert(arguments, 1, util.tremove(arguments, 2))\n  arguments[3] = tolerance\n  arguments.nofmt = arguments.nofmt or {}\n  arguments.nofmt[3] = true\n  set_failure_message(state, arguments[4])\n  return (actual >= expected - tolerance and actual <= expected + tolerance)\nend\n\nlocal function matches(state, arguments, level)\n  local level = (level or 1) + 1\n  local argcnt = arguments.n\n  assert(argcnt > 1, s(\"assertion.internal.argtolittle\", { \"matches\", 2, tostring(argcnt) }), level)\n  local pattern = arguments[1]\n  local actual = nil\n  if util.hastostring(arguments[2]) or type(arguments[2]) == \"number\" then\n    actual = tostring(arguments[2])\n  end\n  local err_message\n  local init_arg_num = 3\n  for i=3,argcnt,1 do\n    if arguments[i] and type(arguments[i]) ~= \"boolean\" and not tonumber(arguments[i]) then\n      if i == 3 then init_arg_num = init_arg_num + 1 end\n      err_message = util.tremove(arguments, i)\n      break\n    end\n  end\n  local init = arguments[3]\n  local plain = arguments[4]\n  local stringtype = \"string or object convertible to a string\"\n  assert(type(pattern) == \"string\", s(\"assertion.internal.badargtype\", { 1, \"matches\", \"string\", type(arguments[1]) }), level)\n  assert(actual, s(\"assertion.internal.badargtype\", { 2, \"matches\", stringtype, format(arguments[2]) }), level)\n  assert(init == nil or tonumber(init), s(\"assertion.internal.badargtype\", { init_arg_num, \"matches\", \"number\", type(arguments[3]) }), level)\n  -- switch arguments for proper output message\n  util.tinsert(arguments, 1, util.tremove(arguments, 2))\n  set_failure_message(state, err_message)\n  local retargs\n  local ok\n  if plain then\n    ok = (actual:find(pattern, init, plain) ~= nil)\n    retargs = ok and { pattern } or {}\n  else\n    retargs = { actual:match(pattern, init) }\n    ok = (retargs[1] ~= nil)\n  end\n  return ok, retargs\nend\n\nlocal function equals(state, arguments, level)\n  local level = (level or 1) + 1\n  local argcnt = arguments.n\n  assert(argcnt > 1, s(\"assertion.internal.argtolittle\", { \"equals\", 2, tostring(argcnt) }), level)\n  local result =  arguments[1] == arguments[2]\n  -- switch arguments for proper output message\n  util.tinsert(arguments, 1, util.tremove(arguments, 2))\n  set_failure_message(state, arguments[3])\n  return result\nend\n\nlocal function same(state, arguments, level)\n  local level = (level or 1) + 1\n  local argcnt = arguments.n\n  assert(argcnt > 1, s(\"assertion.internal.argtolittle\", { \"same\", 2, tostring(argcnt) }), level)\n  if type(arguments[1]) == 'table' and type(arguments[2]) == 'table' then\n    local result, crumbs = util.deepcompare(arguments[1], arguments[2], true)\n    -- switch arguments for proper output message\n    util.tinsert(arguments, 1, util.tremove(arguments, 2))\n    arguments.fmtargs = arguments.fmtargs or {}\n    arguments.fmtargs[1] = { crumbs = crumbs }\n    arguments.fmtargs[2] = { crumbs = crumbs }\n    set_failure_message(state, arguments[3])\n    return result\n  end\n  local result = arguments[1] == arguments[2]\n  -- switch arguments for proper output message\n  util.tinsert(arguments, 1, util.tremove(arguments, 2))\n  set_failure_message(state, arguments[3])\n  return result\nend\n\nlocal function truthy(state, arguments, level)\n  local argcnt = arguments.n\n  assert(argcnt > 0, s(\"assertion.internal.argtolittle\", { \"truthy\", 1, tostring(argcnt) }), level)\n  set_failure_message(state, arguments[2])\n  return arguments[1] ~= false and arguments[1] ~= nil\nend\n\nlocal function falsy(state, arguments, level)\n  local argcnt = arguments.n\n  assert(argcnt > 0, s(\"assertion.internal.argtolittle\", { \"falsy\", 1, tostring(argcnt) }), level)\n  return not truthy(state, arguments, level)\nend\n\nlocal function has_error(state, arguments, level)\n  local level = (level or 1) + 1\n  local retargs = util.shallowcopy(arguments)\n  local func = arguments[1]\n  local err_expected = arguments[2]\n  local failure_message = arguments[3]\n  assert(util.callable(func), s(\"assertion.internal.badargtype\", { 1, \"error\", \"function or callable object\", type(func) }), level)\n  local ok, err_actual = pcall(func)\n  if type(err_actual) == 'string' then\n    -- remove 'path\/to\/file:line: ' from string\n    err_actual = err_actual:gsub('^.-:%d+: ', '', 1)\n  end\n  retargs[1] = err_actual\n  arguments.nofmt = {}\n  arguments.n = 2\n  arguments[1] = (ok and '(no error)' or err_actual)\n  arguments[2] = (err_expected == nil and '(error)' or err_expected)\n  arguments.nofmt[1] = ok\n  arguments.nofmt[2] = (err_expected == nil)\n  set_failure_message(state, failure_message)\n\n  if ok or err_expected == nil then\n    return not ok, retargs\n  end\n  if type(err_expected) == 'string' then\n    -- err_actual must be (convertible to) a string\n    if util.hastostring(err_actual) then\n      err_actual = tostring(err_actual)\n      retargs[1] = err_actual\n    end\n    if type(err_actual) == 'string' then\n      return err_expected == err_actual, retargs\n    end\n  elseif type(err_expected) == 'number' then\n    if type(err_actual) == 'string' then\n      return tostring(err_expected) == tostring(tonumber(err_actual)), retargs\n    end\n  end\n  return same(state, {err_expected, err_actual, [\"n\"] = 2}), retargs\nend\n\nlocal function error_matches(state, arguments, level)\n  local level = (level or 1) + 1\n  local retargs = util.shallowcopy(arguments)\n  local argcnt = arguments.n\n  local func = arguments[1]\n  local pattern = arguments[2]\n  assert(argcnt > 1, s(\"assertion.internal.argtolittle\", { \"error_matches\", 2, tostring(argcnt) }), level)\n  assert(util.callable(func), s(\"assertion.internal.badargtype\", { 1, \"error_matches\", \"function or callable object\", type(func) }), level)\n  assert(pattern == nil or type(pattern) == \"string\", s(\"assertion.internal.badargtype\", { 2, \"error\", \"string\", type(pattern) }), level)\n\n  local failure_message\n  local init_arg_num = 3\n  for i=3,argcnt,1 do\n    if arguments[i] and type(arguments[i]) ~= \"boolean\" and not tonumber(arguments[i]) then\n      if i == 3 then init_arg_num = init_arg_num + 1 end\n      failure_message = util.tremove(arguments, i)\n      break\n    end\n  end\n  local init = arguments[3]\n  local plain = arguments[4]\n  assert(init == nil or tonumber(init), s(\"assertion.internal.badargtype\", { init_arg_num, \"matches\", \"number\", type(arguments[3]) }), level)\n\n  local ok, err_actual = pcall(func)\n  if type(err_actual) == 'string' then\n    -- remove 'path\/to\/file:line: ' from string\n    err_actual = err_actual:gsub('^.-:%d+: ', '', 1)\n  end\n  retargs[1] = err_actual\n  arguments.nofmt = {}\n  arguments.n = 2\n  arguments[1] = (ok and '(no error)' or err_actual)\n  arguments[2] = pattern\n  arguments.nofmt[1] = ok\n  arguments.nofmt[2] = false\n  set_failure_message(state, failure_message)\n\n  if ok then return not ok, retargs end\n  if err_actual == nil and pattern == nil then\n    return true, {}\n  end\n\n  -- err_actual must be (convertible to) a string\n  if util.hastostring(err_actual) or\n     type(err_actual) == \"number\" or\n     type(err_actual) == \"boolean\" then\n    err_actual = tostring(err_actual)\n    retargs[1] = err_actual\n  end\n  if type(err_actual) == 'string' then\n    local ok\n    local retargs_ok\n    if plain then\n      retargs_ok = { pattern }\n      ok = (err_actual:find(pattern, init, plain) ~= nil)\n    else\n      retargs_ok = { err_actual:match(pattern, init) }\n      ok = (retargs_ok[1] ~= nil)\n    end\n    if ok then retargs = retargs_ok end\n    return ok, retargs\n  end\n\n  return false, retargs\nend\n\nlocal function is_true(state, arguments, level)\n  util.tinsert(arguments, 2, true)\n  set_failure_message(state, arguments[3])\n  return arguments[1] == arguments[2]\nend\n\nlocal function is_false(state, arguments, level)\n  util.tinsert(arguments, 2, false)\n  set_failure_message(state, arguments[3])\n  return arguments[1] == arguments[2]\nend\n\nlocal function is_type(state, arguments, level, etype)\n  util.tinsert(arguments, 2, \"type \" .. etype)\n  arguments.nofmt = arguments.nofmt or {}\n  arguments.nofmt[2] = true\n  set_failure_message(state, arguments[3])\n  return arguments.n > 1 and type(arguments[1]) == etype\nend\n\nlocal function returned_arguments(state, arguments, level)\n  arguments[1] = tostring(arguments[1])\n  arguments[2] = tostring(arguments.n - 1)\n  arguments.nofmt = arguments.nofmt or {}\n  arguments.nofmt[1] = true\n  arguments.nofmt[2] = true\n  if arguments.n < 2 then arguments.n = 2 end\n  return arguments[1] == arguments[2]\nend\n\nlocal function set_message(state, arguments, level)\n  state.failure_message = arguments[1]\nend\n\nlocal function is_boolean(state, arguments, level)  return is_type(state, arguments, level, \"boolean\")  end\nlocal function is_number(state, arguments, level)   return is_type(state, arguments, level, \"number\")   end\nlocal function is_string(state, arguments, level)   return is_type(state, arguments, level, \"string\")   end\nlocal function is_table(state, arguments, level)    return is_type(state, arguments, level, \"table\")    end\nlocal function is_nil(state, arguments, level)      return is_type(state, arguments, level, \"nil\")      end\nlocal function is_userdata(state, arguments, level) return is_type(state, arguments, level, \"userdata\") end\nlocal function is_function(state, arguments, level) return is_type(state, arguments, level, \"function\") end\nlocal function is_thread(state, arguments, level)   return is_type(state, arguments, level, \"thread\")   end\n\nassert:register(\"modifier\", \"message\", set_message)\nassert:register(\"assertion\", \"true\", is_true, \"assertion.same.positive\", \"assertion.same.negative\")\nassert:register(\"assertion\", \"false\", is_false, \"assertion.same.positive\", \"assertion.same.negative\")\nassert:register(\"assertion\", \"boolean\", is_boolean, \"assertion.same.positive\", \"assertion.same.negative\")\nassert:register(\"assertion\", \"number\", is_number, \"assertion.same.positive\", \"assertion.same.negative\")\nassert:register(\"assertion\", \"string\", is_string, \"assertion.same.positive\", \"assertion.same.negative\")\nassert:register(\"assertion\", \"table\", is_table, \"assertion.same.positive\", \"assertion.same.negative\")\nassert:register(\"assertion\", \"nil\", is_nil, \"assertion.same.positive\", \"assertion.same.negative\")\nassert:register(\"assertion\", \"userdata\", is_userdata, \"assertion.same.positive\", \"assertion.same.negative\")\nassert:register(\"assertion\", \"function\", is_function, \"assertion.same.positive\", \"assertion.same.negative\")\nassert:register(\"assertion\", \"thread\", is_thread, \"assertion.same.positive\", \"assertion.same.negative\")\nassert:register(\"assertion\", \"returned_arguments\", returned_arguments, \"assertion.returned_arguments.positive\", \"assertion.returned_arguments.negative\")\n\nassert:register(\"assertion\", \"same\", same, \"assertion.same.positive\", \"assertion.same.negative\")\nassert:register(\"assertion\", \"matches\", matches, \"assertion.matches.positive\", \"assertion.matches.negative\")\nassert:register(\"assertion\", \"match\", matches, \"assertion.matches.positive\", \"assertion.matches.negative\")\nassert:register(\"assertion\", \"near\", near, \"assertion.near.positive\", \"assertion.near.negative\")\nassert:register(\"assertion\", \"equals\", equals, \"assertion.equals.positive\", \"assertion.equals.negative\")\nassert:register(\"assertion\", \"equal\", equals, \"assertion.equals.positive\", \"assertion.equals.negative\")\nassert:register(\"assertion\", \"unique\", unique, \"assertion.unique.positive\", \"assertion.unique.negative\")\nassert:register(\"assertion\", \"error\", has_error, \"assertion.error.positive\", \"assertion.error.negative\")\nassert:register(\"assertion\", \"errors\", has_error, \"assertion.error.positive\", \"assertion.error.negative\")\nassert:register(\"assertion\", \"error_matches\", error_matches, \"assertion.error.positive\", \"assertion.error.negative\")\nassert:register(\"assertion\", \"error_match\", error_matches, \"assertion.error.positive\", \"assertion.error.negative\")\nassert:register(\"assertion\", \"matches_error\", error_matches, \"assertion.error.positive\", \"assertion.error.negative\")\nassert:register(\"assertion\", \"match_error\", error_matches, \"assertion.error.positive\", \"assertion.error.negative\")\nassert:register(\"assertion\", \"truthy\", truthy, \"assertion.truthy.positive\", \"assertion.truthy.negative\")\nassert:register(\"assertion\", \"falsy\", falsy, \"assertion.falsy.positive\", \"assertion.falsy.negative\")"},{"name":"\/Users\/nascarsayan\/Code\/github.com\/nascarsayan\/sqids-lua\/lua_modules\/share\/lua\/5.4\/luassert\/modifiers.lua","coverage":[null,0,null,null,630,null,null,null,0,0,null,null,0,0,0,0,0,0,0],"source":"-- module will not return anything, only register assertions\/modifiers with the main assert engine\nlocal assert = require('luassert.assert')\n\nlocal function is(state)\n  return state\nend\n\nlocal function is_not(state)\n  state.mod = not state.mod\n  return state\nend\n\nassert:register(\"modifier\", \"is\", is)\nassert:register(\"modifier\", \"are\", is)\nassert:register(\"modifier\", \"was\", is)\nassert:register(\"modifier\", \"has\", is)\nassert:register(\"modifier\", \"does\", is)\nassert:register(\"modifier\", \"not\", is_not)\nassert:register(\"modifier\", \"no\", is_not)"},{"name":"\/Users\/nascarsayan\/Code\/github.com\/nascarsayan\/sqids-lua\/lua_modules\/share\/lua\/5.4\/luassert\/state.lua","coverage":[null,null,null,0,null,0,null,null,null,0,null,0,null,null,null,null,null,0,null,null,null,null,null,0,null,0,0,null,0,null,null,0,null,0,0,null,null,0,null,0,null,0,0,0,null,0,0,0,null,null,null,null,null,null,0,null,null,null,null,null,0,0,0,0,null,null,null,null,null,0,null,null,null,0,0,0,0,null,null,null,null,0,0,null,null,null,null,0,0,0,0,null,null,0,0,null,0,null,null,null,null,null,3,3,null,null,null,0,0,0,null,0,null,0,0,null,0,null,null,null,null,0,null,null,0,null,0],"source":"-- maintains a state of the assert engine in a linked-list fashion\n-- records; formatters, parameters, spies and stubs\n\nlocal state_mt = {\n  __call = function(self)\n    self:revert()\n  end\n}\n\nlocal spies_mt = { __mode = \"kv\" }\n\nlocal nilvalue = {} -- unique ID to refer to nil values for parameters\n\n-- will hold the current state\nlocal current\n\n-- exported module table\nlocal state = {}\n\n------------------------------------------------------\n-- Reverts to a (specific) snapshot.\n-- @param self (optional) the snapshot to revert to. If not provided, it will revert to the last snapshot.\nstate.revert = function(self)\n  if not self then\n    -- no snapshot given, so move 1 up\n    self = current\n    if not self.previous then\n      -- top of list, no previous one, nothing to do\n      return\n    end\n  end\n  if getmetatable(self) ~= state_mt then error(\"Value provided is not a valid snapshot\", 2) end\n\n  if self.next then\n    self.next:revert()\n  end\n  -- revert formatters in 'last'\n  self.formatters = {}\n  -- revert parameters in 'last'\n  self.parameters = {}\n  -- revert spies\/stubs in 'last'\n  for s,_ in pairs(self.spies) do\n    self.spies[s] = nil\n    s:revert()\n  end\n  setmetatable(self, nil) -- invalidate as a snapshot\n  current = self.previous\n  current.next = nil\nend\n\n------------------------------------------------------\n-- Creates a new snapshot.\n-- @return snapshot table\nstate.snapshot = function()\n  local new = setmetatable ({\n    formatters = {},\n    parameters = {},\n    spies = setmetatable({}, spies_mt),\n    previous = current,\n    revert = state.revert,\n  }, state_mt)\n  if current then current.next = new end\n  current = new\n  return current\nend\n\n\n--  FORMATTERS\nstate.add_formatter = function(callback)\n  table.insert(current.formatters, 1, callback)\nend\n\nstate.remove_formatter = function(callback, s)\n  s = s or current\n  for i, v in ipairs(s.formatters) do\n    if v == callback then\n      table.remove(s.formatters, i)\n      break\n    end\n  end\n  -- wasn't found, so traverse up 1 state\n  if s.previous then\n    state.remove_formatter(callback, s.previous)\n  end\nend\n\nstate.format_argument = function(val, s, fmtargs)\n  s = s or current\n  for _, fmt in ipairs(s.formatters) do\n    local valfmt = fmt(val, fmtargs)\n    if valfmt ~= nil then return valfmt end\n  end\n  -- nothing found, check snapshot 1 up in list\n  if s.previous then\n    return state.format_argument(val, s.previous, fmtargs)\n  end\n  return nil -- end of list, couldn't format\nend\n\n\n--  PARAMETERS\nstate.set_parameter = function(name, value)\n  if value == nil then value = nilvalue end\n  current.parameters[name] = value\nend\n\nstate.get_parameter = function(name, s)\n  s = s or current\n  local val = s.parameters[name]\n  if val == nil and s.previous then\n    -- not found, so check 1 up in list\n    return state.get_parameter(name, s.previous)\n  end\n  if val ~= nilvalue then\n    return val\n  end\n  return nil\nend\n\n--  SPIES \/ STUBS\nstate.add_spy = function(spy)\n  current.spies[spy] = true\nend\n\nstate.snapshot()  -- create initial state\n\nreturn state"},{"name":"\/Users\/nascarsayan\/Code\/github.com\/nascarsayan\/sqids-lua\/lua_modules\/share\/lua\/5.4\/luassert\/util.lua","coverage":[0,0,null,null,0,15,0,0,0,null,null,0,1371,1371,null,1371,297,297,null,297,null,0,null,297,null,null,null,297,297,297,297,297,0,0,null,297,0,null,null,297,297,null,1371,1074,1074,0,null,null,1074,1074,0,0,0,null,null,1371,null,null,1074,null,null,297,297,null,297,null,null,0,15,15,15,60,45,null,15,null,null,0,0,0,0,null,null,0,0,0,null,0,0,null,0,0,null,0,null,0,null,null,null,null,null,null,0,0,0,0,0,0,0,null,0,null,null,null,null,null,null,0,0,0,null,0,null,null,null,null,null,null,null,null,null,0,0,0,0,0,0,null,0,0,null,0,0,null,null,null,0,null,null,0,0,null,0,0,0,null,null,0,null,null,null,0,null,null,null,null,null,null,null,null,0,null,null,null,null,null,0,0,0,0,0,null,null,0,null,null,null,null,null,null,null,0,0,null,null,null,0,0,null,null,0,null,null,null,null,null,null,null,null,null,null,0,null,615,615,615,615,615,615,0,0,null,null,615,615,0,615,null,0,0,null,null,1113,498,null,null,615,null,null,null,null,null,null,null,null,0,null,498,498,0,498,0,null,0,0,null,498,null,996,498,null,null,498,498,498,null,null,null,null,null,null,null,null,0,15,null,null,null,null,null,null,null,null,0,15,null,null,null,null,null,null,null,0,630,630,630,630,1260,630,630,630,null,630,630,null,null,null,null,null,null,null,0,630,null,null,630,630,630,1890,1260,1260,null,null,1260,1260,0,0,0,0,null,null,1260,1260,1260,null,1260,null,null,null,630,0,null,null,630,null,null,null,null,null,0,630,630,630,null,null,null,null,0,0,null,null,0],"source":"local util = {}\nlocal arglist_mt = {}\n\n-- have pack\/unpack both respect the 'n' field\nlocal _unpack = table.unpack or unpack\nlocal unpack = function(t, i, j) return _unpack(t, i or 1, j or t.n or #t) end\nlocal pack = function(...) return { n = select(\"#\", ...), ... } end\nutil.pack = pack\nutil.unpack = unpack\n\n\nfunction util.deepcompare(t1,t2,ignore_mt,cycles,thresh1,thresh2)\n  local ty1 = type(t1)\n  local ty2 = type(t2)\n  -- non-table types can be directly compared\n  if ty1 ~= 'table' or ty2 ~= 'table' then return t1 == t2 end\n  local mt1 = debug.getmetatable(t1)\n  local mt2 = debug.getmetatable(t2)\n  -- would equality be determined by metatable __eq?\n  if mt1 and mt1 == mt2 and mt1.__eq then\n    -- then use that unless asked not to\n    if not ignore_mt then return t1 == t2 end\n  else -- we can skip the deep comparison below if t1 and t2 share identity\n    if rawequal(t1, t2) then return true end\n  end\n\n  -- handle recursive tables\n  cycles = cycles or {{},{}}\n  thresh1, thresh2 = (thresh1 or 1), (thresh2 or 1)\n  cycles[1][t1] = (cycles[1][t1] or 0)\n  cycles[2][t2] = (cycles[2][t2] or 0)\n  if cycles[1][t1] == 1 or cycles[2][t2] == 1 then\n    thresh1 = cycles[1][t1] + 1\n    thresh2 = cycles[2][t2] + 1\n  end\n  if cycles[1][t1] > thresh1 and cycles[2][t2] > thresh2 then\n    return true\n  end\n\n  cycles[1][t1] = cycles[1][t1] + 1\n  cycles[2][t2] = cycles[2][t2] + 1\n\n  for k1,v1 in next, t1 do\n    local v2 = t2[k1]\n    if v2 == nil then\n      return false, {k1}\n    end\n\n    local same, crumbs = util.deepcompare(v1,v2,nil,cycles,thresh1,thresh2)\n    if not same then\n      crumbs = crumbs or {}\n      table.insert(crumbs, k1)\n      return false, crumbs\n    end\n  end\n  for k2,_ in next, t2 do\n    -- only check whether each element has a t1 counterpart, actual comparison\n    -- has been done in first loop above\n    if t1[k2] == nil then return false, {k2} end\n  end\n\n  cycles[1][t1] = cycles[1][t1] - 1\n  cycles[2][t2] = cycles[2][t2] - 1\n\n  return true\nend\n\nfunction util.shallowcopy(t)\n  if type(t) ~= \"table\" then return t end\n  local copy = {}\n  setmetatable(copy, getmetatable(t))\n  for k,v in next, t do\n    copy[k] = v\n  end\n  return copy\nend\n\nfunction util.deepcopy(t, deepmt, cache)\n  local spy = require 'luassert.spy'\n  if type(t) ~= \"table\" then return t end\n  local copy = {}\n\n  -- handle recursive tables\n  local cache = cache or {}\n  if cache[t] then return cache[t] end\n  cache[t] = copy\n\n  for k,v in next, t do\n    copy[k] = (spy.is_spy(v) and v or util.deepcopy(v, deepmt, cache))\n  end\n  if deepmt then\n    debug.setmetatable(copy, util.deepcopy(debug.getmetatable(t), false, cache))\n  else\n    debug.setmetatable(copy, debug.getmetatable(t))\n  end\n  return copy\nend\n\n-----------------------------------------------\n-- Copies arguments as a list of arguments\n-- @param args the arguments of which to copy\n-- @return the copy of the arguments\nfunction util.copyargs(args)\n  local copy = {}\n  setmetatable(copy, getmetatable(args))\n  local match = require 'luassert.match'\n  local spy = require 'luassert.spy'\n  for k,v in pairs(args) do\n    copy[k] = ((match.is_matcher(v) or spy.is_spy(v)) and v or util.deepcopy(v))\n  end\n  return { vals = copy, refs = util.shallowcopy(args) }\nend\n\n-----------------------------------------------\n-- Clear an arguments or return values list from a table\n-- @param arglist the table to clear of arguments or return values and their count\n-- @return No return values\nfunction util.cleararglist(arglist)\n  for idx = arglist.n, 1, -1 do\n    util.tremove(arglist, idx)\n  end\n  arglist.n = nil\nend\n\n-----------------------------------------------\n-- Test specs against an arglist in deepcopy and refs flavours.\n-- @param args deepcopy arglist\n-- @param argsrefs refs arglist\n-- @param specs arguments\/return values to match against args\/argsrefs\n-- @return true if specs match args\/argsrefs, false otherwise\nlocal function matcharg(args, argrefs, specs)\n  local match = require 'luassert.match'\n  for idx, argval in pairs(args) do\n    local spec = specs[idx]\n    if match.is_matcher(spec) then\n      if match.is_ref_matcher(spec) then\n        argval = argrefs[idx]\n      end\n      if not spec(argval) then\n        return false\n      end\n    elseif (spec == nil or not util.deepcompare(argval, spec)) then\n      return false\n    end\n  end\n\n  for idx, spec in pairs(specs) do\n    -- only check whether each element has an args counterpart,\n    -- actual comparison has been done in first loop above\n    local argval = args[idx]\n    if argval == nil then\n      -- no args counterpart, so try to compare using matcher\n      if match.is_matcher(spec) then\n        if not spec(argval) then\n          return false\n        end\n      else\n        return false\n      end\n    end\n  end\n  return true\nend\n\n-----------------------------------------------\n-- Find matching arguments\/return values in a saved list of\n-- arguments\/returned values.\n-- @param invocations_list list of arguments\/returned values to search (list of lists)\n-- @param specs arguments\/return values to match against argslist\n-- @return the last matching arguments\/returned values if a match is found, otherwise nil\nfunction util.matchargs(invocations_list, specs)\n  -- Search the arguments\/returned values last to first to give the\n  -- most helpful answer possible. In the cases where you can place\n  -- your assertions between calls to check this gives you the best\n  -- information if no calls match. In the cases where you can't do\n  -- that there is no good way to predict what would work best.\n  assert(not util.is_arglist(invocations_list), \"expected a list of arglist-object, got an arglist\")\n  for ii = #invocations_list, 1, -1 do\n    local val = invocations_list[ii]\n    if matcharg(val.vals, val.refs, specs) then\n      return val\n    end\n  end\n  return nil\nend\n\n-----------------------------------------------\n-- Find matching oncall for an actual call.\n-- @param oncalls list of oncalls to search\n-- @param args actual call argslist to match against\n-- @return the first matching oncall if a match is found, otherwise nil\nfunction util.matchoncalls(oncalls, args)\n  for _, callspecs in ipairs(oncalls) do\n    -- This lookup is done immediately on *args* passing into the stub\n    -- so pass *args* as both *args* and *argsref* without copying\n    -- either.\n    if matcharg(args, args, callspecs.vals) then\n      return callspecs\n    end\n  end\n  return nil\nend\n\n-----------------------------------------------\n-- table.insert() replacement that respects nil values.\n-- The function will use table field 'n' as indicator of the\n-- table length, if not set, it will be added.\n-- @param t table into which to insert\n-- @param pos (optional) position in table where to insert. NOTE: not optional if you want to insert a nil-value!\n-- @param val value to insert\n-- @return No return values\nfunction util.tinsert(...)\n  -- check optional POS value\n  local args = {...}\n  local c = select('#',...)\n  local t = args[1]\n  local pos = args[2]\n  local val = args[3]\n  if c < 3 then\n    val = pos\n    pos = nil\n  end\n  -- set length indicator n if not present (+1)\n  t.n = (t.n or #t) + 1\n  if not pos then\n    pos = t.n\n  elseif pos > t.n then\n    -- out of our range\n    t[pos] = val\n    t.n = pos\n  end\n  -- shift everything up 1 pos\n  for i = t.n, pos + 1, -1 do\n    t[i]=t[i-1]\n  end\n  -- add element to be inserted\n  t[pos] = val\nend\n-----------------------------------------------\n-- table.remove() replacement that respects nil values.\n-- The function will use table field 'n' as indicator of the\n-- table length, if not set, it will be added.\n-- @param t table from which to remove\n-- @param pos (optional) position in table to remove\n-- @return No return values\nfunction util.tremove(t, pos)\n  -- set length indicator n if not present (+1)\n  t.n = t.n or #t\n  if not pos then\n    pos = t.n\n  elseif pos > t.n then\n    local removed = t[pos]\n    -- out of our range\n    t[pos] = nil\n    return removed\n  end\n  local removed = t[pos]\n  -- shift everything up 1 pos\n  for i = pos, t.n do\n    t[i]=t[i+1]\n  end\n  -- set size, clean last\n  t[t.n] = nil\n  t.n = t.n - 1\n  return removed\nend\n\n-----------------------------------------------\n-- Checks an element to be callable.\n-- The type must either be a function or have a metatable\n-- containing an '__call' function.\n-- @param object element to inspect on being callable or not\n-- @return boolean, true if the object is callable\nfunction util.callable(object)\n  return type(object) == \"function\" or type((debug.getmetatable(object) or {}).__call) == \"function\"\nend\n\n-----------------------------------------------\n-- Checks an element has tostring.\n-- The type must either be a string or have a metatable\n-- containing an '__tostring' function.\n-- @param object element to inspect on having tostring or not\n-- @return boolean, true if the object has tostring\nfunction util.hastostring(object)\n  return type(object) == \"string\" or type((debug.getmetatable(object) or {}).__tostring) == \"function\"\nend\n\n-----------------------------------------------\n-- Find the first level, not defined in the same file as the caller's\n-- code file to properly report an error.\n-- @param level the level to use as the caller's source file\n-- @return number, the level of which to report an error\nfunction util.errorlevel(level)\n  local level = (level or 1) + 1 -- add one to get level of the caller\n  local info = debug.getinfo(level)\n  local source = (info or {}).source\n  local file = source\n  while file and (file == source or source == \"=(tail call)\") do\n    level = level + 1\n    info = debug.getinfo(level)\n    source = (info or {}).source\n  end\n  if level > 1 then level = level - 1 end -- deduct call to errorlevel() itself\n  return level\nend\n\n-----------------------------------------------\n-- Extract modifier and namespace keys from list of tokens.\n-- @param nspace the namespace from which to match tokens\n-- @param tokens list of tokens to search for keys\n-- @return table, list of keys that were extracted\nfunction util.extract_keys(nspace, tokens)\n  local namespace = require 'luassert.namespaces'\n\n  -- find valid keys by coalescing tokens as needed, starting from the end\n  local keys = {}\n  local key = nil\n  local i = #tokens\n  while i > 0 do\n    local token = tokens[i]\n    key = key and (token .. '_' .. key) or token\n\n    -- find longest matching key in the given namespace\n    local longkey = i > 1 and (tokens[i-1] .. '_' .. key) or nil\n    while i > 1 and longkey and namespace[nspace][longkey] do\n      key = longkey\n      i = i - 1\n      token = tokens[i]\n      longkey = (token .. '_' .. key)\n    end\n\n    if namespace.modifier[key] or namespace[nspace][key] then\n      table.insert(keys, 1, key)\n      key = nil\n    end\n    i = i - 1\n  end\n\n  -- if there's anything left we didn't recognize it\n  if key then\n    error(\"luassert: unknown modifier\/\" .. nspace .. \": '\" .. key ..\"'\", util.errorlevel(2))\n  end\n\n  return keys\nend\n\n-----------------------------------------------\n-- store argument list for return values of a function in a table.\n-- The table will get a metatable to identify it as an arglist\nfunction util.make_arglist(...)\n  local arglist = { ... }\n  arglist.n = select('#', ...) -- add values count for trailing nils\n  return setmetatable(arglist, arglist_mt)\nend\n\n-----------------------------------------------\n-- check a table to be an arglist type.\nfunction util.is_arglist(object)\n  return getmetatable(object) == arglist_mt\nend\n\nreturn util"},{"name":"\/Users\/nascarsayan\/Code\/github.com\/nascarsayan\/sqids-lua\/lua_modules\/share\/lua\/5.4\/mediator.lua","coverage":[null,114,null,null,null,114,114,114,114,null,0,0,0,null,null,null,114,114,null,null,null,null,null,63,63,63,63,63,63,null,null,114,114,null,114,null,114,69,69,null,66,null,null,114,null,114,null,null,null,0,0,0,null,null,0,0,0,null,0,null,null,null,0,null,0,0,0,null,null,null,null,63,63,null,null,null,0,null,null,null,870,null,null,null,0,null,0,0,0,null,null,0,null,null,null,null,1608,936,null,null,936,null,936,null,936,936,null,null,null,672,447,null,225,null,null,63,null,null,null,null,0,null,null,0,null,null,null,0,null,null,null,447,null,1317,870,null,null,447,null,null,null,114,null,null,null,0,null,null,null,0,null,null,null,333,null,null,null,null,0],"source":"local function getUniqueId(obj)\n  return tonumber(tostring(obj):match(':%s*[0xX]*(%x+)'), 16)\nend\n\nlocal function Subscriber(fn, options)\n  local sub = {\n    options = options or {},\n    fn = fn,\n    channel = nil,\n    update = function(self, options)\n      if options then\n        self.fn = options.fn or self.fn\n        self.options = options.options or self.options\n      end\n    end\n  }\n  sub.id = getUniqueId(sub)\n  return sub\nend\n\n-- Channel class and functions --\n\nlocal function Channel(namespace, parent)\n  return {\n    stopped = false,\n    namespace = namespace,\n    callbacks = {},\n    channels = {},\n    parent = parent,\n\n    addSubscriber = function(self, fn, options)\n      local callback = Subscriber(fn, options)\n      local priority = (#self.callbacks + 1)\n\n      options = options or {}\n\n      if options.priority and\n        options.priority >= 0 and\n        options.priority < priority\n      then\n          priority = options.priority\n      end\n\n      table.insert(self.callbacks, priority, callback)\n\n      return callback\n    end,\n\n    getSubscriber = function(self, id)\n      for i=1, #self.callbacks do\n        local callback = self.callbacks[i]\n        if callback.id == id then return { index = i, value = callback } end\n      end\n      local sub\n      for _, channel in pairs(self.channels) do\n        sub = channel:getSubscriber(id)\n        if sub then break end\n      end\n      return sub\n    end,\n\n    setPriority = function(self, id, priority)\n      local callback = self:getSubscriber(id)\n\n      if callback.value then\n        table.remove(self.callbacks, callback.index)\n        table.insert(self.callbacks, priority, callback.value)\n      end\n    end,\n\n    addChannel = function(self, namespace)\n      self.channels[namespace] = Channel(namespace, self)\n      return self.channels[namespace]\n    end,\n\n    hasChannel = function(self, namespace)\n      return namespace and self.channels[namespace] and true\n    end,\n\n    getChannel = function(self, namespace)\n      return self.channels[namespace] or self:addChannel(namespace)\n    end,\n\n    removeSubscriber = function(self, id)\n      local callback = self:getSubscriber(id)\n\n      if callback and callback.value then\n        for _, channel in pairs(self.channels) do\n          channel:removeSubscriber(id)\n        end\n\n        return table.remove(self.callbacks, callback.index)\n      end\n    end,\n\n    publish = function(self, result, ...)\n      for i = 1, #self.callbacks do\n        local callback = self.callbacks[i]\n\n        -- if it doesn't have a predicate, or it does and it's true then run it\n        if not callback.options.predicate or callback.options.predicate(...) then\n           -- just take the first result and insert it into the result table\n          local value, continue = callback.fn(...)\n\n          if value then table.insert(result, value) end\n          if not continue then return result end\n        end\n      end\n\n      if parent then\n        return parent:publish(result, ...)\n      else\n        return result\n      end\n    end\n  }\nend\n\n-- Mediator class and functions --\n\nlocal Mediator = setmetatable(\n{\n  Channel = Channel,\n  Subscriber = Subscriber\n},\n{\n  __call = function (fn, options)\n    return {\n      channel = Channel('root'),\n\n      getChannel = function(self, channelNamespace)\n        local channel = self.channel\n\n        for i=1, #channelNamespace do\n          channel = channel:getChannel(channelNamespace[i])\n        end\n\n        return channel\n      end,\n\n      subscribe = function(self, channelNamespace, fn, options)\n        return self:getChannel(channelNamespace):addSubscriber(fn, options)\n      end,\n\n      getSubscriber = function(self, id, channelNamespace)\n        return self:getChannel(channelNamespace):getSubscriber(id)\n      end,\n\n      removeSubscriber = function(self, id, channelNamespace)\n        return self:getChannel(channelNamespace):removeSubscriber(id)\n      end,\n\n      publish = function(self, channelNamespace, ...)\n        return self:getChannel(channelNamespace):publish({}, ...)\n      end\n    }\n  end\n})\nreturn Mediator"},{"name":"\/Users\/nascarsayan\/Code\/github.com\/nascarsayan\/sqids-lua\/lua_modules\/share\/lua\/5.4\/pl\/List.lua","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,3,3,3,3,3,3,3,null,3,3,null,null,3,3,null,null,null,3,null,null,null,0,0,0,null,0,null,null,null,0,null,null,3,0,null,null,3,0,0,0,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,3,null,null,null,null,3,0,0,0,null,null,null,null,null,3,0,0,null,null,3,null,null,null,null,null,3,0,0,0,null,null,null,null,null,null,null,3,0,0,0,null,null,null,null,null,3,0,null,null,null,null,null,null,3,0,0,0,null,null,null,null,null,null,null,null,3,0,0,null,0,null,null,null,null,null,null,null,3,0,0,0,null,null,3,null,null,null,null,null,null,null,null,3,3,null,null,null,null,3,0,null,null,null,null,null,3,0,0,0,null,0,null,null,null,null,null,3,0,0,0,null,null,null,null,null,3,0,null,null,null,null,3,0,0,0,0,0,null,0,null,null,null,null,null,3,0,0,0,0,0,null,0,null,null,null,null,null,null,null,null,null,3,0,null,null,null,null,3,0,0,null,null,3,null,null,null,null,null,null,null,null,null,null,null,3,0,0,0,null,0,0,0,null,0,null,0,0,0,0,0,null,null,null,3,0,null,null,null,null,null,null,null,null,null,3,0,null,null,null,null,null,null,null,null,3,0,0,0,0,0,0,null,0,null,null,null,null,null,null,null,3,0,0,0,0,0,0,null,null,null,null,null,null,3,0,0,0,0,null,null,null,null,null,null,3,0,0,0,null,0,null,null,null,null,null,null,3,0,0,0,null,null,null,null,null,null,null,3,null,null,0,0,0,null,0,null,null,null,null,null,3,0,null,null,null,null,null,3,0,0,0,null,null,null,null,0,0,0,null,null,null,null,null,3,0,0,0,0,null,null,null,null,null,null,null,3,0,null,null,null,null,null,null,null,3,0,0,null,null,null,null,null,null,null,null,null,3,0,null,null,null,null,null,null,null,3,0,0,null,null,null,null,null,null,null,null,null,3,0,null,null,null,null,null,null,null,null,3,0,0,0,0,0,null,0,null,null,null,null,0,null,null,null,3,null,null,0,0,0,null,0,null,0,0,null,null,null,3,null,null,null,null,null,3,0,null,null,null,null,null,null,null,null,null,3,0,0,0,0,0,0,0,0,null,0,null,null,null,3,0,null,null,null,null,null,null,null,null,3,0,0,0,0,null,0,0,null,0,null,null,0,0,0,null,0,0,null,0,null,null,0,0,0,0,null,null,3,null,3,null],"source":"--- Python-style list class.\n--\n-- **Please Note**: methods that change the list will return the list.\n-- This is to allow for method chaining, but please note that `ls = ls:sort()`\n-- does not mean that a new copy of the list is made. In-place (mutable) methods\n-- are marked as returning 'the list' in this documentation.\n--\n-- See the Guide for further @{02-arrays.md.Python_style_Lists|discussion}\n--\n-- See <a href=\"http:\/\/www.python.org\/doc\/current\/tut\/tut.html\">http:\/\/www.python.org\/doc\/current\/tut\/tut.html<\/a>, section 5.1\n--\n-- **Note**: The comments before some of the functions are from the Python docs\n-- and contain Python code.\n--\n-- Written for Lua version Nick Trout 4.0; Redone for Lua 5.1, Steve Donovan.\n--\n-- Dependencies: `pl.utils`, `pl.tablex`, `pl.class`\n-- @classmod pl.List\n-- @pragma nostrip\n\nlocal tinsert,tremove,concat,tsort = table.insert,table.remove,table.concat,table.sort\nlocal setmetatable, getmetatable,type,tostring,string = setmetatable,getmetatable,type,tostring,string\nlocal tablex = require 'pl.tablex'\nlocal filter,imap,imap2,reduce,transform,tremovevalues = tablex.filter,tablex.imap,tablex.imap2,tablex.reduce,tablex.transform,tablex.removevalues\nlocal tsub = tablex.sub\nlocal utils = require 'pl.utils'\nlocal class = require 'pl.class'\n\nlocal array_tostring,split,assert_arg,function_arg = utils.array_tostring,utils.split,utils.assert_arg,utils.function_arg\nlocal normalize_slice = tablex._normalize_slice\n\n-- metatable for our list and map objects has already been defined..\nlocal Multimap = utils.stdmt.MultiMap\nlocal List = utils.stdmt.List\n\nlocal iter\n\nclass(nil,nil,List)\n\n-- we want the result to be _covariant_, i.e. t must have type of obj if possible\nlocal function makelist (t,obj)\n    local klass = List\n    if obj then\n        klass = getmetatable(obj)\n    end\n    return setmetatable(t,klass)\nend\n\nlocal function simple_table(t)\n    return type(t) == 'table' and not getmetatable(t) and #t > 0\nend\n\nfunction List._create (src)\n    if simple_table(src) then return src end\nend\n\nfunction List:_init (src)\n    if self == src then return end -- existing table used as self!\n    if src then\n        for v in iter(src) do\n            tinsert(self,v)\n        end\n    end\nend\n\n--- Create a new list. Can optionally pass a table;\n-- passing another instance of List will cause a copy to be created;\n-- this will return a plain table with an appropriate metatable.\n-- we pass anything which isn't a simple table to iterate() to work out\n-- an appropriate iterator\n-- @see List.iterate\n-- @param[opt] t An optional list-like table\n-- @return a new List\n-- @usage ls = List();  ls = List {1,2,3,4}\n-- @function List.new\n\nList.new = List\n\n--- Make a copy of an existing list.\n-- The difference from a plain 'copy constructor' is that this returns\n-- the actual List subtype.\nfunction List:clone()\n    local ls = makelist({},self)\n    ls:extend(self)\n    return ls\nend\n\n--- Add an item to the end of the list.\n-- @param i An item\n-- @return the list\nfunction List:append(i)\n    tinsert(self,i)\n    return self\nend\n\nList.push = tinsert\n\n--- Extend the list by appending all the items in the given list.\n-- equivalent to 'a[len(a):] = L'.\n-- @tparam List L Another List\n-- @return the list\nfunction List:extend(L)\n    assert_arg(1,L,'table')\n    for i = 1,#L do tinsert(self,L[i]) end\n    return self\nend\n\n--- Insert an item at a given position. i is the index of the\n-- element before which to insert.\n-- @int i index of element before whichh to insert\n-- @param x A data item\n-- @return the list\nfunction List:insert(i, x)\n    assert_arg(1,i,'number')\n    tinsert(self,i,x)\n    return self\nend\n\n--- Insert an item at the begining of the list.\n-- @param x a data item\n-- @return the list\nfunction List:put (x)\n    return self:insert(1,x)\nend\n\n--- Remove an element given its index.\n-- (equivalent of Python's del s[i])\n-- @int i the index\n-- @return the list\nfunction List:remove (i)\n    assert_arg(1,i,'number')\n    tremove(self,i)\n    return self\nend\n\n--- Remove the first item from the list whose value is given.\n-- (This is called 'remove' in Python; renamed to avoid confusion\n-- with table.remove)\n-- Return nil if there is no such item.\n-- @param x A data value\n-- @return the list\nfunction List:remove_value(x)\n    for i=1,#self do\n        if self[i]==x then tremove(self,i) return self end\n    end\n    return self\n end\n\n--- Remove the item at the given position in the list, and return it.\n-- If no index is specified, a:pop() returns the last item in the list.\n-- The item is also removed from the list.\n-- @int[opt] i An index\n-- @return the item\nfunction List:pop(i)\n    if not i then i = #self end\n    assert_arg(1,i,'number')\n    return tremove(self,i)\nend\n\nList.get = List.pop\n\n--- Return the index in the list of the first item whose value is given.\n-- Return nil if there is no such item.\n-- @function List:index\n-- @param x A data value\n-- @int[opt=1] idx where to start search\n-- @return the index, or nil if not found.\n\nlocal tfind = tablex.find\nList.index = tfind\n\n--- Does this list contain the value?\n-- @param x A data value\n-- @return true or false\nfunction List:contains(x)\n    return tfind(self,x) and true or false\nend\n\n--- Return the number of times value appears in the list.\n-- @param x A data value\n-- @return number of times x appears\nfunction List:count(x)\n    local cnt=0\n    for i=1,#self do\n        if self[i]==x then cnt=cnt+1 end\n    end\n    return cnt\nend\n\n--- Sort the items of the list, in place.\n-- @func[opt='<'] cmp an optional comparison function\n-- @return the list\nfunction List:sort(cmp)\n    if cmp then cmp = function_arg(1,cmp) end\n    tsort(self,cmp)\n    return self\nend\n\n--- Return a sorted copy of this list.\n-- @func[opt='<'] cmp an optional comparison function\n-- @return a new list\nfunction List:sorted(cmp)\n    return List(self):sort(cmp)\nend\n\n--- Reverse the elements of the list, in place.\n-- @return the list\nfunction List:reverse()\n    local t = self\n    local n = #t\n    for i = 1,n\/2 do\n        t[i],t[n] = t[n],t[i]\n        n = n - 1\n    end\n    return self\nend\n\n--- Return the minimum and the maximum value of the list.\n-- @return minimum value\n-- @return maximum value\nfunction List:minmax()\n    local vmin,vmax = 1e70,-1e70\n    for i = 1,#self do\n        local v = self[i]\n        if v < vmin then vmin = v end\n        if v > vmax then vmax = v end\n    end\n    return vmin,vmax\nend\n\n--- Emulate list slicing.  like  'list[first:last]' in Python.\n-- If first or last are negative then they are relative to the end of the list\n-- eg. slice(-2) gives last 2 entries in a list, and\n-- slice(-4,-2) gives from -4th to -2nd\n-- @param first An index\n-- @param last An index\n-- @return a new List\nfunction List:slice(first,last)\n    return tsub(self,first,last)\nend\n\n--- Empty the list.\n-- @return the list\nfunction List:clear()\n    for i=1,#self do tremove(self) end\n    return self\nend\n\nlocal eps = 1.0e-10\n\n--- Emulate Python's range(x) function.\n-- Include it in List table for tidiness\n-- @int start A number\n-- @int[opt] finish A number greater than start; if absent,\n-- then start is 1 and finish is start\n-- @int[opt=1] incr an increment (may be less than 1)\n-- @return a List from start .. finish\n-- @usage List.range(0,3) == List{0,1,2,3}\n-- @usage List.range(4) = List{1,2,3,4}\n-- @usage List.range(5,1,-1) == List{5,4,3,2,1}\nfunction List.range(start,finish,incr)\n    if not finish then\n        finish = start\n        start = 1\n    end\n    if incr then\n    assert_arg(3,incr,'number')\n    if math.ceil(incr) ~= incr then finish = finish + eps end\n    else\n        incr = 1\n    end\n    assert_arg(1,start,'number')\n    assert_arg(2,finish,'number')\n    local t = List()\n    for i=start,finish,incr do tinsert(t,i) end\n    return t\nend\n\n--- list:len() is the same as #list.\nfunction List:len()\n    return #self\nend\n\n-- Extended operations --\n\n--- Remove a subrange of elements.\n-- equivalent to 'del s[i1:i2]' in Python.\n-- @int i1 start of range\n-- @int i2 end of range\n-- @return the list\nfunction List:chop(i1,i2)\n    return tremovevalues(self,i1,i2)\nend\n\n--- Insert a sublist into a list\n-- equivalent to 's[idx:idx] = list' in Python\n-- @int idx index\n-- @tparam List list list to insert\n-- @return the list\n-- @usage  l = List{10,20}; l:splice(2,{21,22});  assert(l == List{10,21,22,20})\nfunction List:splice(idx,list)\n    assert_arg(1,idx,'number')\n    idx = idx - 1\n    local i = 1\n    for v in iter(list) do\n        tinsert(self,i+idx,v)\n        i = i + 1\n    end\n    return self\nend\n\n--- General slice assignment s[i1:i2] = seq.\n-- @int i1  start index\n-- @int i2  end index\n-- @tparam List seq a list\n-- @return the list\nfunction List:slice_assign(i1,i2,seq)\n    assert_arg(1,i1,'number')\n    assert_arg(1,i2,'number')\n    i1,i2 = normalize_slice(self,i1,i2)\n    if i2 >= i1 then self:chop(i1,i2) end\n    self:splice(i1,seq)\n    return self\nend\n\n--- Concatenation operator.\n-- @within metamethods\n-- @tparam List L another List\n-- @return a new list consisting of the list with the elements of the new list appended\nfunction List:__concat(L)\n    assert_arg(1,L,'table')\n    local ls = self:clone()\n    ls:extend(L)\n    return ls\nend\n\n--- Equality operator ==.  True iff all elements of two lists are equal.\n-- @within metamethods\n-- @tparam List L another List\n-- @return true or false\nfunction List:__eq(L)\n    if #self ~= #L then return false end\n    for i = 1,#self do\n        if self[i] ~= L[i] then return false end\n    end\n    return true\nend\n\n--- Join the elements of a list using a delimiter.\n-- This method uses tostring on all elements.\n-- @string[opt=''] delim a delimiter string, can be empty.\n-- @return a string\nfunction List:join (delim)\n    delim = delim or ''\n    assert_arg(1,delim,'string')\n    return concat(array_tostring(self),delim)\nend\n\n--- Join a list of strings. <br>\n-- Uses `table.concat` directly.\n-- @function List:concat\n-- @string[opt=''] delim a delimiter\n-- @return a string\nList.concat = concat\n\nlocal function tostring_q(val)\n    local s = tostring(val)\n    if type(val) == 'string' then\n        s = '\"'..s..'\"'\n    end\n    return s\nend\n\n--- How our list should be rendered as a string. Uses join().\n-- @within metamethods\n-- @see List:join\nfunction List:__tostring()\n    return '{'..self:join(',',tostring_q)..'}'\nend\n\n--- Call the function on each element of the list.\n-- @func fun a function or callable object\n-- @param ... optional values to pass to function\nfunction List:foreach (fun,...)\n    fun = function_arg(1,fun)\n    for i = 1,#self do\n        fun(self[i],...)\n    end\nend\n\nlocal function lookup_fun (obj,name)\n    local f = obj[name]\n    if not f then error(type(obj)..\" does not have method \"..name,3) end\n    return f\nend\n\n--- Call the named method on each element of the list.\n-- @string name the method name\n-- @param ... optional values to pass to function\nfunction List:foreachm (name,...)\n    for i = 1,#self do\n        local obj = self[i]\n        local f = lookup_fun(obj,name)\n        f(obj,...)\n    end\nend\n\n--- Create a list of all elements which match a function.\n-- @func fun a boolean function\n-- @param[opt] arg optional argument to be passed as second argument of the predicate\n-- @return a new filtered list.\nfunction List:filter (fun,arg)\n    return makelist(filter(self,fun,arg),self)\nend\n\n--- Split a string using a delimiter.\n-- @string s the string\n-- @string[opt] delim the delimiter (default spaces)\n-- @return a List of strings\n-- @see pl.utils.split\nfunction List.split (s,delim)\n    assert_arg(1,s,'string')\n    return makelist(split(s,delim))\nend\n\n--- Apply a function to all elements.\n-- Any extra arguments will be passed to the function.\n-- @func fun a function of at least one argument\n-- @param ... arbitrary extra arguments.\n-- @return a new list: {f(x) for x in self}\n-- @usage List{'one','two'}:map(string.upper) == {'ONE','TWO'}\n-- @see pl.tablex.imap\nfunction List:map (fun,...)\n    return makelist(imap(fun,self,...),self)\nend\n\n--- Apply a function to all elements, in-place.\n-- Any extra arguments are passed to the function.\n-- @func fun A function that takes at least one argument\n-- @param ... arbitrary extra arguments.\n-- @return the list.\nfunction List:transform (fun,...)\n    transform(fun,self,...)\n    return self\nend\n\n--- Apply a function to elements of two lists.\n-- Any extra arguments will be passed to the function\n-- @func fun a function of at least two arguments\n-- @tparam List ls another list\n-- @param ... arbitrary extra arguments.\n-- @return a new list: {f(x,y) for x in self, for x in arg1}\n-- @see pl.tablex.imap2\nfunction List:map2 (fun,ls,...)\n    return makelist(imap2(fun,self,ls,...),self)\nend\n\n--- apply a named method to all elements.\n-- Any extra arguments will be passed to the method.\n-- @string name name of method\n-- @param ... extra arguments\n-- @return a new list of the results\n-- @see pl.seq.mapmethod\nfunction List:mapm (name,...)\n    local res = {}\n    for i = 1,#self do\n      local val = self[i]\n      local fn = lookup_fun(val,name)\n      res[i] = fn(val,...)\n    end\n    return makelist(res,self)\nend\n\nlocal function composite_call (method,f)\n    return function(self,...)\n        return self[method](self,f,...)\n    end\nend\n\nfunction List.default_map_with(T)\n    return function(self,name)\n        local m\n        if T then\n            local f = lookup_fun(T,name)\n            m = composite_call('map',f)\n        else\n            m = composite_call('mapn',name)\n        end\n        getmetatable(self)[name] = m -- and cache..\n        return m\n    end\nend\n\nList.default_map = List.default_map_with\n\n--- 'reduce' a list using a binary function.\n-- @func fun a function of two arguments\n-- @return result of the function\n-- @see pl.tablex.reduce\nfunction List:reduce (fun)\n    return reduce(fun,self)\nend\n\n--- Partition a list using a classifier function.\n-- The function may return nil, but this will be converted to the string key '<nil>'.\n-- @func fun a function of at least one argument\n-- @param ... will also be passed to the function\n-- @treturn MultiMap a table where the keys are the returned values, and the values are Lists\n-- of values where the function returned that key.\n-- @see pl.MultiMap\nfunction List:partition (fun,...)\n    fun = function_arg(1,fun)\n    local res = {}\n    for i = 1,#self do\n        local val = self[i]\n        local klass = fun(val,...)\n        if klass == nil then klass = '<nil>' end\n        if not res[klass] then res[klass] = List() end\n        res[klass]:append(val)\n    end\n    return setmetatable(res,Multimap)\nend\n\n--- return an iterator over all values.\nfunction List:iter ()\n    return iter(self)\nend\n\n--- Create an iterator over a seqence.\n-- This captures the Python concept of 'sequence'.\n-- For tables, iterates over all values with integer indices.\n-- @param seq a sequence; a string (over characters), a table, a file object (over lines) or an iterator function\n-- @usage for x in iterate {1,10,22,55} do io.write(x,',') end ==> 1,10,22,55\n-- @usage for ch in iterate 'help' do do io.write(ch,' ') end ==> h e l p\nfunction List.iterate(seq)\n    if type(seq) == 'string' then\n        local idx = 0\n        local n = #seq\n        local sub = string.sub\n        return function ()\n            idx = idx + 1\n            if idx > n then return nil\n            else\n                return sub(seq,idx,idx)\n            end\n        end\n    elseif type(seq) == 'table' then\n        local idx = 0\n        local n = #seq\n        return function()\n            idx = idx + 1\n            if idx > n then return nil\n            else\n                return seq[idx]\n            end\n        end\n    elseif type(seq) == 'function' then\n        return seq\n    elseif type(seq) == 'userdata' and io.type(seq) == 'file' then\n        return seq:lines()\n    end\nend\niter = List.iterate\n\nreturn List\n"},{"name":"\/Users\/nascarsayan\/Code\/github.com\/nascarsayan\/sqids-lua\/lua_modules\/share\/lua\/5.4\/pl\/class.lua","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,0,0,null,0,0,0,0,null,0,0,0,null,null,null,null,0,null,null,0,0,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,0,0,0,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,0,null,null,null,null,0,0,0,0,0,0,0,null,null,null,0,0,0,null,null,null,null,null,null,null,3,null,3,3,0,0,null,3,null,null,3,null,null,0,0,null,0,3,0,null,null,3,3,3,3,3,null,null,3,0,null,null,null,null,null,0,0,0,null,0,0,0,0,0,null,null,null,0,0,null,null,0,null,null,null,0,null,0,null,0,0,null,3,3,3,3,null,3,3,null,null,3,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,3,null,null,0,0,0,null,0,0,null,0,0,0,0,null,null,null,null,0,null,0,null,null,0,0,null,0,0,0,null,null,0,null,null,null,0,0,0,0,null,0,null,null,null,null,null,0,null],"source":"--- Provides a reuseable and convenient framework for creating classes in Lua.\n-- Two possible notations:\n--\n--    B = class(A)\n--    class.B(A)\n--\n-- The latter form creates a named class within the current environment. Note\n-- that this implicitly brings in `pl.utils` as a dependency.\n--\n-- See the Guide for further @{01-introduction.md.Simplifying_Object_Oriented_Programming_in_Lua|discussion}\n-- @module pl.class\n\nlocal error, getmetatable, io, pairs, rawget, rawset, setmetatable, tostring, type =\n    _G.error, _G.getmetatable, _G.io, _G.pairs, _G.rawget, _G.rawset, _G.setmetatable, _G.tostring, _G.type\nlocal compat\n\n-- this trickery is necessary to prevent the inheritance of 'super' and\n-- the resulting recursive call problems.\nlocal function call_ctor (c,obj,...)\n    local init = rawget(c,'_init')\n    local parent_with_init = rawget(c,'_parent_with_init')\n\n    if parent_with_init then\n        if not init then -- inheriting an init\n            init = rawget(parent_with_init, '_init')\n            parent_with_init = rawget(parent_with_init, '_parent_with_init')\n        end\n        if parent_with_init then -- super() points to one above whereever _init came from\n            rawset(obj,'super',function(obj,...)\n                call_ctor(parent_with_init,obj,...)\n            end)\n        end\n    else\n        -- Without this, calling super() where none exists will sometimes loop and stack overflow\n        rawset(obj,'super',nil)\n    end\n\n    local res = init(obj,...)\n    if parent_with_init then -- If this execution of call_ctor set a super, unset it\n        rawset(obj,'super',nil)\n    end\n\n    return res\nend\n\n--- initializes an __instance__ upon creation.\n-- @function class:_init\n-- @param ... parameters passed to the constructor\n-- @usage local Cat = class()\n-- function Cat:_init(name)\n--   --self:super(name)   -- call the ancestor initializer if needed\n--   self.name = name\n-- end\n--\n-- local pussycat = Cat(\"pussycat\")\n-- print(pussycat.name)  --> pussycat\n\n--- checks whether an __instance__ is derived from some class.\n-- Works the other way around as `class_of`. It has two ways of using;\n-- 1) call with a class to check against, 2) call without params.\n-- @function instance:is_a\n-- @param some_class class to check against, or `nil` to return the class\n-- @return `true` if `instance` is derived from `some_class`, or if `some_class == nil` then\n-- it returns the class table of the instance\n-- @usage local pussycat = Lion()  -- assuming Lion derives from Cat\n-- if pussycat:is_a(Cat) then\n--   -- it's true, it is a Lion, but also a Cat\n-- end\n--\n-- if pussycat:is_a() == Lion then\n--   -- It's true\n-- end\nlocal function is_a(self,klass)\n    if klass == nil then\n        -- no class provided, so return the class this instance is derived from\n        return getmetatable(self)\n    end\n    local m = getmetatable(self)\n    if not m then return false end --*can't be an object!\n    while m do\n        if m == klass then return true end\n        m = rawget(m,'_base')\n    end\n    return false\nend\n\n--- checks whether an __instance__ is derived from some class.\n-- Works the other way around as `is_a`.\n-- @function some_class:class_of\n-- @param some_instance instance to check against\n-- @return `true` if `some_instance` is derived from `some_class`\n-- @usage local pussycat = Lion()  -- assuming Lion derives from Cat\n-- if Cat:class_of(pussycat) then\n--   -- it's true\n-- end\nlocal function class_of(klass,obj)\n    if type(klass) ~= 'table' or not rawget(klass,'is_a') then return false end\n    return klass.is_a(obj,klass)\nend\n\n--- cast an object to another class.\n-- It is not clever (or safe!) so use carefully.\n-- @param some_instance the object to be changed\n-- @function some_class:cast\nlocal function cast (klass, obj)\n    return setmetatable(obj,klass)\nend\n\n\nlocal function _class_tostring (obj)\n    local mt = obj._class\n    local name = rawget(mt,'_name')\n    setmetatable(obj,nil)\n    local str = tostring(obj)\n    setmetatable(obj,mt)\n    if name then str = name ..str:gsub('table','') end\n    return str\nend\n\nlocal function tupdate(td,ts,dont_override)\n    for k,v in pairs(ts) do\n        if not dont_override or td[k] == nil then\n            td[k] = v\n        end\n    end\nend\n\nlocal function _class(base,c_arg,c)\n    -- the class `c` will be the metatable for all its objects,\n    -- and they will look up their methods in it.\n    local mt = {}   -- a metatable for the class to support __call and _handler\n    -- can define class by passing it a plain table of methods\n    local plain = type(base) == 'table' and not getmetatable(base)\n    if plain then\n        c = base\n        base = c._base\n    else\n        c = c or {}\n    end\n\n    if type(base) == 'table' then\n        -- our new class is a shallow copy of the base class!\n        -- but be careful not to wipe out any methods we have been given at this point!\n        tupdate(c,base,plain)\n        c._base = base\n        -- inherit the 'not found' handler, if present\n        if rawget(c,'_handler') then mt.__index = c._handler end\n    elseif base ~= nil then\n        error(\"must derive from a table type\",3)\n    end\n\n    c.__index = c\n    setmetatable(c,mt)\n    if not plain then\n        if base and rawget(base,'_init') then c._parent_with_init = base end -- For super and inherited init\n        c._init = nil\n    end\n\n    if base and rawget(base,'_class_init') then\n        base._class_init(c,c_arg)\n    end\n\n    -- expose a ctor which can be called by <classname>(<args>)\n    mt.__call = function(class_tbl,...)\n        local obj\n        if rawget(c,'_create') then obj = c._create(...) end\n        if not obj then obj = {} end\n        setmetatable(obj,c)\n\n        if rawget(c,'_init') or rawget(c,'_parent_with_init') then -- constructor exists\n            local res = call_ctor(c,obj,...)\n            if res then -- _if_ a ctor returns a value, it becomes the object...\n                obj = res\n                setmetatable(obj,c)\n            end\n        end\n\n        if base and rawget(base,'_post_init') then\n            base._post_init(obj)\n        end\n\n        return obj\n    end\n    -- Call Class.catch to set a handler for methods\/properties not found in the class!\n    c.catch = function(self, handler)\n        if type(self) == \"function\" then\n            -- called using . instead of :\n            handler = self\n        end\n        c._handler = handler\n        mt.__index = handler\n    end\n    c.is_a = is_a\n    c.class_of = class_of\n    c.cast = cast\n    c._class = c\n\n    if not rawget(c,'__tostring') then\n        c.__tostring = _class_tostring\n    end\n\n    return c\nend\n\n--- create a new class, derived from a given base class.\n-- Supporting two class creation syntaxes:\n-- either `Name = class(base)` or `class.Name(base)`.\n-- The first form returns the class directly and does not set its `_name`.\n-- The second form creates a variable `Name` in the current environment set\n-- to the class, and also sets `_name`.\n-- @function class\n-- @param base optional base class\n-- @param c_arg optional parameter to class constructor\n-- @param c optional table to be used as class\nlocal class\nclass = setmetatable({},{\n    __call = function(fun,...)\n        return _class(...)\n    end,\n    __index = function(tbl,key)\n        if key == 'class' then\n            io.stderr:write('require(\"pl.class\").class is deprecated. Use require(\"pl.class\")\\n')\n            return class\n        end\n        compat = compat or require 'pl.compat'\n        local env = compat.getfenv(2)\n        return function(...)\n            local c = _class(...)\n            c._name = key\n            rawset(env,key,c)\n            return c\n        end\n    end\n})\n\nclass.properties = class()\n\nfunction class.properties._class_init(klass)\n    klass.__index = function(t,key)\n        -- normal class lookup!\n        local v = klass[key]\n        if v then return v end\n        -- is it a getter?\n        v = rawget(klass,'get_'..key)\n        if v then\n            return v(t)\n        end\n        -- is it a field?\n        return rawget(t,'_'..key)\n    end\n    klass.__newindex = function (t,key,value)\n        -- if there's a setter, use that, otherwise directly set table\n        local p = 'set_'..key\n        local setter = klass[p]\n        if setter then\n            setter(t,value)\n        else\n            rawset(t,key,value)\n        end\n    end\nend\n\n\nreturn class\n"},{"name":"\/Users\/nascarsayan\/Code\/github.com\/nascarsayan\/sqids-lua\/lua_modules\/share\/lua\/5.4\/pl\/dir.lua","coverage":[null,null,null,null,null,null,null,3,3,3,3,3,3,3,3,3,3,3,null,3,3,null,3,null,null,3,null,null,null,3,null,null,null,12,12,null,null,null,null,null,null,null,null,null,null,null,3,0,0,0,null,null,null,null,null,null,null,3,0,0,0,0,0,0,null,0,null,null,null,0,0,0,0,0,0,0,0,null,null,null,0,null,null,null,null,null,null,null,3,0,0,0,null,0,0,null,0,null,null,0,null,null,null,null,null,null,3,0,0,0,null,null,null,null,null,0,0,0,0,0,0,0,0,null,0,0,null,null,null,null,0,0,null,0,0,0,0,null,0,0,0,null,null,0,null,0,null,0,0,0,0,0,0,0,0,0,null,null,null,0,0,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,0,0,null,0,null,0,null,null,0,0,0,0,null,0,0,0,0,null,0,null,0,0,null,null,0,0,0,0,0,0,null,0,0,null,null,null,0,0,null,null,null,null,null,null,null,null,null,3,0,0,0,0,null,null,null,null,null,null,null,3,0,0,0,null,null,null,0,0,0,0,0,0,0,0,null,0,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,3,0,null,0,0,null,0,null,null,0,0,null,0,0,0,0,0,null,0,0,null,0,null,null,0,0,null,null,null,0,null,null,null,null,null,null,null,null,3,0,0,0,0,null,0,null,null,0,0,null,0,0,null,null,0,0,0,null,0,0,null,null,0,null,null,null,null,null,3,0,null,3,null,null,null,3,null,0,0,null,0,0,0,0,0,null,0,null,0,null,null,null,null,null,null,null,null,3,0,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,3,0,0,0,0,0,0,0,0,0,null,0,0,0,0,null,0,0,0,0,null,0,0,0,0,0,0,0,null,0,0,0,0,0,0,0,0,null,null,null,null,0,null,null,null,null,null,null,null,null,24,24,3,null,null,21,21,21,3,3,null,null,18,12,12,12,12,0,null,12,null,null,null,6,null,null,null,null,null,null,null,3,3,null,3,3,0,null,null,3,null,3,null,null,null,null,null,null,null,null,null,3,3,3,3,null,3,3,15,12,12,12,12,null,null,null,null,3,null,null,3],"source":"--- Listing files in directories and creating\/removing directory paths.\n--\n-- Dependencies: `pl.utils`, `pl.path`\n--\n-- Soft Dependencies: `alien`, `ffi` (either are used on Windows for copying\/moving files)\n-- @module pl.dir\n\nlocal utils = require 'pl.utils'\nlocal path = require 'pl.path'\nlocal is_windows = path.is_windows\nlocal ldir = path.dir\nlocal mkdir = path.mkdir\nlocal rmdir = path.rmdir\nlocal sub = string.sub\nlocal os,pcall,ipairs,pairs,require,setmetatable = os,pcall,ipairs,pairs,require,setmetatable\nlocal remove = os.remove\nlocal append = table.insert\nlocal assert_arg,assert_string,raise = utils.assert_arg,utils.assert_string,utils.raise\n\nlocal exists, isdir = path.exists, path.isdir\nlocal sep = path.sep\n\nlocal dir = {}\n\nlocal function makelist(l)\n    return setmetatable(l, require('pl.List'))\nend\n\nlocal function assert_dir (n,val)\n    assert_arg(n,val,'string',path.isdir,'not a directory',4)\nend\n\nlocal function filemask(mask)\n    mask = utils.escape(path.normcase(mask))\n    return '^'..mask:gsub('%%%*','.*'):gsub('%%%?','.')..'$'\nend\n\n--- Test whether a file name matches a shell pattern.\n-- Both parameters are case-normalized if operating system is\n-- case-insensitive.\n-- @string filename A file name.\n-- @string pattern A shell pattern. The only special characters are\n-- `'*'` and `'?'`: `'*'` matches any sequence of characters and\n-- `'?'` matches any single character.\n-- @treturn bool\n-- @raise dir and mask must be strings\nfunction dir.fnmatch(filename,pattern)\n    assert_string(1,filename)\n    assert_string(2,pattern)\n    return path.normcase(filename):find(filemask(pattern)) ~= nil\nend\n\n--- Return a list of all file names within an array which match a pattern.\n-- @tab filenames An array containing file names.\n-- @string pattern A shell pattern (see `fnmatch`).\n-- @treturn List(string) List of matching file names.\n-- @raise dir and mask must be strings\nfunction dir.filter(filenames,pattern)\n    assert_arg(1,filenames,'table')\n    assert_string(2,pattern)\n    local res = {}\n    local mask = filemask(pattern)\n    for i,f in ipairs(filenames) do\n        if path.normcase(f):find(mask) then append(res,f) end\n    end\n    return makelist(res)\nend\n\nlocal function _listfiles(dirname,filemode,match)\n    local res = {}\n    local check = utils.choose(filemode,path.isfile,path.isdir)\n    if not dirname then dirname = '.' end\n    for f in ldir(dirname) do\n        if f ~= '.' and f ~= '..' then\n            local p = path.join(dirname,f)\n            if check(p) and (not match or match(f)) then\n                append(res,p)\n            end\n        end\n    end\n    return makelist(res)\nend\n\n--- return a list of all files in a directory which match a shell pattern.\n-- @string[opt='.'] dirname A directory.\n-- @string[opt] mask A shell pattern (see `fnmatch`). If not given, all files are returned.\n-- @treturn {string} list of files\n-- @raise dirname and mask must be strings\nfunction dir.getfiles(dirname,mask)\n    dirname = dirname or '.'\n    assert_dir(1,dirname)\n    if mask then assert_string(2,mask) end\n    local match\n    if mask then\n        mask = filemask(mask)\n        match = function(f)\n            return path.normcase(f):find(mask)\n        end\n    end\n    return _listfiles(dirname,true,match)\nend\n\n--- return a list of all subdirectories of the directory.\n-- @string[opt='.'] dirname A directory.\n-- @treturn {string} a list of directories\n-- @raise dir must be a valid directory\nfunction dir.getdirectories(dirname)\n    dirname = dirname or '.'\n    assert_dir(1,dirname)\n    return _listfiles(dirname,false)\nend\n\nlocal alien,ffi,ffi_checked,CopyFile,MoveFile,GetLastError,win32_errors,cmd_tmpfile\n\nlocal function execute_command(cmd,parms)\n   if not cmd_tmpfile then cmd_tmpfile = path.tmpname () end\n   local err = path.is_windows and ' > ' or ' 2> '\n    cmd = cmd..' '..parms..err..utils.quote_arg(cmd_tmpfile)\n    local ret = utils.execute(cmd)\n    if not ret then\n        local err = (utils.readfile(cmd_tmpfile):gsub('\\n(.*)',''))\n        remove(cmd_tmpfile)\n        return false,err\n    else\n        remove(cmd_tmpfile)\n        return true\n    end\nend\n\nlocal function find_ffi_copyfile ()\n    if not ffi_checked then\n        ffi_checked = true\n        local res\n        res,alien = pcall(require,'alien')\n        if not res then\n            alien = nil\n            res, ffi = pcall(require,'ffi')\n        end\n        if not res then\n            ffi = nil\n            return\n        end\n    else\n        return\n    end\n    if alien then\n        -- register the Win32 CopyFile and MoveFile functions\n        local kernel = alien.load('kernel32.dll')\n        CopyFile = kernel.CopyFileA\n        CopyFile:types{'string','string','int',ret='int',abi='stdcall'}\n        MoveFile = kernel.MoveFileA\n        MoveFile:types{'string','string',ret='int',abi='stdcall'}\n        GetLastError = kernel.GetLastError\n        GetLastError:types{ret ='int', abi='stdcall'}\n    elseif ffi then\n        ffi.cdef [[\n            int CopyFileA(const char *src, const char *dest, int iovr);\n            int MoveFileA(const char *src, const char *dest);\n            int GetLastError();\n        ]]\n        CopyFile = ffi.C.CopyFileA\n        MoveFile = ffi.C.MoveFileA\n        GetLastError = ffi.C.GetLastError\n    end\n    win32_errors = {\n        ERROR_FILE_NOT_FOUND    =         2,\n        ERROR_PATH_NOT_FOUND    =         3,\n        ERROR_ACCESS_DENIED    =          5,\n        ERROR_WRITE_PROTECT    =          19,\n        ERROR_BAD_UNIT         =          20,\n        ERROR_NOT_READY        =          21,\n        ERROR_WRITE_FAULT      =          29,\n        ERROR_READ_FAULT       =          30,\n        ERROR_SHARING_VIOLATION =         32,\n        ERROR_LOCK_VIOLATION    =         33,\n        ERROR_HANDLE_DISK_FULL  =         39,\n        ERROR_BAD_NETPATH       =         53,\n        ERROR_NETWORK_BUSY      =         54,\n        ERROR_DEV_NOT_EXIST     =         55,\n        ERROR_FILE_EXISTS       =         80,\n        ERROR_OPEN_FAILED       =         110,\n        ERROR_INVALID_NAME      =         123,\n        ERROR_BAD_PATHNAME      =         161,\n        ERROR_ALREADY_EXISTS    =         183,\n    }\nend\n\nlocal function two_arguments (f1,f2)\n    return utils.quote_arg(f1)..' '..utils.quote_arg(f2)\nend\n\nlocal function file_op (is_copy,src,dest,flag)\n    if flag == 1 and path.exists(dest) then\n        return false,\"cannot overwrite destination\"\n    end\n    if is_windows then\n        -- if we haven't tried to load Alien\/LuaJIT FFI before, then do so\n        find_ffi_copyfile()\n        -- fallback if there's no Alien, just use DOS commands *shudder*\n        -- 'rename' involves a copy and then deleting the source.\n        if not CopyFile then\n            if path.is_windows then\n                src = src:gsub(\"\/\",\"\\\\\")\n                dest = dest:gsub(\"\/\",\"\\\\\")\n            end\n            local res, err = execute_command('copy',two_arguments(src,dest))\n            if not res then return false,err end\n            if not is_copy then\n                return execute_command('del',utils.quote_arg(src))\n            end\n            return true\n        else\n            if path.isdir(dest) then\n                dest = path.join(dest,path.basename(src))\n            end\n            local ret\n            if is_copy then ret = CopyFile(src,dest,flag)\n            else ret = MoveFile(src,dest) end\n            if ret == 0 then\n                local err = GetLastError()\n                for name,value in pairs(win32_errors) do\n                    if value == err then return false,name end\n                end\n                return false,\"Error #\"..err\n            else return true\n            end\n        end\n    else -- for Unix, just use cp for now\n        return execute_command(is_copy and 'cp' or 'mv',\n            two_arguments(src,dest))\n    end\nend\n\n--- copy a file.\n-- @string src source file\n-- @string dest destination file or directory\n-- @bool flag true if you want to force the copy (default)\n-- @treturn bool operation succeeded\n-- @raise src and dest must be strings\nfunction dir.copyfile (src,dest,flag)\n    assert_string(1,src)\n    assert_string(2,dest)\n    flag = flag==nil or flag\n    return file_op(true,src,dest,flag and 0 or 1)\nend\n\n--- move a file.\n-- @string src source file\n-- @string dest destination file or directory\n-- @treturn bool operation succeeded\n-- @raise src and dest must be strings\nfunction dir.movefile (src,dest)\n    assert_string(1,src)\n    assert_string(2,dest)\n    return file_op(false,src,dest,0)\nend\n\nlocal function _dirfiles(dirname,attrib)\n    local dirs = {}\n    local files = {}\n    for f in ldir(dirname) do\n        if f ~= '.' and f ~= '..' then\n            local p = path.join(dirname,f)\n            local mode = attrib(p,'mode')\n            if mode=='directory' then\n                append(dirs,f)\n            else\n                append(files,f)\n            end\n        end\n    end\n    return makelist(dirs), makelist(files)\nend\n\n\n--- return an iterator which walks through a directory tree starting at root.\n-- The iterator returns (root,dirs,files)\n-- Note that dirs and files are lists of names (i.e. you must say path.join(root,d)\n-- to get the actual full path)\n-- If bottom_up is false (or not present), then the entries at the current level are returned\n-- before we go deeper. This means that you can modify the returned list of directories before\n-- continuing.\n-- This is a clone of os.walk from the Python libraries.\n-- @string root A starting directory\n-- @bool bottom_up False if we start listing entries immediately.\n-- @bool follow_links follow symbolic links\n-- @return an iterator returning root,dirs,files\n-- @raise root must be a directory\nfunction dir.walk(root,bottom_up,follow_links)\n    assert_dir(1,root)\n    local attrib\n    if path.is_windows or not follow_links then\n        attrib = path.attrib\n    else\n        attrib = path.link_attrib\n    end\n\n    local to_scan = { root }\n    local to_return = {}\n    local iter = function()\n        while #to_scan > 0 do\n            local current_root = table.remove(to_scan)\n            local dirs,files = _dirfiles(current_root, attrib)\n            for _, d in ipairs(dirs) do\n                table.insert(to_scan, current_root..path.sep..d)\n            end\n            if not bottom_up then\n                return current_root, dirs, files\n            else\n                table.insert(to_return, { current_root, dirs, files })\n            end\n        end\n        if #to_return > 0 then\n            return utils.unpack(table.remove(to_return))\n        end\n    end\n\n    return iter\nend\n\n--- remove a whole directory tree.\n-- Symlinks in the tree will be deleted without following them.\n-- @string fullpath A directory path (must be an actual directory, not a symlink)\n-- @return true or nil\n-- @return error if failed\n-- @raise fullpath must be a string\nfunction dir.rmtree(fullpath)\n    assert_dir(1,fullpath)\n    if path.islink(fullpath) then return false,'will not follow symlink' end\n    for root,dirs,files in dir.walk(fullpath,true) do\n        if path.islink(root) then\n            -- sub dir is a link, remove link, do not follow\n            if is_windows then\n                -- Windows requires using \"rmdir\". Deleting the link like a file\n                -- will instead delete all files from the target directory!!\n                local res, err = rmdir(root)\n                if not res then return nil,err .. \": \" .. root end\n            else\n                local res, err = remove(root)\n                if not res then return nil,err .. \": \" .. root end\n            end\n        else\n            for i,f in ipairs(files) do\n                local res, err = remove(path.join(root,f))\n                if not res then return nil,err .. \": \" .. path.join(root,f) end\n            end\n            local res, err = rmdir(root)\n            if not res then return nil,err .. \": \" .. root end\n        end\n    end\n    return true\nend\n\n\ndo\n  local dirpat\n  if path.is_windows then\n      dirpat = '(.+)\\\\[^\\\\]+$'\n  else\n      dirpat = '(.+)\/[^\/]+$'\n  end\n\n  local _makepath\n  function _makepath(p)\n      -- windows root drive case\n      if p:find '^%a:[\\\\]*$' then\n          return true\n      end\n      if not path.isdir(p) then\n          local subp = p:match(dirpat)\n          if subp then\n            local ok, err = _makepath(subp)\n            if not ok then return nil, err end\n          end\n          return mkdir(p)\n      else\n          return true\n      end\n  end\n\n  --- create a directory path.\n  -- This will create subdirectories as necessary!\n  -- @string p A directory path\n  -- @return true on success, nil + errormsg on failure\n  -- @raise failure to create\n  function dir.makepath (p)\n      assert_string(1,p)\n      if path.is_windows then\n          p = p:gsub(\"\/\", \"\\\\\")\n      end\n      return _makepath(path.abspath(p))\n  end\nend\n\n--- clone a directory tree. Will always try to create a new directory structure\n-- if necessary.\n-- @string path1 the base path of the source tree\n-- @string path2 the new base path for the destination\n-- @func file_fun an optional function to apply on all files\n-- @bool verbose an optional boolean to control the verbosity of the output.\n--  It can also be a logging function that behaves like print()\n-- @return true, or nil\n-- @return error message, or list of failed directory creations\n-- @return list of failed file operations\n-- @raise path1 and path2 must be strings\n-- @usage clonetree('.','..\/backup',copyfile)\nfunction dir.clonetree (path1,path2,file_fun,verbose)\n    assert_string(1,path1)\n    assert_string(2,path2)\n    if verbose == true then verbose = print end\n    local abspath,normcase,isdir,join = path.abspath,path.normcase,path.isdir,path.join\n    local faildirs,failfiles = {},{}\n    if not isdir(path1) then return raise 'source is not a valid directory' end\n    path1 = abspath(normcase(path1))\n    path2 = abspath(normcase(path2))\n    if verbose then verbose('normalized:',path1,path2) end\n    -- particularly NB that the new path isn't fully contained in the old path\n    if path1 == path2 then return raise \"paths are the same\" end\n    local _,i2 = path2:find(path1,1,true)\n    if i2 == #path1 and path2:sub(i2+1,i2+1) == path.sep then\n        return raise 'destination is a subdirectory of the source'\n    end\n    local cp = path.common_prefix (path1,path2)\n    local idx = #cp\n    if idx == 0 then -- no common path, but watch out for Windows paths!\n        if path1:sub(2,2) == ':' then idx = 3 end\n    end\n    for root,dirs,files in dir.walk(path1) do\n        local opath = path2..root:sub(idx)\n        if verbose then verbose('paths:',opath,root) end\n        if not isdir(opath) then\n            local ret = dir.makepath(opath)\n            if not ret then append(faildirs,opath) end\n            if verbose then verbose('creating:',opath,ret) end\n        end\n        if file_fun then\n            for i,f in ipairs(files) do\n                local p1 = join(root,f)\n                local p2 = join(opath,f)\n                local ret = file_fun(p1,p2)\n                if not ret then append(failfiles,p2) end\n                if verbose then\n                    verbose('files:',p1,p2,ret)\n                end\n            end\n        end\n    end\n    return true,faildirs,failfiles\nend\n\n\n-- each entry of the stack is an array with three items:\n-- 1. the name of the directory\n-- 2. the lfs iterator function\n-- 3. the lfs iterator userdata\nlocal function treeiter(iterstack)\n    local diriter = iterstack[#iterstack]\n    if not diriter then\n      return -- done\n    end\n\n    local dirname = diriter[1]\n    local entry = diriter[2](diriter[3])\n    if not entry then\n      table.remove(iterstack)\n      return treeiter(iterstack) -- tail-call to try next\n    end\n\n    if entry ~= \".\" and entry ~= \"..\" then\n        entry = dirname .. sep .. entry\n        if exists(entry) then  -- Just in case a symlink is broken.\n            local is_dir = isdir(entry)\n            if is_dir then\n                table.insert(iterstack, { entry, ldir(entry) })\n            end\n            return entry, is_dir\n        end\n    end\n\n    return treeiter(iterstack) -- tail-call to try next\nend\n\n\n--- return an iterator over all entries in a directory tree\n-- @string d a directory\n-- @return an iterator giving pathname and mode (true for dir, false otherwise)\n-- @raise d must be a non-empty string\nfunction dir.dirtree( d )\n    assert( d and d ~= \"\", \"directory parameter is missing or empty\" )\n\n    local last = sub ( d, -1 )\n    if last == sep or last == '\/' then\n        d = sub( d, 1, -2 )\n    end\n\n    local iterstack = { {d, ldir(d)} }\n\n    return treeiter, iterstack\nend\n\n\n--- Recursively returns all the file starting at 'path'. It can optionally take a shell pattern and\n-- only returns files that match 'shell_pattern'. If a pattern is given it will do a case insensitive search.\n-- @string[opt='.'] start_path  A directory.\n-- @string[opt='*'] shell_pattern A shell pattern (see `fnmatch`).\n-- @treturn List(string) containing all the files found recursively starting at 'path' and filtered by 'shell_pattern'.\n-- @raise start_path must be a directory\nfunction dir.getallfiles( start_path, shell_pattern )\n    start_path = start_path or '.'\n    assert_dir(1,start_path)\n    shell_pattern = shell_pattern or \"*\"\n\n    local files = {}\n    local normcase = path.normcase\n    for filename, mode in dir.dirtree( start_path ) do\n        if not mode then\n            local mask = filemask( shell_pattern )\n            if normcase(filename):find( mask ) then\n                files[#files + 1] = filename\n            end\n        end\n    end\n\n    return makelist(files)\nend\n\nreturn dir"},{"name":"\/Users\/nascarsayan\/Code\/github.com\/nascarsayan\/sqids-lua\/lua_modules\/share\/lua\/5.4\/pl\/path.lua","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,0,0,0,0,0,null,0,0,0,null,null,0,0,0,null,0,null,null,0,0,0,null,0,0,0,null,0,null,null,null,null,null,0,null,null,null,null,null,0,0,0,null,0,null,null,null,null,null,null,0,0,0,null,0,null,null,null,null,null,null,0,0,0,null,0,null,null,null,null,null,null,0,0,0,null,0,null,null,null,null,null,null,0,0,0,null,0,null,null,null,null,null,null,null,null,0,0,0,null,0,null,null,null,null,0,18,18,null,null,null,null,0,3,3,null,null,null,null,0,0,0,0,null,0,null,null,null,null,null,0,0,0,null,null,null,null,null,0,12,12,null,null,null,null,0,0,0,null,null,null,null,0,0,0,null,null,null,null,0,0,0,null,null,null,null,2907,null,null,0,null,null,null,null,0,0,0,0,null,0,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,204,204,204,2859,2655,2655,null,204,0,null,204,null,null,null,null,null,null,0,0,0,0,0,0,0,0,0,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,12,12,12,48,36,0,null,36,36,null,12,0,null,12,null,null,null,null,null,null,null,null,null,null,0,192,192,192,null,null,null,null,null,null,null,null,null,0,12,12,12,null,null,null,null,null,null,null,null,null,0,12,12,12,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,0,0,0,0,0,0,null,0,null,0,0,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,0,24,24,0,null,24,null,null,null,null,null,null,null,null,0,0,null,0,0,0,0,0,0,0,0,0,0,0,0,0,0,null,null,0,null,null,null,0,0,0,0,0,0,null,null,0,0,0,0,0,null,0,null,0,0,null,null,0,0,0,null,null,null,null,null,0,0,0,0,0,0,null,0,0,0,0,null,0,null,0,0,0,0,null,0,0,0,0,null,null,null,0,0,0,0,null,0,null,null,null,null,null,null,null,0,0,0,0,0,0,null,0,null,0,null,null,null,null,null,null,0,0,null,null,null,0,0,null,0,null,null,null,null,null,null,0,0,0,null,0,null,0,0,0,0,null,0,null,0,0,0,0,0,null,0,null,null,0,0,null,null,null,null,null,null,null,null,null,0,0,null,0,0,0,0,0,null,null,null,null,0],"source":"--- Path manipulation and file queries.\n--\n-- This is modelled after Python's os.path library (10.1); see @{04-paths.md|the Guide}.\n--\n-- NOTE: the functions assume the paths being dealt with to originate\n-- from the OS the application is running on. Windows drive letters are not\n-- to be used when running on a Unix system for example. The one exception\n-- is Windows paths to allow both forward and backward slashes (since Lua\n-- also accepts those)\n--\n-- Dependencies: `pl.utils`, `lfs`\n-- @module pl.path\n\n-- imports and locals\nlocal _G = _G\nlocal sub = string.sub\nlocal getenv = os.getenv\nlocal tmpnam = os.tmpname\nlocal package = package\nlocal append, concat, remove = table.insert, table.concat, table.remove\nlocal utils = require 'pl.utils'\nlocal assert_string,raise = utils.assert_string,utils.raise\n\nlocal res,lfs = _G.pcall(_G.require,'lfs')\nif not res then\n    error(\"pl.path requires LuaFileSystem\")\nend\n\nlocal attrib = lfs.attributes\nlocal currentdir = lfs.currentdir\nlocal link_attrib = lfs.symlinkattributes\n\nlocal path = {}\n\nlocal function err_func(name, param, err, code)\n  local ret = (\"%s failed\"):format(tostring(name))\n  if param ~= nil then\n    ret = ret .. (\" for '%s'\"):format(tostring(param))\n  end\n  ret = ret .. (\": %s\"):format(tostring(err))\n  if code ~= nil then\n    ret = ret .. (\" (code %s)\"):format(tostring(code))\n  end\n  return ret\nend\n\n--- Lua iterator over the entries of a given directory.\n-- Implicit link to [`luafilesystem.dir`](https:\/\/keplerproject.github.io\/luafilesystem\/manual.html#reference)\n-- @function dir\npath.dir = lfs.dir\n\n--- Creates a directory.\n-- Implicit link to [`luafilesystem.mkdir`](https:\/\/keplerproject.github.io\/luafilesystem\/manual.html#reference)\n-- @function mkdir\npath.mkdir = function(d)\n  local ok, err, code = lfs.mkdir(d)\n  if not ok then\n    return ok, err_func(\"mkdir\", d, err, code), code\n  end\n  return ok, err, code\nend\n\n--- Removes a directory.\n-- Implicit link to [`luafilesystem.rmdir`](https:\/\/keplerproject.github.io\/luafilesystem\/manual.html#reference)\n-- @function rmdir\npath.rmdir = function(d)\n  local ok, err, code = lfs.rmdir(d)\n  if not ok then\n    return ok, err_func(\"rmdir\", d, err, code), code\n  end\n  return ok, err, code\nend\n\n--- Gets attributes.\n-- Implicit link to [`luafilesystem.attributes`](https:\/\/keplerproject.github.io\/luafilesystem\/manual.html#reference)\n-- @function attrib\npath.attrib = function(d, r)\n  local ok, err, code = attrib(d, r)\n  if not ok then\n    return ok, err_func(\"attrib\", d, err, code), code\n  end\n  return ok, err, code\nend\n\n--- Get the working directory.\n-- Implicit link to [`luafilesystem.currentdir`](https:\/\/keplerproject.github.io\/luafilesystem\/manual.html#reference)\n-- @function currentdir\npath.currentdir = function()\n  local ok, err, code = currentdir()\n  if not ok then\n    return ok, err_func(\"currentdir\", nil, err, code), code\n  end\n  return ok, err, code\nend\n\n--- Gets symlink attributes.\n-- Implicit link to [`luafilesystem.symlinkattributes`](https:\/\/keplerproject.github.io\/luafilesystem\/manual.html#reference)\n-- @function link_attrib\npath.link_attrib = function(d, r)\n  local ok, err, code = link_attrib(d, r)\n  if not ok then\n    return ok, err_func(\"link_attrib\", d, err, code), code\n  end\n  return ok, err, code\nend\n\n--- Changes the working directory.\n-- On Windows, if a drive is specified, it also changes the current drive. If\n-- only specifying the drive, it will only switch drive, but not modify the path.\n-- Implicit link to [`luafilesystem.chdir`](https:\/\/keplerproject.github.io\/luafilesystem\/manual.html#reference)\n-- @function chdir\npath.chdir = function(d)\n  local ok, err, code = lfs.chdir(d)\n  if not ok then\n    return ok, err_func(\"chdir\", d, err, code), code\n  end\n  return ok, err, code\nend\n\n--- is this a directory?\n-- @string P A file path\nfunction path.isdir(P)\n    assert_string(1,P)\n    return attrib(P,'mode') == 'directory'\nend\n\n--- is this a file?\n-- @string P A file path\nfunction path.isfile(P)\n    assert_string(1,P)\n    return attrib(P,'mode') == 'file'\nend\n\n-- is this a symbolic link?\n-- @string P A file path\nfunction path.islink(P)\n    assert_string(1,P)\n    if link_attrib then\n        return link_attrib(P,'mode')=='link'\n    else\n        return false\n    end\nend\n\n--- return size of a file.\n-- @string P A file path\nfunction path.getsize(P)\n    assert_string(1,P)\n    return attrib(P,'size')\nend\n\n--- does a path exist?\n-- @string P A file path\n-- @return the file path if it exists (either as file, directory, socket, etc), nil otherwise\nfunction path.exists(P)\n    assert_string(1,P)\n    return attrib(P,'mode') ~= nil and P\nend\n\n--- Return the time of last access as the number of seconds since the epoch.\n-- @string P A file path\nfunction path.getatime(P)\n    assert_string(1,P)\n    return attrib(P,'access')\nend\n\n--- Return the time of last modification as the number of seconds since the epoch.\n-- @string P A file path\nfunction path.getmtime(P)\n    assert_string(1,P)\n    return attrib(P,'modification')\nend\n\n---Return the system's ctime as the number of seconds since the epoch.\n-- @string P A file path\nfunction path.getctime(P)\n    assert_string(1,P)\n    return path.attrib(P,'change')\nend\n\n\nlocal function at(s,i)\n    return sub(s,i,i)\nend\n\npath.is_windows = utils.is_windows\n\nlocal sep, other_sep, seps\n-- constant sep is the directory separator for this platform.\n-- constant dirsep is the separator in the PATH environment variable\nif path.is_windows then\n    path.sep = '\\\\'; other_sep = '\/'\n    path.dirsep = ';'\n    seps = { ['\/'] = true, ['\\\\'] = true }\nelse\n    path.sep = '\/'\n    path.dirsep = ':'\n    seps = { ['\/'] = true }\nend\nsep = path.sep\n\n--- are we running Windows?\n-- @class field\n-- @name path.is_windows\n\n--- path separator for this platform.\n-- @class field\n-- @name path.sep\n\n--- separator for PATH for this platform\n-- @class field\n-- @name path.dirsep\n\n--- given a path, return the directory part and a file part.\n-- if there's no directory part, the first value will be empty\n-- @string P A file path\n-- @return directory part\n-- @return file part\n-- @usage\n-- local dir, file = path.splitpath(\"some\/dir\/myfile.txt\")\n-- assert(dir == \"some\/dir\")\n-- assert(file == \"myfile.txt\")\n--\n-- local dir, file = path.splitpath(\"some\/dir\/\")\n-- assert(dir == \"some\/dir\")\n-- assert(file == \"\")\n--\n-- local dir, file = path.splitpath(\"some_dir\")\n-- assert(dir == \"\")\n-- assert(file == \"some_dir\")\nfunction path.splitpath(P)\n    assert_string(1,P)\n    local i = #P\n    local ch = at(P,i)\n    while i > 0 and ch ~= sep and ch ~= other_sep do\n        i = i - 1\n        ch = at(P,i)\n    end\n    if i == 0 then\n        return '',P\n    else\n        return sub(P,1,i-1), sub(P,i+1)\n    end\nend\n\n--- return an absolute path.\n-- @string P A file path\n-- @string[opt] pwd optional start path to use (default is current dir)\nfunction path.abspath(P,pwd)\n    assert_string(1,P)\n    if pwd then assert_string(2,pwd) end\n    local use_pwd = pwd ~= nil\n    if not use_pwd and not currentdir() then return P end\n    P = P:gsub('[\\\\\/]$','')\n    pwd = pwd or currentdir()\n    if not path.isabs(P) then\n        P = path.join(pwd,P)\n    elseif path.is_windows and not use_pwd and at(P,2) ~= ':' and at(P,2) ~= '\\\\' then\n        P = pwd:sub(1,2)..P -- attach current drive to path like '\\\\fred.txt'\n    end\n    return path.normpath(P)\nend\n\n--- given a path, return the root part and the extension part.\n-- if there's no extension part, the second value will be empty\n-- @string P A file path\n-- @treturn string root part (everything upto the \".\"\", maybe empty)\n-- @treturn string extension part (including the \".\", maybe empty)\n-- @usage\n-- local file_path, ext = path.splitext(\"\/bonzo\/dog_stuff\/cat.txt\")\n-- assert(file_path == \"\/bonzo\/dog_stuff\/cat\")\n-- assert(ext == \".txt\")\n--\n-- local file_path, ext = path.splitext(\"\")\n-- assert(file_path == \"\")\n-- assert(ext == \"\")\nfunction path.splitext(P)\n    assert_string(1,P)\n    local i = #P\n    local ch = at(P,i)\n    while i > 0 and ch ~= '.' do\n        if seps[ch] then\n            return P,''\n        end\n        i = i - 1\n        ch = at(P,i)\n    end\n    if i == 0 then\n        return P,''\n    else\n        return sub(P,1,i-1),sub(P,i)\n    end\nend\n\n--- return the directory part of a path\n-- @string P A file path\n-- @treturn string everything before the last dir-separator\n-- @see splitpath\n-- @usage\n-- path.dirname(\"\/some\/path\/file.txt\")   -- \"\/some\/path\"\n-- path.dirname(\"file.txt\")              -- \"\" (empty string)\nfunction path.dirname(P)\n    assert_string(1,P)\n    local p1 = path.splitpath(P)\n    return p1\nend\n\n--- return the file part of a path\n-- @string P A file path\n-- @treturn string\n-- @see splitpath\n-- @usage\n-- path.basename(\"\/some\/path\/file.txt\")  -- \"file.txt\"\n-- path.basename(\"\/some\/path\/file\/\")     -- \"\" (empty string)\nfunction path.basename(P)\n    assert_string(1,P)\n    local _,p2 = path.splitpath(P)\n    return p2\nend\n\n--- get the extension part of a path.\n-- @string P A file path\n-- @treturn string\n-- @see splitext\n-- @usage\n-- path.extension(\"\/some\/path\/file.txt\") -- \".txt\"\n-- path.extension(\"\/some\/path\/file_txt\") -- \"\" (empty string)\nfunction path.extension(P)\n    assert_string(1,P)\n    local _,p2 = path.splitext(P)\n    return p2\nend\n\n--- is this an absolute path?\n-- @string P A file path\n-- @usage\n-- path.isabs(\"hello\/path\")    -- false\n-- path.isabs(\"\/hello\/path\")   -- true\n-- -- Windows;\n-- path.isabs(\"hello\\path\")    -- false\n-- path.isabs(\"\\hello\\path\")   -- true\n-- path.isabs(\"C:\\hello\\path\") -- true\n-- path.isabs(\"C:hello\\path\")  -- false\nfunction path.isabs(P)\n    assert_string(1,P)\n    if path.is_windows and at(P,2) == \":\" then\n        return seps[at(P,3)] ~= nil\n    end\n    return seps[at(P,1)] ~= nil\nend\n\n--- return the path resulting from combining the individual paths.\n-- if the second (or later) path is absolute, we return the last absolute path (joined with any non-absolute paths following).\n-- empty elements (except the last) will be ignored.\n-- @string p1 A file path\n-- @string p2 A file path\n-- @string ... more file paths\n-- @treturn string the combined path\n-- @usage\n-- path.join(\"\/first\",\"second\",\"third\")   -- \"\/first\/second\/third\"\n-- path.join(\"first\",\"second\/third\")      -- \"first\/second\/third\"\n-- path.join(\"\/first\",\"\/second\",\"third\")  -- \"\/second\/third\"\nfunction path.join(p1,p2,...)\n    assert_string(1,p1)\n    assert_string(2,p2)\n    if select('#',...) > 0 then\n        local p = path.join(p1,p2)\n        local args = {...}\n        for i = 1,#args do\n            assert_string(i,args[i])\n            p = path.join(p,args[i])\n        end\n        return p\n    end\n    if path.isabs(p2) then return p2 end\n    local endc = at(p1,#p1)\n    if endc ~= path.sep and endc ~= other_sep and endc ~= \"\" then\n        p1 = p1..path.sep\n    end\n    return p1..p2\nend\n\n--- normalize the case of a pathname. On Unix, this returns the path unchanged,\n-- for Windows it converts;\n--\n-- * the path to lowercase\n-- * forward slashes to backward slashes\n-- @string P A file path\n-- @usage path.normcase(\"\/Some\/Path\/File.txt\")\n-- -- Windows: \"\\some\\path\\file.txt\"\n-- -- Others : \"\/Some\/Path\/File.txt\"\nfunction path.normcase(P)\n    assert_string(1,P)\n    if path.is_windows then\n        return P:gsub('\/','\\\\'):lower()\n    else\n        return P\n    end\nend\n\n--- normalize a path name.\n-- `A\/\/B`, `A\/.\/B`, and `A\/foo\/..\/B` all become `A\/B`.\n--\n-- An empty path results in '.'.\n-- @string P a file path\nfunction path.normpath(P)\n    assert_string(1,P)\n    -- Split path into anchor and relative path.\n    local anchor = ''\n    if path.is_windows then\n        if P:match '^\\\\\\\\' then -- UNC\n            anchor = '\\\\\\\\'\n            P = P:sub(3)\n        elseif seps[at(P, 1)] then\n            anchor = '\\\\'\n            P = P:sub(2)\n        elseif at(P, 2) == ':' then\n            anchor = P:sub(1, 2)\n            P = P:sub(3)\n            if seps[at(P, 1)] then\n                anchor = anchor..'\\\\'\n                P = P:sub(2)\n            end\n        end\n        P = P:gsub('\/','\\\\')\n    else\n        -- According to POSIX, in path start '\/\/' and '\/' are distinct,\n        -- but '\/\/\/+' is equivalent to '\/'.\n        if P:match '^\/\/' and at(P, 3) ~= '\/' then\n            anchor = '\/\/'\n            P = P:sub(3)\n        elseif at(P, 1) == '\/' then\n            anchor = '\/'\n            P = P:match '^\/*(.*)$'\n        end\n    end\n    local parts = {}\n    for part in P:gmatch('[^'..sep..']+') do\n        if part == '..' then\n            if #parts ~= 0 and parts[#parts] ~= '..' then\n                remove(parts)\n            else\n                append(parts, part)\n            end\n        elseif part ~= '.' then\n            append(parts, part)\n        end\n    end\n    P = anchor..concat(parts, sep)\n    if P == '' then P = '.' end\n    return P\nend\n\n--- relative path from current directory or optional start point\n-- @string P a path\n-- @string[opt] start optional start point (default current directory)\nfunction path.relpath (P,start)\n    assert_string(1,P)\n    if start then assert_string(2,start) end\n    local split,min,append = utils.split, math.min, table.insert\n    P = path.abspath(P,start)\n    start = start or currentdir()\n    local compare\n    if path.is_windows then\n        P = P:gsub(\"\/\",\"\\\\\")\n        start = start:gsub(\"\/\",\"\\\\\")\n        compare = function(v) return v:lower() end\n    else\n        compare = function(v) return v end\n    end\n    local startl, Pl = split(start,sep), split(P,sep)\n    local n = min(#startl,#Pl)\n    if path.is_windows and n > 0 and at(Pl[1],2) == ':' and Pl[1] ~= startl[1] then\n        return P\n    end\n    local k = n+1 -- default value if this loop doesn't bail out!\n    for i = 1,n do\n        if compare(startl[i]) ~= compare(Pl[i]) then\n            k = i\n            break\n        end\n    end\n    local rell = {}\n    for i = 1, #startl-k+1 do rell[i] = '..' end\n    if k <= #Pl then\n        for i = k,#Pl do append(rell,Pl[i]) end\n    end\n    return table.concat(rell,sep)\nend\n\n\n--- Replace a starting '~' with the user's home directory.\n-- In windows, if HOME isn't set, then USERPROFILE is used in preference to\n-- HOMEDRIVE HOMEPATH. This is guaranteed to be writeable on all versions of Windows.\n-- @string P A file path\nfunction path.expanduser(P)\n    assert_string(1,P)\n    if at(P,1) == '~' then\n        local home = getenv('HOME')\n        if not home then -- has to be Windows\n            home = getenv 'USERPROFILE' or (getenv 'HOMEDRIVE' .. getenv 'HOMEPATH')\n        end\n        return home..sub(P,2)\n    else\n        return P\n    end\nend\n\n\n---Return a suitable full path to a new temporary file name.\n-- unlike os.tmpname(), it always gives you a writeable path (uses TEMP environment variable on Windows)\nfunction path.tmpname ()\n    local res = tmpnam()\n    -- On Windows if Lua is compiled using MSVC14 os.tmpname\n    -- already returns an absolute path within TEMP env variable directory,\n    -- no need to prepend it.\n    if path.is_windows and not res:find(':') then\n        res = getenv('TEMP')..res\n    end\n    return res\nend\n\n--- return the largest common prefix path of two paths.\n-- @string path1 a file path\n-- @string path2 a file path\n-- @return the common prefix (Windows: separators will be normalized, casing will be original)\nfunction path.common_prefix (path1,path2)\n    assert_string(1,path1)\n    assert_string(2,path2)\n    -- get them in order!\n    if #path1 > #path2 then path2,path1 = path1,path2 end\n    local compare\n    if path.is_windows then\n        path1 = path1:gsub(\"\/\", \"\\\\\")\n        path2 = path2:gsub(\"\/\", \"\\\\\")\n        compare = function(v) return v:lower() end\n    else\n        compare = function(v) return v end\n    end\n    for i = 1,#path1 do\n        if compare(at(path1,i)) ~= compare(at(path2,i)) then\n            local cp = path1:sub(1,i-1)\n            if at(path1,i-1) ~= sep then\n                cp = path.dirname(cp)\n            end\n            return cp\n        end\n    end\n    if at(path2,#path1+1) ~= sep then path1 = path.dirname(path1) end\n    return path1\n    --return ''\nend\n\n--- return the full path where a particular Lua module would be found.\n-- Both package.path and package.cpath is searched, so the result may\n-- either be a Lua file or a shared library.\n-- @string mod name of the module\n-- @return on success: path of module, lua or binary\n-- @return on error: nil, error string listing paths tried\nfunction path.package_path(mod)\n    assert_string(1,mod)\n    local res, err1, err2\n    res, err1 = package.searchpath(mod,package.path)\n    if res then return res,true end\n    res, err2 = package.searchpath(mod,package.cpath)\n    if res then return res,false end\n    return raise ('cannot find module on path\\n' .. err1 .. \"\\n\" .. err2)\nend\n\n\n---- finis -----\nreturn path"},{"name":"\/Users\/nascarsayan\/Code\/github.com\/nascarsayan\/sqids-lua\/lua_modules\/share\/lua\/5.4\/pl\/tablex.lua","coverage":[null,null,null,null,null,null,0,0,0,0,0,0,0,0,null,0,null,null,null,null,null,6,6,null,null,null,0,null,null,null,0,null,null,null,0,null,null,null,6,0,null,null,null,null,15,0,null,null,null,null,0,0,null,null,null,null,null,null,null,null,0,0,0,0,0,null,0,null,null,null,null,null,null,null,null,null,null,0,0,0,0,0,null,null,null,null,null,null,0,15,15,975,960,null,15,null,null,null,0,0,0,0,0,0,0,0,0,0,null,0,0,null,null,null,null,null,null,null,null,0,0,null,null,0,null,null,0,0,0,0,null,0,0,0,null,null,0,0,0,0,null,0,0,null,0,0,0,0,0,null,0,null,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,0,0,0,0,null,0,null,null,null,null,null,null,null,0,0,0,0,0,0,0,0,null,0,0,null,0,0,0,null,null,null,null,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,0,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,0,0,0,0,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,0,0,0,null,0,null,null,null,null,null,null,null,null,0,0,0,0,0,0,null,0,null,null,null,null,null,null,null,null,null,null,0,0,0,0,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,0,0,0,0,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,0,0,0,0,0,null,0,null,null,null,null,null,null,null,null,0,0,0,0,0,null,null,null,null,null,null,null,null,0,null,0,0,0,0,0,null,0,0,0,null,0,null,null,null,null,null,null,null,null,null,null,0,0,0,0,0,0,0,null,0,null,null,null,null,null,null,null,null,null,null,0,0,0,0,0,0,0,null,0,null,null,null,null,null,null,null,null,0,0,0,0,0,0,null,0,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,0,0,0,0,0,null,null,null,null,null,null,null,null,null,null,0,0,0,0,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,0,0,0,0,null,0,0,0,0,0,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,0,0,0,0,0,0,0,null,0,null,null,0,null,null,0,null,null,0,null,null,0,null,null,null,null,0,0,0,null,null,0,null,null,null,null,0,0,0,null,null,0,null,null,null,null,null,0,0,0,null,null,0,null,null,null,null,null,0,0,0,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,0,0,0,null,0,0,0,null,null,0,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,null,null,null,0,0,0,0,0,0,null,0,0,0,null,null,0,null,null,null,null,null,null,null,0,0,0,0,0,0,0,0,0,null,0,0,0,0,0,0,0,null,null,null,null,0,null,null,null,null,null,null,null,0,6,6,6,30,24,24,24,24,null,null,6,null,null,null,null,null,null,null,0,0,null,null,null,0,0,0,null,0,0,0,null,0,null,0,0,0,0,null,null,0,0,0,null,0,0,null,0,null,null,null,null,null,null,null,null,null,0,0,0,0,null,null,null,null,null,null,null,null,null,0,0,0,0,null,null,0,0,0,0,null,0,0,0,null,null,null,null,null,null,null,null,null,null,null,0,0,0,0,0,0,null,null,null,null,null,null,null,null,0,0,0,0,0,0,null,null,0,0,null,null,null,null,null,null,null,null,0,0,0,0,null,null,null,null,null,0,0,0,null,null,null,null,null,null,null,null,null,0,3,null,3,3,null,0,null,3,3,0,null,3,15,12,null,null,3,null,null,null,null,null,null,null,null,0,0,0,0,0,null,0,null,null,null,null,0,0,null,0,0,0,0,0,0,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,0,0,null,0,null,null,null,null,null,null,null,null,0,0,0,0,0,null,0,0,null,null,null,null,null,null,null,null,null,0,0,0,0,0,0,null,0,0,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,0,null,0,null,null,0],"source":"--- Extended operations on Lua tables.\n--\n-- See @{02-arrays.md.Useful_Operations_on_Tables|the Guide}\n--\n-- Dependencies: `pl.utils`, `pl.types`\n-- @module pl.tablex\nlocal utils = require ('pl.utils')\nlocal types = require ('pl.types')\nlocal getmetatable,setmetatable,require = getmetatable,setmetatable,require\nlocal tsort,append,remove = table.sort,table.insert,table.remove\nlocal min = math.min\nlocal pairs,type,unpack,select,tostring = pairs,type,utils.unpack,select,tostring\nlocal function_arg = utils.function_arg\nlocal assert_arg = utils.assert_arg\n\nlocal tablex = {}\n\n-- generally, functions that make copies of tables try to preserve the metatable.\n-- However, when the source has no obvious type, then we attach appropriate metatables\n-- like List, Map, etc to the result.\nlocal function setmeta (res,tbl,pl_class)\n    local mt = getmetatable(tbl) or pl_class and require('pl.' .. pl_class)\n    return mt and setmetatable(res, mt) or res\nend\n\nlocal function makelist(l)\n    return setmetatable(l, require('pl.List'))\nend\n\nlocal function makemap(m)\n    return setmetatable(m, require('pl.Map'))\nend\n\nlocal function complain (idx,msg)\n    error(('argument %d is not %s'):format(idx,msg),3)\nend\n\nlocal function assert_arg_indexable (idx,val)\n    if not types.is_indexable(val) then\n        complain(idx,\"indexable\")\n    end\nend\n\nlocal function assert_arg_iterable (idx,val)\n    if not types.is_iterable(val) then\n        complain(idx,\"iterable\")\n    end\nend\n\nlocal function assert_arg_writeable (idx,val)\n    if not types.is_writeable(val) then\n        complain(idx,\"writeable\")\n    end\nend\n\n--- copy a table into another, in-place.\n-- @within Copying\n-- @tab t1 destination table\n-- @tab t2 source (actually any iterable object)\n-- @return first table\nfunction tablex.update (t1,t2)\n    assert_arg_writeable(1,t1)\n    assert_arg_iterable(2,t2)\n    for k,v in pairs(t2) do\n        t1[k] = v\n    end\n    return t1\nend\n\n--- total number of elements in this table.\n-- Note that this is distinct from `#t`, which is the number\n-- of values in the array part; this value will always\n-- be greater or equal. The difference gives the size of\n-- the hash part, for practical purposes. Works for any\n-- object with a __pairs metamethod.\n-- @tab t a table\n-- @return the size\nfunction tablex.size (t)\n    assert_arg_iterable(1,t)\n    local i = 0\n    for k in pairs(t) do i = i + 1 end\n    return i\nend\n\n--- make a shallow copy of a table\n-- @within Copying\n-- @tab t an iterable source\n-- @return new table\nfunction tablex.copy (t)\n    assert_arg_iterable(1,t)\n    local res = {}\n    for k,v in pairs(t) do\n        res[k] = v\n    end\n    return res\nend\n\nlocal function cycle_aware_copy(t, cache)\n    if type(t) ~= 'table' then return t end\n    if cache[t] then return cache[t] end\n    assert_arg_iterable(1,t)\n    local res = {}\n    cache[t] = res\n    local mt = getmetatable(t)\n    for k,v in pairs(t) do\n        k = cycle_aware_copy(k, cache)\n        v = cycle_aware_copy(v, cache)\n        res[k] = v\n    end\n    setmetatable(res,mt)\n    return res\nend\n\n--- make a deep copy of a table, recursively copying all the keys and fields.\n-- This supports cycles in tables; cycles will be reproduced in the copy.\n-- This will also set the copied table's metatable to that of the original.\n-- @within Copying\n-- @tab t A table\n-- @return new table\nfunction tablex.deepcopy(t)\n    return cycle_aware_copy(t,{})\nend\n\nlocal abs = math.abs\n\nlocal function cycle_aware_compare(t1,t2,ignore_mt,eps,cache)\n    if cache[t1] and cache[t1][t2] then return true end\n    local ty1 = type(t1)\n    local ty2 = type(t2)\n    if ty1 ~= ty2 then return false end\n    -- non-table types can be directly compared\n    if ty1 ~= 'table' then\n        if ty1 == 'number' and eps then return abs(t1-t2) < eps end\n        return t1 == t2\n    end\n    -- as well as tables which have the metamethod __eq\n    local mt = getmetatable(t1)\n    if not ignore_mt and mt and mt.__eq then return t1 == t2 end\n    for k1 in pairs(t1) do\n        if t2[k1]==nil then return false end\n    end\n    for k2 in pairs(t2) do\n        if t1[k2]==nil then return false end\n    end\n    cache[t1] = cache[t1] or {}\n    cache[t1][t2] = true\n    for k1,v1 in pairs(t1) do\n        local v2 = t2[k1]\n        if not cycle_aware_compare(v1,v2,ignore_mt,eps,cache) then return false end\n    end\n    return true\nend\n\n--- compare two values.\n-- if they are tables, then compare their keys and fields recursively.\n-- @within Comparing\n-- @param t1 A value\n-- @param t2 A value\n-- @bool[opt] ignore_mt if true, ignore __eq metamethod (default false)\n-- @number[opt] eps if defined, then used for any number comparisons\n-- @return true or false\nfunction tablex.deepcompare(t1,t2,ignore_mt,eps)\n    return cycle_aware_compare(t1,t2,ignore_mt,eps,{})\nend\n\n--- compare two arrays using a predicate.\n-- @within Comparing\n-- @array t1 an array\n-- @array t2 an array\n-- @func cmp A comparison function; `bool = cmp(t1_value, t2_value)`\n-- @return true or false\n-- @usage\n-- assert(tablex.compare({ 1, 2, 3 }, { 1, 2, 3 }, \"==\"))\n--\n-- assert(tablex.compare(\n--    {1,2,3, hello = \"world\"},  -- fields are not compared!\n--    {1,2,3}, function(v1, v2) return v1 == v2 end)\nfunction tablex.compare (t1,t2,cmp)\n    assert_arg_indexable(1,t1)\n    assert_arg_indexable(2,t2)\n    if #t1 ~= #t2 then return false end\n    cmp = function_arg(3,cmp)\n    for k = 1,#t1 do\n        if not cmp(t1[k],t2[k]) then return false end\n    end\n    return true\nend\n\n--- compare two list-like tables using an optional predicate, without regard for element order.\n-- @within Comparing\n-- @array t1 a list-like table\n-- @array t2 a list-like table\n-- @param cmp A comparison function (may be nil)\nfunction tablex.compare_no_order (t1,t2,cmp)\n    assert_arg_indexable(1,t1)\n    assert_arg_indexable(2,t2)\n    if cmp then cmp = function_arg(3,cmp) end\n    if #t1 ~= #t2 then return false end\n    local visited = {}\n    for i = 1,#t1 do\n        local val = t1[i]\n        local gotcha\n        for j = 1,#t2 do\n            if not visited[j] then\n                local match\n                if cmp then match = cmp(val,t2[j]) else match = val == t2[j] end\n                if match then\n                    gotcha = j\n                    break\n                end\n            end\n        end\n        if not gotcha then return false end\n        visited[gotcha] = true\n    end\n    return true\nend\n\n\n--- return the index of a value in a list.\n-- Like string.find, there is an optional index to start searching,\n-- which can be negative.\n-- @within Finding\n-- @array t A list-like table\n-- @param val A value\n-- @int idx index to start; -1 means last element,etc (default 1)\n-- @return index of value or nil if not found\n-- @usage find({10,20,30},20) == 2\n-- @usage find({'a','b','a','c'},'a',2) == 3\nfunction tablex.find(t,val,idx)\n    assert_arg_indexable(1,t)\n    idx = idx or 1\n    if idx < 0 then idx = #t + idx + 1 end\n    for i = idx,#t do\n        if t[i] == val then return i end\n    end\n    return nil\nend\n\n--- return the index of a value in a list, searching from the end.\n-- Like string.find, there is an optional index to start searching,\n-- which can be negative.\n-- @within Finding\n-- @array t A list-like table\n-- @param val A value\n-- @param idx index to start; -1 means last element,etc (default `#t`)\n-- @return index of value or nil if not found\n-- @usage rfind({10,10,10},10) == 3\nfunction tablex.rfind(t,val,idx)\n    assert_arg_indexable(1,t)\n    idx = idx or #t\n    if idx < 0 then idx = #t + idx + 1 end\n    for i = idx,1,-1 do\n        if t[i] == val then return i end\n    end\n    return nil\nend\n\n\n--- return the index (or key) of a value in a table using a comparison function.\n--\n-- *NOTE*: the 2nd return value of this function, the value returned\n-- by the comparison function, has a limitation that it cannot be `false`.\n-- Because if it is, then it indicates the comparison failed, and the\n-- function will continue the search. See examples.\n-- @within Finding\n-- @tab t A table\n-- @func cmp A comparison function\n-- @param arg an optional second argument to the function\n-- @return index of value, or nil if not found\n-- @return value returned by comparison function (cannot be `false`!)\n-- @usage\n-- -- using an operator\n-- local lst = { \"Rudolph\", true, false, 15 }\n-- local idx, cmp_result = tablex.rfind(lst, \"==\", \"Rudolph\")\n-- assert(idx == 1)\n-- assert(cmp_result == true)\n--\n-- local idx, cmp_result = tablex.rfind(lst, \"==\", false)\n-- assert(idx == 3)\n-- assert(cmp_result == true)       -- looking up 'false' works!\n--\n-- -- using a function returning the value looked up\n-- local cmp = function(v1, v2) return v1 == v2 and v2 end\n-- local idx, cmp_result = tablex.rfind(lst, cmp, \"Rudolph\")\n-- assert(idx == 1)\n-- assert(cmp_result == \"Rudolph\")  -- the value is returned\n--\n-- -- NOTE: this fails, since 'false' cannot be returned!\n-- local idx, cmp_result = tablex.rfind(lst, cmp, false)\n-- assert(idx == nil)               -- looking up 'false' failed!\n-- assert(cmp_result == nil)\nfunction tablex.find_if(t,cmp,arg)\n    assert_arg_iterable(1,t)\n    cmp = function_arg(2,cmp)\n    for k,v in pairs(t) do\n        local c = cmp(v,arg)\n        if c then return k,c end\n    end\n    return nil\nend\n\n--- return a list of all values in a table indexed by another list.\n-- @tab tbl a table\n-- @array idx an index table (a list of keys)\n-- @return a list-like table\n-- @usage index_by({10,20,30,40},{2,4}) == {20,40}\n-- @usage index_by({one=1,two=2,three=3},{'one','three'}) == {1,3}\nfunction tablex.index_by(tbl,idx)\n    assert_arg_indexable(1,tbl)\n    assert_arg_indexable(2,idx)\n    local res = {}\n    for i = 1,#idx do\n        res[i] = tbl[idx[i]]\n    end\n    return setmeta(res,tbl,'List')\nend\n\n--- apply a function to all values of a table.\n-- This returns a table of the results.\n-- Any extra arguments are passed to the function.\n-- @within MappingAndFiltering\n-- @func fun A function that takes at least one argument\n-- @tab t A table\n-- @param ... optional arguments\n-- @usage map(function(v) return v*v end, {10,20,30,fred=2}) is {100,400,900,fred=4}\nfunction tablex.map(fun,t,...)\n    assert_arg_iterable(1,t)\n    fun = function_arg(1,fun)\n    local res = {}\n    for k,v in pairs(t) do\n        res[k] = fun(v,...)\n    end\n    return setmeta(res,t)\nend\n\n--- apply a function to all values of a list.\n-- This returns a table of the results.\n-- Any extra arguments are passed to the function.\n-- @within MappingAndFiltering\n-- @func fun A function that takes at least one argument\n-- @array t a table (applies to array part)\n-- @param ... optional arguments\n-- @return a list-like table\n-- @usage imap(function(v) return v*v end, {10,20,30,fred=2}) is {100,400,900}\nfunction tablex.imap(fun,t,...)\n    assert_arg_indexable(1,t)\n    fun = function_arg(1,fun)\n    local res = {}\n    for i = 1,#t do\n        res[i] = fun(t[i],...) or false\n    end\n    return setmeta(res,t,'List')\nend\n\n--- apply a named method to values from a table.\n-- @within MappingAndFiltering\n-- @string name the method name\n-- @array t a list-like table\n-- @param ... any extra arguments to the method\n-- @return a `List` with the results of the method (1st result only)\n-- @usage\n-- local Car = {}\n-- Car.__index = Car\n-- function Car.new(car)\n--   return setmetatable(car or {}, Car)\n-- end\n-- Car.speed = 0\n-- function Car:faster(increase)\n--   self.speed = self.speed + increase\n--   return self.speed\n-- end\n--\n-- local ferrari = Car.new{ name = \"Ferrari\" }\n-- local lamborghini = Car.new{ name = \"Lamborghini\", speed = 50 }\n-- local cars = { ferrari, lamborghini }\n--\n-- assert(ferrari.speed == 0)\n-- assert(lamborghini.speed == 50)\n-- tablex.map_named_method(\"faster\", cars, 10)\n-- assert(ferrari.speed == 10)\n-- assert(lamborghini.speed == 60)\nfunction tablex.map_named_method (name,t,...)\n    utils.assert_string(1,name)\n    assert_arg_indexable(2,t)\n    local res = {}\n    for i = 1,#t do\n        local val = t[i]\n        local fun = val[name]\n        res[i] = fun(val,...)\n    end\n    return setmeta(res,t,'List')\nend\n\n--- apply a function to all values of a table, in-place.\n-- Any extra arguments are passed to the function.\n-- @func fun A function that takes at least one argument\n-- @tab t a table\n-- @param ... extra arguments passed to `fun`\n-- @see tablex.foreach\nfunction tablex.transform (fun,t,...)\n    assert_arg_iterable(1,t)\n    fun = function_arg(1,fun)\n    for k,v in pairs(t) do\n        t[k] = fun(v,...)\n    end\nend\n\n--- generate a table of all numbers in a range.\n-- This is consistent with a numerical for loop.\n-- @int start  number\n-- @int finish number\n-- @int[opt=1] step  make this negative for start < finish\nfunction tablex.range (start,finish,step)\n    local res\n    step = step or 1\n    if start == finish then\n        res = {start}\n    elseif (start > finish and step > 0) or (finish > start and step < 0) then\n        res = {}\n    else\n        local k = 1\n        res = {}\n        for i=start,finish,step do res[k]=i; k=k+1 end\n    end\n    return makelist(res)\nend\n\n--- apply a function to values from two tables.\n-- @within MappingAndFiltering\n-- @func fun a function of at least two arguments\n-- @tab t1 a table\n-- @tab t2 a table\n-- @param ... extra arguments\n-- @return a table\n-- @usage map2('+',{1,2,3,m=4},{10,20,30,m=40}) is {11,22,23,m=44}\nfunction tablex.map2 (fun,t1,t2,...)\n    assert_arg_iterable(1,t1)\n    assert_arg_iterable(2,t2)\n    fun = function_arg(1,fun)\n    local res = {}\n    for k,v in pairs(t1) do\n        res[k] = fun(v,t2[k],...)\n    end\n    return setmeta(res,t1,'List')\nend\n\n--- apply a function to values from two arrays.\n-- The result will be the length of the shortest array.\n-- @within MappingAndFiltering\n-- @func fun a function of at least two arguments\n-- @array t1 a list-like table\n-- @array t2 a list-like table\n-- @param ... extra arguments\n-- @usage imap2('+',{1,2,3,m=4},{10,20,30,m=40}) is {11,22,23}\nfunction tablex.imap2 (fun,t1,t2,...)\n    assert_arg_indexable(2,t1)\n    assert_arg_indexable(3,t2)\n    fun = function_arg(1,fun)\n    local res,n = {},math.min(#t1,#t2)\n    for i = 1,n do\n        res[i] = fun(t1[i],t2[i],...)\n    end\n    return res\nend\n\n--- 'reduce' a list using a binary function.\n-- @func fun a function of two arguments\n-- @array t a list-like table\n-- @array memo optional initial memo value. Defaults to first value in table.\n-- @return the result of the function\n-- @usage reduce('+',{1,2,3,4}) == 10\nfunction tablex.reduce (fun,t,memo)\n    assert_arg_indexable(2,t)\n    fun = function_arg(1,fun)\n    local n = #t\n    if n == 0 then\n        return memo\n    end\n    local res = memo and fun(memo, t[1]) or t[1]\n    for i = 2,n do\n        res = fun(res,t[i])\n    end\n    return res\nend\n\n--- apply a function to all elements of a table.\n-- The arguments to the function will be the value,\n-- the key and _finally_ any extra arguments passed to this function.\n-- Note that the Lua 5.0 function table.foreach passed the _key_ first.\n-- @within Iterating\n-- @tab t a table\n-- @func fun a function on the elements; `function(value, key, ...)`\n-- @param ... extra arguments passed to `fun`\n-- @see tablex.transform\nfunction tablex.foreach(t,fun,...)\n    assert_arg_iterable(1,t)\n    fun = function_arg(2,fun)\n    for k,v in pairs(t) do\n        fun(v,k,...)\n    end\nend\n\n--- apply a function to all elements of a list-like table in order.\n-- The arguments to the function will be the value,\n-- the index and _finally_ any extra arguments passed to this function\n-- @within Iterating\n-- @array t a table\n-- @func fun a function with at least one argument\n-- @param ... optional arguments\nfunction tablex.foreachi(t,fun,...)\n    assert_arg_indexable(1,t)\n    fun = function_arg(2,fun)\n    for i = 1,#t do\n        fun(t[i],i,...)\n    end\nend\n\n--- Apply a function to a number of tables.\n-- A more general version of map\n-- The result is a table containing the result of applying that function to the\n-- ith value of each table. Length of output list is the minimum length of all the lists\n-- @within MappingAndFiltering\n-- @func fun a function of n arguments\n-- @tab ... n tables\n-- @usage mapn(function(x,y,z) return x+y+z end, {1,2,3},{10,20,30},{100,200,300}) is {111,222,333}\n-- @usage mapn(math.max, {1,20,300},{10,2,3},{100,200,100}) is    {100,200,300}\n-- @param fun A function that takes as many arguments as there are tables\nfunction tablex.mapn(fun,...)\n    fun = function_arg(1,fun)\n    local res = {}\n    local lists = {...}\n    local minn = 1e40\n    for i = 1,#lists do\n        minn = min(minn,#(lists[i]))\n    end\n    for i = 1,minn do\n        local args,k = {},1\n        for j = 1,#lists do\n            args[k] = lists[j][i]\n            k = k + 1\n        end\n        res[#res+1] = fun(unpack(args))\n    end\n    return res\nend\n\n--- call the function with the key and value pairs from a table.\n-- The function can return a value and a key (note the order!). If both\n-- are not nil, then this pair is inserted into the result: if the key already exists, we convert the value for that\n-- key into a table and append into it. If only value is not nil, then it is appended to the result.\n-- @within MappingAndFiltering\n-- @func fun A function which will be passed each key and value as arguments, plus any extra arguments to pairmap.\n-- @tab t A table\n-- @param ... optional arguments\n-- @usage pairmap(function(k,v) return v end,{fred=10,bonzo=20}) is {10,20} _or_ {20,10}\n-- @usage pairmap(function(k,v) return {k,v},k end,{one=1,two=2}) is {one={'one',1},two={'two',2}}\nfunction tablex.pairmap(fun,t,...)\n    assert_arg_iterable(1,t)\n    fun = function_arg(1,fun)\n    local res = {}\n    for k,v in pairs(t) do\n        local rv,rk = fun(k,v,...)\n        if rk then\n            if res[rk] then\n                if type(res[rk]) == 'table' then\n                    table.insert(res[rk],rv)\n                else\n                    res[rk] = {res[rk], rv}\n                end\n            else\n                res[rk] = rv\n            end\n        else\n            res[#res+1] = rv\n        end\n    end\n    return res\nend\n\nlocal function keys_op(i,v) return i end\n\n--- return all the keys of a table in arbitrary order.\n-- @within Extraction\n-- @tab t A list-like table where the values are the keys of the input table\nfunction tablex.keys(t)\n    assert_arg_iterable(1,t)\n    return makelist(tablex.pairmap(keys_op,t))\nend\n\nlocal function values_op(i,v) return v end\n\n--- return all the values of the table in arbitrary order\n-- @within Extraction\n-- @tab t A list-like table where the values are the values of the input table\nfunction tablex.values(t)\n    assert_arg_iterable(1,t)\n    return makelist(tablex.pairmap(values_op,t))\nend\n\nlocal function index_map_op (i,v) return i,v end\n\n--- create an index map from a list-like table. The original values become keys,\n-- and the associated values are the indices into the original list.\n-- @array t a list-like table\n-- @return a map-like table\nfunction tablex.index_map (t)\n    assert_arg_indexable(1,t)\n    return makemap(tablex.pairmap(index_map_op,t))\nend\n\nlocal function set_op(i,v) return true,v end\n\n--- create a set from a list-like table. A set is a table where the original values\n-- become keys, and the associated values are all true.\n-- @array t a list-like table\n-- @return a set (a map-like table)\nfunction tablex.makeset (t)\n    assert_arg_indexable(1,t)\n    return setmetatable(tablex.pairmap(set_op,t),require('pl.Set'))\nend\n\n--- combine two tables, either as union or intersection. Corresponds to\n-- set operations for sets () but more general. Not particularly\n-- useful for list-like tables.\n-- @within Merging\n-- @tab t1 a table\n-- @tab t2 a table\n-- @bool dup true for a union, false for an intersection.\n-- @usage merge({alice=23,fred=34},{bob=25,fred=34}) is {fred=34}\n-- @usage merge({alice=23,fred=34},{bob=25,fred=34},true) is {bob=25,fred=34,alice=23}\n-- @see tablex.index_map\nfunction tablex.merge (t1,t2,dup)\n    assert_arg_iterable(1,t1)\n    assert_arg_iterable(2,t2)\n    local res = {}\n    for k,v in pairs(t1) do\n        if dup or t2[k] then res[k] = v end\n    end\n    if dup then\n      for k,v in pairs(t2) do\n        res[k] = v\n      end\n    end\n    return setmeta(res,t1,'Map')\nend\n\n--- the union of two map-like tables.\n-- If there are duplicate keys, the second table wins.\n-- @tab t1 a table\n-- @tab t2 a table\n-- @treturn tab\n-- @see tablex.merge\nfunction tablex.union(t1, t2)\n    return tablex.merge(t1, t2, true)\nend\n\n--- the intersection of two map-like tables.\n-- @tab t1 a table\n-- @tab t2 a table\n-- @treturn tab\n-- @see tablex.merge\nfunction tablex.intersection(t1, t2)\n    return tablex.merge(t1, t2, false)\nend\n\n--- a new table which is the difference of two tables.\n-- With sets (where the values are all true) this is set difference and\n-- symmetric difference depending on the third parameter.\n-- @within Merging\n-- @tab s1 a map-like table or set\n-- @tab s2 a map-like table or set\n-- @bool symm symmetric difference (default false)\n-- @return a map-like table or set\nfunction tablex.difference (s1,s2,symm)\n    assert_arg_iterable(1,s1)\n    assert_arg_iterable(2,s2)\n    local res = {}\n    for k,v in pairs(s1) do\n        if s2[k] == nil then res[k] = v end\n    end\n    if symm then\n        for k,v in pairs(s2) do\n            if s1[k] == nil then res[k] = v end\n        end\n    end\n    return setmeta(res,s1,'Map')\nend\n\n--- A table where the key\/values are the values and value counts of the table.\n-- @array t a list-like table\n-- @func cmp a function that defines equality (otherwise uses ==)\n-- @return a map-like table\n-- @see seq.count_map\nfunction tablex.count_map (t,cmp)\n    assert_arg_indexable(1,t)\n    local res,mask = {},{}\n    cmp = function_arg(2,cmp or '==')\n    local n = #t\n    for i = 1,#t do\n        local v = t[i]\n        if not mask[v] then\n            mask[v] = true\n            -- check this value against all other values\n            res[v] = 1  -- there's at least one instance\n            for j = i+1,n do\n                local w = t[j]\n                local ok = cmp(v,w)\n                if ok then\n                    res[v] = res[v] + 1\n                    mask[w] = true\n                end\n            end\n        end\n    end\n    return makemap(res)\nend\n\n--- filter an array's values using a predicate function\n-- @within MappingAndFiltering\n-- @array t a list-like table\n-- @func pred a boolean function\n-- @param arg optional argument to be passed as second argument of the predicate\nfunction tablex.filter (t,pred,arg)\n    assert_arg_indexable(1,t)\n    pred = function_arg(2,pred)\n    local res,k = {},1\n    for i = 1,#t do\n        local v = t[i]\n        if pred(v,arg) then\n            res[k] = v\n            k = k + 1\n        end\n    end\n    return setmeta(res,t,'List')\nend\n\n--- return a table where each element is a table of the ith values of an arbitrary\n-- number of tables. It is equivalent to a matrix transpose.\n-- @within Merging\n-- @usage zip({10,20,30},{100,200,300}) is {{10,100},{20,200},{30,300}}\n-- @array ... arrays to be zipped\nfunction tablex.zip(...)\n    return tablex.mapn(function(...) return {...} end,...)\nend\n\nlocal _copy\nfunction _copy (dest,src,idest,isrc,nsrc,clean_tail)\n    idest = idest or 1\n    isrc = isrc or 1\n    local iend\n    if not nsrc then\n        nsrc = #src\n        iend = #src\n    else\n        iend = isrc + min(nsrc-1,#src-isrc)\n    end\n    if dest == src then -- special case\n        if idest > isrc and iend >= idest then -- overlapping ranges\n            src = tablex.sub(src,isrc,nsrc)\n            isrc = 1; iend = #src\n        end\n    end\n    for i = isrc,iend do\n        dest[idest] = src[i]\n        idest = idest + 1\n    end\n    if clean_tail then\n        tablex.clear(dest,idest)\n    end\n    return dest\nend\n\n--- copy an array into another one, clearing `dest` after `idest+nsrc`, if necessary.\n-- @within Copying\n-- @array dest a list-like table\n-- @array src a list-like table\n-- @int[opt=1] idest where to start copying values into destination\n-- @int[opt=1] isrc where to start copying values from source\n-- @int[opt=#src] nsrc number of elements to copy from source\nfunction tablex.icopy (dest,src,idest,isrc,nsrc)\n    assert_arg_indexable(1,dest)\n    assert_arg_indexable(2,src)\n    return _copy(dest,src,idest,isrc,nsrc,true)\nend\n\n--- copy an array into another one.\n-- @within Copying\n-- @array dest a list-like table\n-- @array src a list-like table\n-- @int[opt=1] idest where to start copying values into destination\n-- @int[opt=1] isrc where to start copying values from source\n-- @int[opt=#src] nsrc number of elements to copy from source\nfunction tablex.move (dest,src,idest,isrc,nsrc)\n    assert_arg_indexable(1,dest)\n    assert_arg_indexable(2,src)\n    return _copy(dest,src,idest,isrc,nsrc,false)\nend\n\nfunction tablex._normalize_slice(self,first,last)\n  local sz = #self\n  if not first then first=1 end\n  if first<0 then first=sz+first+1 end\n  -- make the range _inclusive_!\n  if not last then last=sz end\n  if last < 0 then last=sz+1+last end\n  return first,last\nend\n\n--- Extract a range from a table, like  'string.sub'.\n-- If first or last are negative then they are relative to the end of the list\n-- eg. sub(t,-2) gives last 2 entries in a list, and\n-- sub(t,-4,-2) gives from -4th to -2nd\n-- @within Extraction\n-- @array t a list-like table\n-- @int first An index\n-- @int last An index\n-- @return a new List\nfunction tablex.sub(t,first,last)\n    assert_arg_indexable(1,t)\n    first,last = tablex._normalize_slice(t,first,last)\n    local res={}\n    for i=first,last do append(res,t[i]) end\n    return setmeta(res,t,'List')\nend\n\n--- set an array range to a value. If it's a function we use the result\n-- of applying it to the indices.\n-- @array t a list-like table\n-- @param val a value\n-- @int[opt=1] i1 start range\n-- @int[opt=#t] i2 end range\nfunction tablex.set (t,val,i1,i2)\n    assert_arg_indexable(1,t)\n    i1,i2 = i1 or 1,i2 or #t\n    if types.is_callable(val) then\n        for i = i1,i2 do\n            t[i] = val(i)\n        end\n    else\n        for i = i1,i2 do\n            t[i] = val\n        end\n    end\nend\n\n--- create a new array of specified size with initial value.\n-- @int n size\n-- @param val initial value (can be `nil`, but don't expect `#` to work!)\n-- @return the table\nfunction tablex.new (n,val)\n    local res = {}\n    tablex.set(res,val,1,n)\n    return res\nend\n\n--- clear out the contents of a table.\n-- @array t a list\n-- @param istart optional start position\nfunction tablex.clear(t,istart)\n    istart = istart or 1\n    for i = istart,#t do remove(t) end\nend\n\n--- insert values into a table.\n-- similar to `table.insert` but inserts values from given table `values`,\n-- not the object itself, into table `t` at position `pos`.\n-- @within Copying\n-- @array t the list\n-- @int[opt] position (default is at end)\n-- @array values\nfunction tablex.insertvalues(t, ...)\n    assert_arg(1,t,'table')\n    local pos, values\n    if select('#', ...) == 1 then\n        pos,values = #t+1, ...\n    else\n        pos,values = ...\n    end\n    if #values > 0 then\n        for i=#t,pos,-1 do\n            t[i+#values] = t[i]\n        end\n        local offset = 1 - pos\n        for i=pos,pos+#values-1 do\n            t[i] = values[i + offset]\n        end\n    end\n    return t\nend\n\n--- remove a range of values from a table.\n-- End of range may be negative.\n-- @array t a list-like table\n-- @int i1 start index\n-- @int i2 end index\n-- @return the table\nfunction tablex.removevalues (t,i1,i2)\n    assert_arg(1,t,'table')\n    i1,i2 = tablex._normalize_slice(t,i1,i2)\n    for i = i1,i2 do\n        remove(t,i1)\n    end\n    return t\nend\n\nlocal _find\n_find = function (t,value,tables)\n    for k,v in pairs(t) do\n        if v == value then return k end\n    end\n    for k,v in pairs(t) do\n        if not tables[v] and type(v) == 'table' then\n            tables[v] = true\n            local res = _find(v,value,tables)\n            if res then\n                res = tostring(res)\n                if type(k) ~= 'string' then\n                    return '['..k..']'..res\n                else\n                    return k..'.'..res\n                end\n            end\n        end\n    end\nend\n\n--- find a value in a table by recursive search.\n-- @within Finding\n-- @tab t the table\n-- @param value the value\n-- @array[opt] exclude any tables to avoid searching\n-- @return a fieldspec, e.g. 'a.b' or 'math.sin'\n-- @usage search(_G,math.sin,{package.path}) == 'math.sin'\nfunction tablex.search (t,value,exclude)\n    assert_arg_iterable(1,t)\n    local tables = {[t]=true}\n    if exclude then\n        for _,v in pairs(exclude) do tables[v] = true end\n    end\n    return _find(t,value,tables)\nend\n\n--- return an iterator to a table sorted by its keys\n-- @within Iterating\n-- @tab t the table\n-- @func f an optional comparison function (f(x,y) is true if x < y)\n-- @usage for k,v in tablex.sort(t) do print(k,v) end\n-- @return an iterator to traverse elements sorted by the keys\nfunction tablex.sort(t,f)\n    local keys = {}\n    for k in pairs(t) do keys[#keys + 1] = k end\n    tsort(keys,f)\n    local i = 0\n    return function()\n        i = i + 1\n        return keys[i], t[keys[i]]\n    end\nend\n\n--- return an iterator to a table sorted by its values\n-- @within Iterating\n-- @tab t the table\n-- @func f an optional comparison function (f(x,y) is true if x < y)\n-- @usage for k,v in tablex.sortv(t) do print(k,v) end\n-- @return an iterator to traverse elements sorted by the values\nfunction tablex.sortv(t,f)\n    f = function_arg(2, f or '<')\n    local keys = {}\n    for k in pairs(t) do keys[#keys + 1] = k end\n    tsort(keys,function(x, y) return f(t[x], t[y]) end)\n    local i = 0\n    return function()\n        i = i + 1\n        return keys[i], t[keys[i]]\n    end\nend\n\n--- modifies a table to be read only.\n-- This only offers weak protection. Tables can still be modified with\n-- `table.insert` and `rawset`.\n--\n-- *NOTE*: for Lua 5.1 length, pairs and ipairs will not work, since the\n-- equivalent metamethods are only available in Lua 5.2 and newer.\n-- @tab t the table\n-- @return the table read only (a proxy).\nfunction tablex.readonly(t)\n    local mt = {\n        __index=t,\n        __newindex=function(t, k, v) error(\"Attempt to modify read-only table\", 2) end,\n        __pairs=function() return pairs(t) end,\n        __ipairs=function() return ipairs(t) end,\n        __len=function() return #t end,\n        __metatable=false\n    }\n    return setmetatable({}, mt)\nend\n\nreturn tablex"},{"name":"\/Users\/nascarsayan\/Code\/github.com\/nascarsayan\/sqids-lua\/lua_modules\/share\/lua\/5.4\/pl\/types.lua","coverage":[null,null,null,null,null,0,0,0,0,null,null,null,0,0,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,0,0,0,0,0,0,0,0,null,null,0,null,null,0,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,0,0,0,0,null,0,null,null,null,null,21,0,null,null,null,null,null,null,null,null,null,null,null,0,6,6,0,null,null,null,null,null,null,null,null,null,null,null,0,15,15,0,null,null,null,null,null,null,null,null,null,null,0,0,0,0,null,null,null,0,null,0,null,null,0,0,0,null,null,0,0,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,0,null,0,0,0,0,0,null,0,null,null,null,0],"source":"---- Dealing with Detailed Type Information\n\n-- Dependencies `pl.utils`\n-- @module pl.types\n\nlocal utils = require 'pl.utils'\nlocal math_ceil = math.ceil\nlocal assert_arg = utils.assert_arg\nlocal types = {}\n\n--- is the object either a function or a callable object?.\n-- @param obj Object to check.\nfunction types.is_callable (obj)\n    return type(obj) == 'function' or getmetatable(obj) and getmetatable(obj).__call and true\nend\n\n--- is the object of the specified type?.\n-- If the type is a string, then use type, otherwise compare with metatable.\n--\n-- NOTE: this function is imported from `utils.is_type`.\n-- @param obj An object to check\n-- @param tp The expected type\n-- @function is_type\n-- @see utils.is_type\ntypes.is_type = utils.is_type\n\nlocal fileMT = getmetatable(io.stdout)\n\n--- a string representation of a type.\n-- For tables and userdata with metatables, we assume that the metatable has a `_name`\n-- field. If the field is not present it will return 'unknown table' or\n-- 'unknown userdata'.\n-- Lua file objects return the type 'file'.\n-- @param obj an object\n-- @return a string like 'number', 'table', 'file' or 'List'\nfunction types.type (obj)\n    local t = type(obj)\n    if t == 'table' or t == 'userdata' then\n        local mt = getmetatable(obj)\n        if mt == fileMT then\n            return 'file'\n        elseif mt == nil then\n            return t\n        else\n            -- TODO: the \"unknown\" is weird, it should just return the type\n            return mt._name or \"unknown \"..t\n        end\n    else\n        return t\n    end\nend\n\n--- is this number an integer?\n-- @param x a number\n-- @raise error if x is not a number\n-- @return boolean\nfunction types.is_integer (x)\n    return math_ceil(x)==x\nend\n\n--- Check if the object is \"empty\".\n-- An object is considered empty if it is:\n--\n-- - `nil`\n-- - a table without any items (key-value pairs or indexes)\n-- - a string with no content (\"\")\n-- - not a nil\/table\/string\n-- @param o The object to check if it is empty.\n-- @param ignore_spaces If the object is a string and this is true the string is\n-- considered empty if it only contains spaces.\n-- @return `true` if the object is empty, otherwise a falsy value.\nfunction types.is_empty(o, ignore_spaces)\n    if o == nil then\n        return true\n    elseif type(o) == \"table\" then\n        return next(o) == nil\n    elseif type(o) == \"string\" then\n        return o == \"\" or (not not ignore_spaces and (not not o:find(\"^%s+$\")))\n    else\n        return true\n    end\nend\n\nlocal function check_meta (val)\n    if type(val) == 'table' then return true end\n    return getmetatable(val)\nend\n\n--- is an object 'array-like'?\n-- An object is array like if:\n--\n-- - it is a table, or\n-- - it has a metatable with `__len` and `__index` methods\n--\n-- NOTE: since `__len` is 5.2+, on 5.1 is usually returns `false` for userdata\n-- @param val any value.\n-- @return `true` if the object is array-like, otherwise a falsy value.\nfunction types.is_indexable (val)\n    local mt = check_meta(val)\n    if mt == true then return true end\n    return mt and mt.__len and mt.__index and true\nend\n\n--- can an object be iterated over with `pairs`?\n-- An object is iterable if:\n--\n-- - it is a table, or\n-- - it has a metatable with a `__pairs` meta method\n--\n-- NOTE: since `__pairs` is 5.2+, on 5.1 is usually returns `false` for userdata\n-- @param val any value.\n-- @return `true` if the object is iterable, otherwise a falsy value.\nfunction types.is_iterable (val)\n    local mt = check_meta(val)\n    if mt == true then return true end\n    return mt and mt.__pairs and true\nend\n\n--- can an object accept new key\/pair values?\n-- An object is iterable if:\n--\n-- - it is a table, or\n-- - it has a metatable with a `__newindex` meta method\n--\n-- @param val any value.\n-- @return `true` if the object is writeable, otherwise a falsy value.\nfunction types.is_writeable (val)\n    local mt = check_meta(val)\n    if mt == true then return true end\n    return mt and mt.__newindex and true\nend\n\n-- Strings that should evaluate to true.   -- TODO: add on\/off ???\nlocal trues = { yes=true, y=true, [\"true\"]=true, t=true, [\"1\"]=true }\n-- Conditions types should evaluate to true.\nlocal true_types = {\n    boolean=function(o, true_strs, check_objs) return o end,\n    string=function(o, true_strs, check_objs)\n        o = o:lower()\n        if trues[o] then\n            return true\n        end\n        -- Check alternative user provided strings.\n        for _,v in ipairs(true_strs or {}) do\n            if type(v) == \"string\" and o == v:lower() then\n                return true\n            end\n        end\n        return false\n    end,\n    number=function(o, true_strs, check_objs) return o ~= 0 end,\n    table=function(o, true_strs, check_objs) if check_objs and next(o) ~= nil then return true end return false end\n}\n--- Convert to a boolean value.\n-- True values are:\n--\n-- * boolean: true.\n-- * string: 'yes', 'y', 'true', 't', '1' or additional strings specified by `true_strs`.\n-- * number: Any non-zero value.\n-- * table: Is not empty and `check_objs` is true.\n-- * everything else: Is not `nil` and `check_objs` is true.\n--\n-- @param o The object to evaluate.\n-- @param[opt] true_strs optional Additional strings that when matched should evaluate to true. Comparison is case insensitive.\n-- This should be a List of strings. E.g. \"ja\" to support German.\n-- @param[opt] check_objs True if objects should be evaluated.\n-- @return true if the input evaluates to true, otherwise false.\nfunction types.to_bool(o, true_strs, check_objs)\n    local true_func\n    if true_strs then\n        assert_arg(2, true_strs, \"table\")\n    end\n    true_func = true_types[type(o)]\n    if true_func then\n        return true_func(o, true_strs, check_objs)\n    elseif check_objs and o ~= nil then\n        return true\n    end\n    return false\nend\n\n\nreturn types"},{"name":"\/Users\/nascarsayan\/Code\/github.com\/nascarsayan\/sqids-lua\/lua_modules\/share\/lua\/5.4\/pl\/utils.lua","coverage":[null,null,null,null,null,null,null,0,0,0,0,0,0,0,0,0,0,null,0,0,null,null,0,null,null,0,0,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,0,0,0,null,null,null,null,null,null,0,0,0,null,null,null,null,0,null,0,0,0,null,0,null,null,null,0,0,null,0,null,null,0,null,null,null,null,0,0,0,0,0,null,0,0,0,0,0,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,0,0,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,0,null,0,0,0,null,0,0,0,null,0,null,null,null,null,0,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,0,0,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,513,0,null,513,0,null,513,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,null,null,0,null,0,0,0,0,null,null,null,null,0,0,null,0,0,0,null,0,0,null,null,0,0,0,null,0,0,null,0,0,null,null,null,0,0,null,null,0,0,null,0,null,null,0,null,null,0,0,0,0,null,null,0,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,6,6,6,null,0,0,0,0,0,0,0,0,0,0,0,0,0,0,null,0,null,null,0,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,501,null,null,null,null,null,null,null,null,null,null,null,0,0,0,0,null,null,0,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,0,0,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,0,0,0,0,0,0,0,0,null,null,0,null,0,null,null,null,null,null,null,null,null,null,0,0,0,0,0,0,0,0,0,null,null,0,null,0,null,null,null,null,null,null,0,0,0,0,0,0,0,null,0,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,null,0,0,0,null,0,null,0,0,0,0,0,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,0,0,0,null,null,0,null,null,0,0,null,null,null,null,null,0,null,null,null,null,0,null,0,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,0,0,0,0,0,0,0,null,0,null,null,null,null,null,null,null,null,0,12,12,null,null,null,null,null,null,null,null,null,null,0,0,0,0,0,null,0,0,0,0,0,0,null,0,null,null,0,0,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,0,0,0,0,null,0,null,null,null,null,null,null,null,null,null,0,0,null,null,null,0,0,0,0,0,null,0,null,0,0,0,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,null,null,null,null,null,null,null,null,null,null,null,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,null,0,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,0,null,null,0,0,null,null,0,0,0,0,0,0,0,null,0,null,null,0,null,0,0,null,0,null,0,null,null,null,0,null,null,null,null,null,0,null,null],"source":"--- Generally useful routines.\n-- See  @{01-introduction.md.Generally_useful_functions|the Guide}.\n--\n-- Dependencies: `pl.compat`, all exported fields and functions from\n-- `pl.compat` are also available in this module.\n--\n-- @module pl.utils\nlocal format = string.format\nlocal compat = require 'pl.compat'\nlocal stdout = io.stdout\nlocal append = table.insert\nlocal concat = table.concat\nlocal _unpack = table.unpack  -- always injected by 'compat'\nlocal find = string.find\nlocal sub = string.sub\nlocal next = next\nlocal floor = math.floor\n\nlocal is_windows = compat.is_windows\nlocal err_mode = 'default'\nlocal raise\nlocal operators\nlocal _function_factories = {}\n\n\nlocal utils = { _VERSION = \"1.13.1\" }\nfor k, v in pairs(compat) do utils[k] = v  end\n\n--- Some standard patterns\n-- @table patterns\nutils.patterns = {\n    FLOAT = '[%+%-%d]%d*%.?%d*[eE]?[%+%-]?%d*', -- floating point number\n    INTEGER = '[+%-%d]%d*',                     -- integer number\n    IDEN = '[%a_][%w_]*',                       -- identifier\n    FILE = '[%a%.\\\\][:%][%w%._%-\\\\]*',          -- file\n}\n\n\n--- Standard meta-tables as used by other Penlight modules\n-- @table stdmt\n-- @field List the List metatable\n-- @field Map the Map metatable\n-- @field Set the Set metatable\n-- @field MultiMap the MultiMap metatable\nutils.stdmt = {\n    List = {_name='List'},\n    Map = {_name='Map'},\n    Set = {_name='Set'},\n    MultiMap = {_name='MultiMap'},\n}\n\n\n--- pack an argument list into a table.\n-- @param ... any arguments\n-- @return a table with field `n` set to the length\n-- @function utils.pack\n-- @see compat.pack\n-- @see utils.npairs\n-- @see utils.unpack\nutils.pack = table.pack  -- added here to be symmetrical with unpack\n\n--- unpack a table and return its contents.\n--\n-- NOTE: this implementation differs from the Lua implementation in the way\n-- that this one DOES honor the `n` field in the table `t`, such that it is 'nil-safe'.\n-- @param t table to unpack\n-- @param[opt] i index from which to start unpacking, defaults to 1\n-- @param[opt] j index of the last element to unpack, defaults to `t.n` or else `#t`\n-- @return multiple return values from the table\n-- @function utils.unpack\n-- @see compat.unpack\n-- @see utils.pack\n-- @see utils.npairs\n-- @usage\n-- local t = table.pack(nil, nil, nil, 4)\n-- local a, b, c, d = table.unpack(t)   -- this `unpack` is NOT nil-safe, so d == nil\n--\n-- local a, b, c, d = utils.unpack(t)   -- this is nil-safe, so d == 4\nfunction utils.unpack(t, i, j)\n    return _unpack(t, i or 1, j or t.n or #t)\nend\n\n--- print an arbitrary number of arguments using a format.\n-- Output will be sent to `stdout`.\n-- @param fmt The format (see `string.format`)\n-- @param ... Extra arguments for format\nfunction utils.printf(fmt, ...)\n    utils.assert_string(1, fmt)\n    utils.fprintf(stdout, fmt, ...)\nend\n\n--- write an arbitrary number of arguments to a file using a format.\n-- @param f File handle to write to.\n-- @param fmt The format (see `string.format`).\n-- @param ... Extra arguments for format\nfunction utils.fprintf(f,fmt,...)\n    utils.assert_string(2,fmt)\n    f:write(format(fmt,...))\nend\n\ndo\n    local function import_symbol(T,k,v,libname)\n        local key = rawget(T,k)\n        -- warn about collisions!\n        if key and k ~= '_M' and k ~= '_NAME' and k ~= '_PACKAGE' and k ~= '_VERSION' then\n            utils.fprintf(io.stderr,\"warning: '%s.%s' will not override existing symbol\\n\",libname,k)\n            return\n        end\n        rawset(T,k,v)\n    end\n\n    local function lookup_lib(T,t)\n        for k,v in pairs(T) do\n            if v == t then return k end\n        end\n        return '?'\n    end\n\n    local already_imported = {}\n\n    --- take a table and 'inject' it into the local namespace.\n    -- @param t The table (table), or module name (string), defaults to this `utils` module table\n    -- @param T An optional destination table (defaults to callers environment)\n    function utils.import(t,T)\n        T = T or _G\n        t = t or utils\n        if type(t) == 'string' then\n            t = require (t)\n        end\n        local libname = lookup_lib(T,t)\n        if already_imported[t] then return end\n        already_imported[t] = libname\n        for k,v in pairs(t) do\n            import_symbol(T,k,v,libname)\n        end\n    end\nend\n\n--- return either of two values, depending on a condition.\n-- @param cond A condition\n-- @param value1 Value returned if cond is truthy\n-- @param value2 Value returned if cond is falsy\nfunction utils.choose(cond, value1, value2)\n    return cond and value1 or value2\nend\n\n--- convert an array of values to strings.\n-- @param t a list-like table\n-- @param[opt] temp (table) buffer to use, otherwise allocate\n-- @param[opt] tostr custom tostring function, called with (value,index). Defaults to `tostring`.\n-- @return the converted buffer\nfunction utils.array_tostring (t,temp,tostr)\n    temp, tostr = temp or {}, tostr or tostring\n    for i = 1,#t do\n        temp[i] = tostr(t[i],i)\n    end\n    return temp\nend\n\n\n\n--- is the object of the specified type?\n-- If the type is a string, then use type, otherwise compare with metatable\n-- @param obj An object to check\n-- @param tp String of what type it should be\n-- @return boolean\n-- @usage utils.is_type(\"hello world\", \"string\")   --> true\n-- -- or check metatable\n-- local my_mt = {}\n-- local my_obj = setmetatable(my_obj, my_mt)\n-- utils.is_type(my_obj, my_mt)  --> true\nfunction utils.is_type (obj,tp)\n    if type(tp) == 'string' then return type(obj) == tp end\n    local mt = getmetatable(obj)\n    return tp == mt\nend\n\n\n\n--- an iterator with indices, similar to `ipairs`, but with a range.\n-- This is a nil-safe index based iterator that will return `nil` when there\n-- is a hole in a list. To be safe ensure that table `t.n` contains the length.\n-- @tparam table t the table to iterate over\n-- @tparam[opt=1] integer i_start start index\n-- @tparam[opt=t.n or #t] integer i_end end index\n-- @tparam[opt=1] integer step step size\n-- @treturn integer index\n-- @treturn any value at index (which can be `nil`!)\n-- @see utils.pack\n-- @see utils.unpack\n-- @usage\n-- local t = utils.pack(nil, 123, nil)  -- adds an `n` field when packing\n--\n-- for i, v in utils.npairs(t, 2) do  -- start at index 2\n--   t[i] = tostring(t[i])\n-- end\n--\n-- -- t = { n = 3, [2] = \"123\", [3] = \"nil\" }\nfunction utils.npairs(t, i_start, i_end, step)\n  step = step or 1\n  if step == 0 then\n    error(\"iterator step-size cannot be 0\", 2)\n  end\n  local i = (i_start or 1) - step\n  i_end = i_end or t.n or #t\n  if step < 0 then\n    return function()\n      i = i + step\n      if i < i_end then\n        return nil\n      end\n      return i, t[i]\n    end\n\n  else\n    return function()\n      i = i + step\n      if i > i_end then\n        return nil\n      end\n      return i, t[i]\n    end\n  end\nend\n\n\n\n--- an iterator over all non-integer keys (inverse of `ipairs`).\n-- It will skip any key that is an integer number, so negative indices or an\n-- array with holes will not return those either (so it returns slightly less than\n-- 'the inverse of `ipairs`').\n--\n-- This uses `pairs` under the hood, so any value that is iterable using `pairs`\n-- will work with this function.\n-- @tparam table t the table to iterate over\n-- @treturn key\n-- @treturn value\n-- @usage\n-- local t = {\n--   \"hello\",\n--   \"world\",\n--   hello = \"hallo\",\n--   world = \"Welt\",\n-- }\n--\n-- for k, v in utils.kpairs(t) do\n--   print(\"German: \", v)\n-- end\n--\n-- -- output;\n-- -- German: hallo\n-- -- German: Welt\nfunction utils.kpairs(t)\n  local index\n  return function()\n    local value\n    while true do\n      index, value = next(t, index)\n      if type(index) ~= \"number\" or floor(index) ~= index then\n        break\n      end\n    end\n    return index, value\n  end\nend\n\n\n\n--- Error handling\n-- @section Error-handling\n\n--- assert that the given argument is in fact of the correct type.\n-- @param n argument index\n-- @param val the value\n-- @param tp the type\n-- @param verify an optional verification function\n-- @param msg an optional custom message\n-- @param lev optional stack position for trace, default 2\n-- @return the validated value\n-- @raise if `val` is not the correct type\n-- @usage\n-- local param1 = assert_arg(1,\"hello\",'table')  --> error: argument 1 expected a 'table', got a 'string'\n-- local param4 = assert_arg(4,'!@#$%^&*','string',path.isdir,'not a directory')\n--      --> error: argument 4: '!@#$%^&*' not a directory\nfunction utils.assert_arg (n,val,tp,verify,msg,lev)\n    if type(val) ~= tp then\n        error((\"argument %d expected a '%s', got a '%s'\"):format(n,tp,type(val)),lev or 2)\n    end\n    if verify and not verify(val) then\n        error((\"argument %d: '%s' %s\"):format(n,val,msg),lev or 2)\n    end\n    return val\nend\n\n--- creates an Enum or constants lookup table for improved error handling.\n-- This helps prevent magic strings in code by throwing errors for accessing\n-- non-existing values, and\/or converting strings\/identifiers to other values.\n--\n-- Calling on the object does the same, but returns a soft error; `nil + err`, if\n-- the call is succesful (the key exists), it will return the value.\n--\n-- When calling with varargs or an array the values will be equal to the keys.\n-- The enum object is read-only.\n-- @tparam table|vararg ... the input for the Enum. If varargs or an array then the\n-- values in the Enum will be equal to the names (must be strings), if a hash-table\n-- then values remain (any type), and the keys must be strings.\n-- @return Enum object (read-only table\/object)\n-- @usage -- Enum access at runtime\n-- local obj = {}\n-- obj.MOVEMENT = utils.enum(\"FORWARD\", \"REVERSE\", \"LEFT\", \"RIGHT\")\n--\n-- if current_movement == obj.MOVEMENT.FORWARD then\n--   -- do something\n--\n-- elseif current_movement == obj.MOVEMENT.REVERES then\n--   -- throws error due to typo 'REVERES', so a silent mistake becomes a hard error\n--   -- \"'REVERES' is not a valid value (expected one of: 'FORWARD', 'REVERSE', 'LEFT', 'RIGHT')\"\n--\n-- end\n-- @usage -- standardized error codes\n-- local obj = {\n--   ERR = utils.enum {\n--     NOT_FOUND = \"the item was not found\",\n--     OUT_OF_BOUNDS = \"the index is outside the allowed range\"\n--   },\n--\n--   some_method = function(self)\n--     return self.ERR.OUT_OF_BOUNDS\n--   end,\n-- }\n--\n-- local result, err = obj:some_method()\n-- if not result then\n--   if err == obj.ERR.NOT_FOUND then\n--     -- check on error code, not magic strings\n--\n--   else\n--     -- return the error description, contained in the constant\n--     return nil, \"error: \"..err  -- \"error: the index is outside the allowed range\"\n--   end\n-- end\n-- @usage -- validating\/converting user-input\n-- local color = \"purple\"\n-- local ansi_colors = utils.enum {\n--   black     = 30,\n--   red       = 31,\n--   green     = 32,\n-- }\n-- local color_code, err = ansi_colors(color) -- calling on the object, returns the value from the enum\n-- if not color_code then\n--   print(\"bad 'color', \" .. err)\n--   -- \"bad 'color', 'purple' is not a valid value (expected one of: 'black', 'red', 'green')\"\n--   os.exit(1)\n-- end\nfunction utils.enum(...)\n  local first = select(1, ...)\n  local enum = {}\n  local lst\n\n  if type(first) ~= \"table\" then\n    -- vararg with strings\n    lst = utils.pack(...)\n    for i, value in utils.npairs(lst) do\n      utils.assert_arg(i, value, \"string\")\n      enum[value] = value\n    end\n\n  else\n    -- table\/array with values\n    utils.assert_arg(1, first, \"table\")\n    lst = {}\n    -- first add array part\n    for i, value in ipairs(first) do\n      if type(value) ~= \"string\" then\n        error((\"expected 'string' but got '%s' at index %d\"):format(type(value), i), 2)\n      end\n      lst[i] = value\n      enum[value] = value\n    end\n    -- add key-ed part\n    for key, value in utils.kpairs(first) do\n      if type(key) ~= \"string\" then\n        error((\"expected key to be 'string' but got '%s'\"):format(type(key)), 2)\n      end\n      if enum[key] then\n        error((\"duplicate entry in array and hash part: '%s'\"):format(key), 2)\n      end\n      enum[key] = value\n      lst[#lst+1] = key\n    end\n  end\n\n  if not lst[1] then\n    error(\"expected at least 1 entry\", 2)\n  end\n\n  local valid = \"(expected one of: '\" .. concat(lst, \"', '\") .. \"')\"\n  setmetatable(enum, {\n    __index = function(self, key)\n      error((\"'%s' is not a valid value %s\"):format(tostring(key), valid), 2)\n    end,\n    __newindex = function(self, key, value)\n      error(\"the Enum object is read-only\", 2)\n    end,\n    __call = function(self, key)\n      if type(key) == \"string\" then\n        local v = rawget(self, key)\n        if v ~= nil then\n          return v\n        end\n      end\n      return nil, (\"'%s' is not a valid value %s\"):format(tostring(key), valid)\n    end\n  })\n\n  return enum\nend\n\n\n--- process a function argument.\n-- This is used throughout Penlight and defines what is meant by a function:\n-- Something that is callable, or an operator string as defined by <code>pl.operator<\/code>,\n-- such as '>' or '#'. If a function factory has been registered for the type, it will\n-- be called to get the function.\n-- @param idx argument index\n-- @param f a function, operator string, or callable object\n-- @param msg optional error message\n-- @return a callable\n-- @raise if idx is not a number or if f is not callable\nfunction utils.function_arg (idx,f,msg)\n    utils.assert_arg(1,idx,'number')\n    local tp = type(f)\n    if tp == 'function' then return f end  -- no worries!\n    -- ok, a string can correspond to an operator (like '==')\n    if tp == 'string' then\n        if not operators then operators = require 'pl.operator'.optable end\n        local fn = operators[f]\n        if fn then return fn end\n        local fn, err = utils.string_lambda(f)\n        if not fn then error(err..': '..f) end\n        return fn\n    elseif tp == 'table' or tp == 'userdata' then\n        local mt = getmetatable(f)\n        if not mt then error('not a callable object',2) end\n        local ff = _function_factories[mt]\n        if not ff then\n            if not mt.__call then error('not a callable object',2) end\n            return f\n        else\n            return ff(f) -- we have a function factory for this type!\n        end\n    end\n    if not msg then msg = \" must be callable\" end\n    if idx > 0 then\n        error(\"argument \"..idx..\": \"..msg,2)\n    else\n        error(msg,2)\n    end\nend\n\n\n--- assert the common case that the argument is a string.\n-- @param n argument index\n-- @param val a value that must be a string\n-- @return the validated value\n-- @raise val must be a string\n-- @usage\n-- local val = 42\n-- local param2 = utils.assert_string(2, val) --> error: argument 2 expected a 'string', got a 'number'\nfunction utils.assert_string (n, val)\n    return utils.assert_arg(n,val,'string',nil,nil,3)\nend\n\n--- control the error strategy used by Penlight.\n-- This is a global setting that controls how `utils.raise` behaves:\n--\n-- - 'default': return `nil + error` (this is the default)\n-- - 'error': throw a Lua error\n-- - 'quit': exit the program\n--\n-- @param mode either 'default', 'quit'  or 'error'\n-- @see utils.raise\nfunction utils.on_error (mode)\n    mode = tostring(mode)\n    if ({['default'] = 1, ['quit'] = 2, ['error'] = 3})[mode] then\n      err_mode = mode\n    else\n      -- fail loudly\n      local err = \"Bad argument expected string; 'default', 'quit', or 'error'. Got '\"..tostring(mode)..\"'\"\n      if err_mode == 'default' then\n        error(err, 2)  -- even in 'default' mode fail loud in this case\n      end\n      raise(err)\n    end\nend\n\n--- used by Penlight functions to return errors. Its global behaviour is controlled\n-- by `utils.on_error`.\n-- To use this function you MUST use it in conjunction with `return`, since it might\n-- return `nil + error`.\n-- @param err the error string.\n-- @see utils.on_error\n-- @usage\n-- if some_condition then\n--   return utils.raise(\"some condition was not met\")  -- MUST use 'return'!\n-- end\nfunction utils.raise (err)\n    if err_mode == 'default' then\n        return nil, err\n    elseif err_mode == 'quit' then\n        return utils.quit(err)\n    else\n        error(err, 2)\n    end\nend\nraise = utils.raise\n\n\n\n--- File handling\n-- @section files\n\n--- return the contents of a file as a string\n-- @param filename The file path\n-- @param is_bin open in binary mode\n-- @return file contents\nfunction utils.readfile(filename,is_bin)\n    local mode = is_bin and 'b' or ''\n    utils.assert_string(1,filename)\n    local f,open_err = io.open(filename,'r'..mode)\n    if not f then return raise (open_err) end\n    local res,read_err = f:read('*a')\n    f:close()\n    if not res then\n        -- Errors in io.open have \"filename: \" prefix,\n        -- error in file:read don't, add it.\n        return raise (filename..\": \"..read_err)\n    end\n    return res\nend\n\n--- write a string to a file\n-- @param filename The file path\n-- @param str The string\n-- @param is_bin open in binary mode\n-- @return true or nil\n-- @return error message\n-- @raise error if filename or str aren't strings\nfunction utils.writefile(filename,str,is_bin)\n    local mode = is_bin and 'b' or ''\n    utils.assert_string(1,filename)\n    utils.assert_string(2,str)\n    local f,err = io.open(filename,'w'..mode)\n    if not f then return raise(err) end\n    local ok, write_err = f:write(str)\n    f:close()\n    if not ok then\n        -- Errors in io.open have \"filename: \" prefix,\n        -- error in file:write don't, add it.\n        return raise (filename..\": \"..write_err)\n    end\n    return true\nend\n\n--- return the contents of a file as a list of lines\n-- @param filename The file path\n-- @return file contents as a table\n-- @raise error if filename is not a string\nfunction utils.readlines(filename)\n    utils.assert_string(1,filename)\n    local f,err = io.open(filename,'r')\n    if not f then return raise(err) end\n    local res = {}\n    for line in f:lines() do\n        append(res,line)\n    end\n    f:close()\n    return res\nend\n\n--- OS functions\n-- @section OS-functions\n\n--- execute a shell command and return the output.\n-- This function redirects the output to tempfiles and returns the content of those files.\n-- @param cmd a shell command\n-- @param bin boolean, if true, read output as binary file\n-- @return true if successful\n-- @return actual return code\n-- @return stdout output (string)\n-- @return errout output (string)\nfunction utils.executeex(cmd, bin)\n    local outfile = os.tmpname()\n    local errfile = os.tmpname()\n\n    if is_windows and not outfile:find(':') then\n        outfile = os.getenv('TEMP')..outfile\n        errfile = os.getenv('TEMP')..errfile\n    end\n    cmd = cmd .. \" > \" .. utils.quote_arg(outfile) .. \" 2> \" .. utils.quote_arg(errfile)\n\n    local success, retcode = utils.execute(cmd)\n    local outcontent = utils.readfile(outfile, bin)\n    local errcontent = utils.readfile(errfile, bin)\n    os.remove(outfile)\n    os.remove(errfile)\n    return success, retcode, (outcontent or \"\"), (errcontent or \"\")\nend\n\n--- Quote and escape an argument of a command.\n-- Quotes a single (or list of) argument(s) of a command to be passed\n-- to `os.execute`, `pl.utils.execute` or `pl.utils.executeex`.\n-- @param argument (string or table\/list) the argument to quote. If a list then\n-- all arguments in the list will be returned as a single string quoted.\n-- @return quoted and escaped argument.\n-- @usage\n-- local options = utils.quote_arg {\n--     \"-lluacov\",\n--     \"-e\",\n--     \"utils = print(require('pl.utils')._VERSION\",\n-- }\n-- -- returns: -lluacov -e 'utils = print(require('\\''pl.utils'\\'')._VERSION'\nfunction utils.quote_arg(argument)\n    if type(argument) == \"table\" then\n        -- encode an entire table\n        local r = {}\n        for i, arg in ipairs(argument) do\n            r[i] = utils.quote_arg(arg)\n        end\n\n        return concat(r, \" \")\n    end\n    -- only a single argument\n    if is_windows then\n        if argument == \"\" or argument:find('[ \\f\\t\\v]') then\n            -- Need to quote the argument.\n            -- Quotes need to be escaped with backslashes;\n            -- additionally, backslashes before a quote, escaped or not,\n            -- need to be doubled.\n            -- See documentation for CommandLineToArgvW Windows function.\n            argument = '\"' .. argument:gsub([[(\\*)\"]], [[%1%1\\\"]]):gsub([[\\+$]], \"%0%0\") .. '\"'\n        end\n\n        -- os.execute() uses system() C function, which on Windows passes command\n        -- to cmd.exe. Escape its special characters.\n        return (argument:gsub('[\"^<>!|&%%]', \"^%0\"))\n    else\n        if argument == \"\" or argument:find('[^a-zA-Z0-9_@%+=:,.\/-]') then\n            -- To quote arguments on posix-like systems use single quotes.\n            -- To represent an embedded single quote close quoted string ('),\n            -- add escaped quote (\\'), open quoted string again (').\n            argument = \"'\" .. argument:gsub(\"'\", [['\\'']]) .. \"'\"\n        end\n\n        return argument\n    end\nend\n\n--- error out of this program gracefully.\n-- @param[opt] code The exit code, defaults to -`1` if omitted\n-- @param msg The exit message will be sent to `stderr` (will be formatted with the extra parameters)\n-- @param ... extra arguments for message's format'\n-- @see utils.fprintf\n-- @usage utils.quit(-1, \"Error '%s' happened\", \"42\")\n-- -- is equivalent to\n-- utils.quit(\"Error '%s' happened\", \"42\")  --> Error '42' happened\nfunction utils.quit(code, msg, ...)\n    if type(code) == 'string' then\n        utils.fprintf(io.stderr, code, msg, ...)\n        io.stderr:write('\\n')\n        code = -1 -- TODO: this is odd, see the test. Which returns 255 as exit code\n    elseif msg then\n        utils.fprintf(io.stderr, msg, ...)\n        io.stderr:write('\\n')\n    end\n    os.exit(code, true)\nend\n\n\n--- String functions\n-- @section string-functions\n\n--- escape any Lua 'magic' characters in a string\n-- @param s The input string\nfunction utils.escape(s)\n    utils.assert_string(1,s)\n    return (s:gsub('[%-%.%+%[%]%(%)%$%^%%%?%*]','%%%1'))\nend\n\n--- split a string into a list of strings separated by a delimiter.\n-- @param s The input string\n-- @param re optional A Lua string pattern; defaults to '%s+'\n-- @param plain optional If truthy don't use Lua patterns\n-- @param n optional maximum number of elements (if there are more, the last will remian un-split)\n-- @return a list-like table\n-- @raise error if s is not a string\n-- @see splitv\nfunction utils.split(s,re,plain,n)\n    utils.assert_string(1,s)\n    local i1,ls = 1,{}\n    if not re then re = '%s+' end\n    if re == '' then return {s} end\n    while true do\n        local i2,i3 = find(s,re,i1,plain)\n        if not i2 then\n            local last = sub(s,i1)\n            if last ~= '' then append(ls,last) end\n            if #ls == 1 and ls[1] == '' then\n                return {}\n            else\n                return ls\n            end\n        end\n        append(ls,sub(s,i1,i2-1))\n        if n and #ls == n then\n            ls[#ls] = sub(s,i1)\n            return ls\n        end\n        i1 = i3+1\n    end\nend\n\n--- split a string into a number of return values.\n-- Identical to `split` but returns multiple sub-strings instead of\n-- a single list of sub-strings.\n-- @param s the string\n-- @param re A Lua string pattern; defaults to '%s+'\n-- @param plain don't use Lua patterns\n-- @param n optional maximum number of splits\n-- @return n values\n-- @usage first,next = splitv('user=jane=doe','=', false, 2)\n-- assert(first == \"user\")\n-- assert(next == \"jane=doe\")\n-- @see split\nfunction utils.splitv (s,re, plain, n)\n    return _unpack(utils.split(s,re, plain, n))\nend\n\n\n--- Functional\n-- @section functional\n\n\n--- 'memoize' a function (cache returned value for next call).\n-- This is useful if you have a function which is relatively expensive,\n-- but you don't know in advance what values will be required, so\n-- building a table upfront is wasteful\/impossible.\n-- @param func a function of at least one argument\n-- @return a function with at least one argument, which is used as the key.\nfunction utils.memoize(func)\n    local cache = {}\n    return function(k)\n        local res = cache[k]\n        if res == nil then\n            res = func(k)\n            cache[k] = res\n        end\n        return res\n    end\nend\n\n\n--- associate a function factory with a type.\n-- A function factory takes an object of the given type and\n-- returns a function for evaluating it\n-- @tab mt metatable\n-- @func fun a callable that returns a function\nfunction utils.add_function_factory (mt,fun)\n    _function_factories[mt] = fun\nend\n\nlocal function _string_lambda(f)\n    if f:find '^|' or f:find '_' then\n        local args,body = f:match '|([^|]*)|(.+)'\n        if f:find '_' then\n            args = '_'\n            body = f\n        else\n            if not args then return raise 'bad string lambda' end\n        end\n        local fstr = 'return function('..args..') return '..body..' end'\n        local fn,err = utils.load(fstr)\n        if not fn then return raise(err) end\n        fn = fn()\n        return fn\n    else\n        return raise 'not a string lambda'\n    end\nend\n\n\n--- an anonymous function as a string. This string is either of the form\n-- '|args| expression' or is a function of one argument, '_'\n-- @param lf function as a string\n-- @return a function\n-- @function utils.string_lambda\n-- @usage\n-- string_lambda '|x|x+1' (2) == 3\n-- string_lambda '_+1' (2) == 3\nutils.string_lambda = utils.memoize(_string_lambda)\n\n\n--- bind the first argument of the function to a value.\n-- @param fn a function of at least two values (may be an operator string)\n-- @param p a value\n-- @return a function such that f(x) is fn(p,x)\n-- @raise same as @{function_arg}\n-- @see func.bind1\n-- @usage local function f(msg, name)\n--   print(msg .. \" \" .. name)\n-- end\n--\n-- local hello = utils.bind1(f, \"Hello\")\n--\n-- print(hello(\"world\"))     --> \"Hello world\"\n-- print(hello(\"sunshine\"))  --> \"Hello sunshine\"\nfunction utils.bind1 (fn,p)\n    fn = utils.function_arg(1,fn)\n    return function(...) return fn(p,...) end\nend\n\n\n--- bind the second argument of the function to a value.\n-- @param fn a function of at least two values (may be an operator string)\n-- @param p a value\n-- @return a function such that f(x) is fn(x,p)\n-- @raise same as @{function_arg}\n-- @usage local function f(a, b, c)\n--   print(a .. \" \" .. b .. \" \" .. c)\n-- end\n--\n-- local hello = utils.bind1(f, \"world\")\n--\n-- print(hello(\"Hello\", \"!\"))  --> \"Hello world !\"\n-- print(hello(\"Bye\", \"?\"))    --> \"Bye world ?\"\nfunction utils.bind2 (fn,p)\n    fn = utils.function_arg(1,fn)\n    return function(x,...) return fn(x,p,...) end\nend\n\n\n\n\n--- Deprecation\n-- @section deprecation\n\ndo\n  -- the default implementation\n  local deprecation_func = function(msg, trace)\n    if trace then\n      warn(msg, \"\\n\", trace)  -- luacheck: ignore\n    else\n      warn(msg)  -- luacheck: ignore\n    end\n  end\n\n  --- Sets a deprecation warning function.\n  -- An application can override this function to support proper output of\n  -- deprecation warnings. The warnings can be generated from libraries or\n  -- functions by calling `utils.raise_deprecation`. The default function\n  -- will write to the 'warn' system (introduced in Lua 5.4, or the compatibility\n  -- function from the `compat` module for earlier versions).\n  --\n  -- Note: only applications should set\/change this function, libraries should not.\n  -- @param func a callback with signature: `function(msg, trace)` both arguments are strings, the latter being optional.\n  -- @see utils.raise_deprecation\n  -- @usage\n  -- -- write to the Nginx logs with OpenResty\n  -- utils.set_deprecation_func(function(msg, trace)\n  --   ngx.log(ngx.WARN, msg, (trace and (\" \" .. trace) or nil))\n  -- end)\n  --\n  -- -- disable deprecation warnings\n  -- utils.set_deprecation_func()\n  function utils.set_deprecation_func(func)\n    if func == nil then\n      deprecation_func = function() end\n    else\n      utils.assert_arg(1, func, \"function\")\n      deprecation_func = func\n    end\n  end\n\n  --- raises a deprecation warning.\n  -- For options see the usage example below.\n  --\n  -- Note: the `opts.deprecated_after` field is the last version in which\n  -- a feature or option was NOT YET deprecated! Because when writing the code it\n  -- is quite often not known in what version the code will land. But the last\n  -- released version is usually known.\n  -- @param opts options table\n  -- @see utils.set_deprecation_func\n  -- @usage\n  -- warn(\"@on\")   -- enable Lua warnings, they are usually off by default\n  --\n  -- function stringx.islower(str)\n  --   raise_deprecation {\n  --     source = \"Penlight \" .. utils._VERSION,                   -- optional\n  --     message = \"function 'islower' was renamed to 'is_lower'\", -- required\n  --     version_removed = \"2.0.0\",                                -- optional\n  --     deprecated_after = \"1.2.3\",                               -- optional\n  --     no_trace = true,                                          -- optional\n  --   }\n  --   return stringx.is_lower(str)\n  -- end\n  -- -- output: \"[Penlight 1.9.2] function 'islower' was renamed to 'is_lower' (deprecated after 1.2.3, scheduled for removal in 2.0.0)\"\n  function utils.raise_deprecation(opts)\n    utils.assert_arg(1, opts, \"table\")\n    if type(opts.message) ~= \"string\" then\n      error(\"field 'message' of the options table must be a string\", 2)\n    end\n    local trace\n    if not opts.no_trace then\n      trace = debug.traceback(\"\", 2):match(\"[\\n%s]*(.-)$\")\n    end\n    local msg\n    if opts.deprecated_after and opts.version_removed then\n      msg = (\" (deprecated after %s, scheduled for removal in %s)\"):format(\n        tostring(opts.deprecated_after), tostring(opts.version_removed))\n    elseif opts.deprecated_after then\n      msg = (\" (deprecated after %s)\"):format(tostring(opts.deprecated_after))\n    elseif opts.version_removed then\n      msg = (\" (scheduled for removal in %s)\"):format(tostring(opts.version_removed))\n    else\n      msg = \"\"\n    end\n\n    msg = opts.message .. msg\n\n    if opts.source then\n      msg = \"[\" .. opts.source ..\"] \" .. msg\n    else\n      if msg:sub(1,1) == \"@\" then\n        -- in Lua 5.4 \"@\" prefixed messages are control messages to the warn system\n        error(\"message cannot start with '@'\", 2)\n      end\n    end\n\n    deprecation_func(msg, trace)\n  end\n\nend\n\n\nreturn utils\n\n"},{"name":"\/Users\/nascarsayan\/Code\/github.com\/nascarsayan\/sqids-lua\/lua_modules\/share\/lua\/5.4\/say\/init.lua","coverage":[0,null,0,null,null,null,0,null,null,null,null,null,null,3,3,0,null,null,null,null,0,0,0,null,null,null,null,57,null,null,null,0,null,513,0,null,513,513,null,513,null,513,0,null,513,513,null,2067,1554,null,null,513,null,null,null,0,null,null,null,0,0,null,0,null,0],"source":"local unpack = table.unpack or unpack\n\nlocal registry = { }\nlocal current_namespace\nlocal fallback_namespace\n\nlocal s = {\n\n  _COPYRIGHT   = \"Copyright (c) 2012 Olivine Labs, LLC.\",\n  _DESCRIPTION = \"A simple string key\/value store for i18n or any other case where you want namespaced strings.\",\n  _VERSION     = \"Say 1.3\",\n\n  set_namespace = function(self, namespace)\n    current_namespace = namespace\n    if not registry[current_namespace] then\n      registry[current_namespace] = {}\n    end\n  end,\n\n  set_fallback = function(self, namespace)\n    fallback_namespace = namespace\n    if not registry[fallback_namespace] then\n      registry[fallback_namespace] = {}\n    end\n  end,\n\n  set = function(self, key, value)\n    registry[current_namespace][key] = value\n  end\n}\n\nlocal __meta = {\n  __call = function(self, key, vars)\n    if vars ~= nil and type(vars) ~= \"table\" then\n      error((\"expected parameter table to be a table, got '%s'\"):format(type(vars)), 2)\n    end\n    vars = vars or {}\n    vars.n = math.max((vars.n or 0), #vars)\n\n    local str = registry[current_namespace][key] or registry[fallback_namespace][key]\n\n    if str == nil then\n      return nil\n    end\n    str = tostring(str)\n    local strings = {}\n\n    for i = 1, vars.n or #vars do\n      table.insert(strings, tostring(vars[i]))\n    end\n\n    return #strings > 0 and str:format(unpack(strings)) or str\n  end,\n\n  __index = function(self, key)\n    return registry[key]\n  end\n}\n\ns:set_fallback('en')\ns:set_namespace('en')\n\ns._registry = registry\n\nreturn setmetatable(s, __meta)"},{"name":"\/Users\/nascarsayan\/Code\/github.com\/nascarsayan\/sqids-lua\/lua_modules\/share\/lua\/5.4\/sqids.lua","coverage":[null,null,null,12,null,12,12,12,12,12,null,12,null,null,12,12,0,null,null,12,12,null,12,12,0,null,null,12,12,null,null,1218,1218,72129,70911,null,null,1218,null,1764,1764,1764,null,1218,null,null,null,366,null,156774,156465,112557,1965,30,null,110592,69765,12,null,40827,15,null,null,null,null,309,null,null,null,null,null,null,1149,null,null,null,null,1074,65265,64191,null,null,1074,2589,1515,null,null,1074,null,null,null,null,216,12630,12417,12417,3,null,12414,null,213,null,null,null,null,2067,127230,125163,null,null,125163,123096,123096,123096,null,null,2067,null,null,null,null,372,null,null,372,6,null,null,null,366,1584,1218,null,366,null,null,366,null,null,366,null,null,366,null,null,366,null,null,366,null,null,1584,null,1218,1218,null,null,1218,null,852,null,null,852,null,null,null,null,366,null,null,366,null,159,null,null,null,282,123,123,null,null,null,null,366,57,null,null,342,null,null,12,222,null,222,222,222,null,null,222,3,null,null,219,3,null,null,216,3,null,null,null,213,6,null,null,null,207,12246,99390,99183,99183,762177,99183,95850,null,null,null,null,207,207,207,207,null,null,207,207,null,null,null,12,null,321,0,null,null,null,321,1461,1146,1140,null,6,null,null,null,315,null,null,null,12,297,null,null,297,3,null,null,null,294,18081,17787,null,null,6726,6435,6435,203757,203754,6432,6432,null,null,null,6435,3,null,null,null,null,291,null,null,291,null,null,291,null,null,291,null,null,291,null,null,1365,1167,null,null,1167,4191,3024,null,null,1167,null,1167,93,null,null,null,1074,1074,null,null,1074,885,null,null,null,null,1074,null,null,198,null,null,12],"source":"-- package.cpath = \"lua_modules\/lib\/lua\/5.4\/?.so;\" .. package.path\n-- package.path = \"lua_modules\/share\/lua\/5.4\/?.lua;\" .. package.path\n\nlocal cjson = require \"cjson\"\n\nDefaultOptions = {\n    alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\",\n    minLength = 0,\n    blocklist = {}\n}\n\nlocal minLengthLimit = 255\n\n-- Load blocklist from blocklist.json file\nlocal blocklistFile = io.open(\"blocklist.json\", \"r\")\nif not blocklistFile then\n    error(\"Cannot open blocklist.json\")\nend\n\nlocal blocklistData = blocklistFile:read(\"*all\")\nblocklistFile:close()\n\nlocal success, defaultBlocklist = pcall(cjson.decode, blocklistData)\nif not success or type(defaultBlocklist) ~= \"table\" then\n    error(\"Invalid blocklist data in blocklist.json\")\nend\n\nlocal Sqids = {}\nSqids.__index = Sqids\n\nlocal function toId(num, alphabet)\n    local id = {}\n    local chars = {}\n    for i = 1, #alphabet do\n        table.insert(chars, alphabet:sub(i, i))\n    end\n\n    local result = num\n    repeat\n        table.insert(id, 1, chars[result % #chars + 1])\n        result = math.floor(result \/ #chars)\n    until result <= 0\n\n    return table.concat(id)\nend\n\nlocal function isBlockedId(id, blocklist)\n    id = id:lower()\n\n    for _, word in ipairs(blocklist) do\n        if #word <= #id then\n            if #id <= 3 or #word <= 3 then\n                if id == word then\n                    return true\n                end\n            elseif string.match(word, \"%d\") then\n                if id:sub(1, #word) == word or id:sub(#id - #word + 1) == word then\n                    return true\n                end\n            elseif string.find(id, word) then\n                return true\n            end\n        end\n    end\n\n    return false\nend\n\n-- Helper function to determine the maximum unsigned integer value based on Lua's capabilities\nlocal function maxValue()\n    -- Determine the maximum unsigned integer value based on Lua's capabilities\n    -- For Lua, it's typically 2^53 - 1 due to number representation\n    return 2 ^ 53 - 1\nend\n\n-- Helper function to convert an ID to a number\nlocal function toNumber(id, alphabet)\n    local charIdx = {}\n    for i = 1, #alphabet do\n        charIdx[alphabet:sub(i, i)] = i - 1\n    end\n\n    local result = 0\n    for i = 1, #id do\n        result = result * #alphabet + charIdx[id:sub(i, i)]\n    end\n\n    return result\nend\n\n-- Helper function to check if a string contains unique characters\nlocal function hasUniqueChars(str)\n    local charSet = {}\n    for i = 1, #str do\n        local c = str:sub(i, i)\n        if charSet[c] then\n            return false\n        end\n        charSet[c] = true\n    end\n    return true\nend\n\n-- consistent shuffle (always produces the same result given the input)\nlocal function shuffle(alphabet)\n    local chars = {}\n    for i = 1, #alphabet do\n        table.insert(chars, alphabet:sub(i, i))\n    end\n\n    for i = 1, #chars - 1 do\n        local j = #chars - i + 1\n        local r = (i * j + chars[i]:byte() + chars[j]:byte()) % #chars + 1\n        chars[i], chars[r] = chars[r], chars[i]\n    end\n\n    return table.concat(chars)\nend\n\n-- encodeNumbers function (internal) in Lua\nlocal function encodeNumbers(sq, numbers, increment)\n    increment = increment or 0 -- Default value for increment\n\n    -- if increment is greater than alphabet length, we've reached max attempts\n    if increment > #sq.alphabet then\n        error('Reached max attempts to re-generate the ID')\n    end\n\n    -- get a semi-random offset from input numbers\n    local offset = 0\n    for i, v in ipairs(numbers) do\n        offset = sq.alphabet:byte(v % #sq.alphabet + 1) + i + offset\n    end\n    offset = offset % #sq.alphabet\n\n    -- if there is a non-zero `increment`, it's an internal attempt to re-generate the ID\n    offset = (offset + increment) % #sq.alphabet\n\n    -- re-arrange alphabet so that second-half goes in front of the first-half\n    local alphabet = sq.alphabet:sub(offset + 1) .. sq.alphabet:sub(1, offset)\n\n    -- `prefix` is the first character in the generated ID, used for randomization\n    local prefix = alphabet:sub(1, 1)\n\n    -- reverse alphabet (otherwise for [0, x] `offset` and `separator` will be the same char)\n    alphabet = alphabet:reverse()\n\n    -- final ID will always have the `prefix` character at the beginning\n    local ret = { prefix }\n\n    -- encode input array\n    for i, num in ipairs(numbers) do\n        -- the first character of the alphabet is going to be reserved for the `separator`\n        local alphabetWithoutSeparator = alphabet:sub(2)\n        table.insert(ret, toId(num, alphabetWithoutSeparator))\n\n        -- if not the last number\n        if i < #numbers then\n            -- `separator` character is used to isolate numbers within the ID\n            table.insert(ret, alphabet:sub(1, 1))\n\n            -- shuffle on every iteration\n            alphabet = shuffle(alphabet)\n        end\n    end\n\n    -- join all the parts to form an ID\n    local id = table.concat(ret, '')\n\n    -- handle `minLength` requirement, if the ID is too short\n    if sq.minLength > #id then\n        -- append a separator\n        id = id .. alphabet:sub(1, 1)\n\n        -- keep appending `separator` + however much alphabet is needed\n        -- for decoding: two separators next to each other is what tells us the rest are junk characters\n        while sq.minLength - #id > 0 do\n            alphabet = shuffle(alphabet)\n            id = id .. alphabet:sub(1, math.min(sq.minLength - #id, #alphabet))\n        end\n    end\n\n    -- if ID has a blocked word anywhere, restart with a +1 increment\n    if isBlockedId(id, sq.blocklist) then\n        id = encodeNumbers(sq, numbers, increment + 1)\n    end\n\n    return id\nend\n\nfunction Sqids.new(options)\n    options = options or {}\n\n    local alphabet = options.alphabet or DefaultOptions.alphabet\n    local minLength = options.minLength or DefaultOptions.minLength\n    local blocklist = options.blocklist or defaultBlocklist\n\n    -- Validate the alphabet\n    if #alphabet ~= utf8.len(alphabet) then\n        error('Alphabet cannot contain multibyte characters')\n    end\n\n    if #alphabet < 3 then\n        error('Alphabet length must be at least 3')\n    end\n\n    if not hasUniqueChars(alphabet) then\n        error('Alphabet must contain unique characters')\n    end\n\n    -- Validate the minimum length\n    if type(minLength) ~= 'number' or minLength < 0 or minLength > minLengthLimit then\n        error('Minimum length has to be between 0 and ' .. minLengthLimit)\n    end\n\n    -- Filter the blocklist\n    local filteredBlocklist = {}\n    local alphabetChars = alphabet:lower():gsub('.', function(c) return c .. '\\1' end)\n    for _, word in ipairs(blocklist) do\n        if #word >= 3 then\n            local wordLowercased = word:lower()\n            local intersection = wordLowercased:gsub('.', function(c) return alphabetChars:find(c, 1, true) and c or '' end)\n            if intersection == wordLowercased then\n                table.insert(filteredBlocklist, wordLowercased)\n            end\n        end\n    end\n\n    local instance = {\n        alphabet = shuffle(alphabet),\n        minLength = minLength,\n        blocklist = filteredBlocklist\n    }\n\n    setmetatable(instance, Sqids)\n    return instance\nend\n\n-- encode function in Lua\nfunction Sqids:encode(numbers)\n    -- if no numbers passed, return an empty string\n    if #numbers == 0 then\n        return ''\n    end\n\n    -- don't allow out-of-range numbers [might be lang-specific]\n    local inRangeNumbers = {}\n    for _, n in ipairs(numbers) do\n        if n >= 0 and n <= maxValue() then\n            table.insert(inRangeNumbers, n)\n        else\n            error(\"Encoding supports numbers between 0 and \" .. maxValue())\n        end\n    end\n\n    return encodeNumbers(self, numbers)\nend\n\n-- Decode function in Lua\nfunction Sqids:decode(id)\n    local ret = {} -- Array of unsigned integers\n\n    -- if an empty string, return an empty array\n    if id == '' then\n        return ret\n    end\n\n    -- if a character is not in the alphabet, return an empty array\n    local alphabetChars = {}\n    for i = 1, #self.alphabet do\n        table.insert(alphabetChars, self.alphabet:sub(i, i))\n    end\n\n    for i = 1, #id do\n        local c = id:sub(i, i)\n        local found = false\n        for _, char in ipairs(alphabetChars) do\n            if char == c then\n                found = true\n                break\n            end\n        end\n\n        if not found then\n            return ret\n        end\n    end\n\n    -- first character is always the `prefix`\n    local prefix = id:sub(1, 1)\n\n    -- `offset` is the semi-random position that was generated during encoding\n    local offset = self.alphabet:find(prefix, 1, true)\n\n    -- re-arrange alphabet back into its original form\n    local alphabet = self.alphabet:sub(offset) .. self.alphabet:sub(1, offset - 1)\n\n    -- reverse alphabet\n    alphabet = alphabet:reverse()\n\n    -- now it's safe to remove the prefix character from ID, it's not needed anymore\n    id = id:sub(2)\n\n    -- decode\n    while #id > 0 do\n        local separator = alphabet:sub(1, 1)\n\n        -- we need the first part to the left of the separator to decode the number\n        local chunks = {}\n        for chunk in id:gmatch(string.format(\"([^%s]*)\", separator)) do\n            table.insert(chunks, chunk)\n        end\n\n        if #chunks > 0 then\n            -- if chunk is empty, we are done (the rest are junk characters)\n            if chunks[1] == '' then\n                return ret\n            end\n\n            -- decode the number without using the `separator` character\n            local alphabetWithoutSeparator = alphabet:sub(2)\n            table.insert(ret, toNumber(chunks[1], alphabetWithoutSeparator))\n\n            -- if this ID has multiple numbers, shuffle the alphabet because that's what encoding function did\n            if #chunks > 1 then\n                alphabet = shuffle(alphabet)\n            end\n        end\n\n        -- `id` is now going to be everything to the right of the `separator`\n        id = table.concat(chunks, separator, 2)\n    end\n\n    return ret\nend\n\nreturn Sqids"},{"name":"\/Users\/nascarsayan\/Code\/github.com\/nascarsayan\/sqids-lua\/lua_modules\/share\/lua\/5.4\/term\/colors.lua","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,0,null,0,null,0,null,0,1122,null,null,0,1122,null,null,0,561,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,0],"source":"-- Copyright (c) 2009 Rob Hoelz <rob@hoelzro.net>\n--\n-- Permission is hereby granted, free of charge, to any person obtaining a copy\n-- of this software and associated documentation files (the \"Software\"), to deal\n-- in the Software without restriction, including without limitation the rights\n-- to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell\n-- copies of the Software, and to permit persons to whom the Software is\n-- furnished to do so, subject to the following conditions:\n--\n-- The above copyright notice and this permission notice shall be included in\n-- all copies or substantial portions of the Software.\n--\n-- THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n-- THE SOFTWARE.\n\nlocal pairs = pairs\nlocal tostring = tostring\nlocal setmetatable = setmetatable\nlocal schar = string.char\n\nlocal colors = {}\n\nlocal colormt = {}\n\nfunction colormt:__tostring()\n    return self.value\nend\n\nfunction colormt:__concat(other)\n    return tostring(self) .. tostring(other)\nend\n\nfunction colormt:__call(s)\n    return self .. s .. colors.reset\nend\n\nlocal function makecolor(value)\n    return setmetatable({ value = schar(27) .. '[' .. tostring(value) .. 'm' }, colormt)\nend\n\nlocal colorvalues = {\n    -- attributes\n    reset      = 0,\n    clear      = 0,\n    default    = 0,\n    bright     = 1,\n    dim        = 2,\n    underscore = 4,\n    blink      = 5,\n    reverse    = 7,\n    hidden     = 8,\n\n    -- foreground\n    black   = 30,\n    red     = 31,\n    green   = 32,\n    yellow  = 33,\n    blue    = 34,\n    magenta = 35,\n    cyan    = 36,\n    white   = 37,\n\n    -- background\n    onblack   = 40,\n    onred     = 41,\n    ongreen   = 42,\n    onyellow  = 43,\n    onblue    = 44,\n    onmagenta = 45,\n    oncyan    = 46,\n    onwhite   = 47,\n}\n\nfor c, v in pairs(colorvalues) do\n    colors[c] = makecolor(v)\nend\n\nreturn colors"}],"git":{"remotes":[{"url":"git@github.com:nascarsayan\/sqids-lua ","name":"mine"},{"url":"https:\/\/github.com\/sqids\/sqids-lua\/ ","name":"origin"}],"branch":"actions","head":{"committer_email":"nascarsayan@gmail.com","id":"9e53f1d4a8ab0744ad6dabcdce72f78318e5f77f","author_email":"nascarsayan@gmail.com","message":"actions fix 4","committer_name":"Sayan Naskar","author_name":"Sayan Naskar"}}}